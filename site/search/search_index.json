{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Qiang Liu's Homepage Introduction Hi, my name is Qiang Liu. I am currently a Ph.D. student at the College of Computer Science of Zhejiang University (ZJU), Hangzhou, China. I visited HEXHIVE at EPFL from 2021.08 to 2022.03. My research interests include system and software security. It is welcome to contact me by email at cyruscyliu@gmail.com. CV Google Scholar GitHub Twitter News Our Paper \"ECMO: Peripheral Transplantation to Rehost Embedded Linux Kernels\" got accepted at CCS'21! Our Paper \"FirmGuide: Boosting the Capability of Rehosting Embedded Linux Kernels through Model-Guided Kernel Execution\" got accepted at @ASE_conf 2021! #ASE2021 @zhclhy @JMuhui @yajinzhou. Projects, Publications, and Real Impact 0x02 Embedded System Rehosting This project tries to rehost embedded Linux kernels for routers, cameras, and other high-end devices. Then, we can dynamically analyze bugs or vulnerabilities, detect bugs or vulnerabilities, make honey pots, detect and inspect malware. Relative research papers are FirmGuide (ASE'21, co-first-authors) , and ECMO (CCS'21, 4th author) . We open source the following projects. + pyqemulog is the qemu-log ported to Python. It converts the structured trace generated by QEMU with -d to JSON. (Author and Maintainer) llbic , which is short for LLVM Linux Build Issues Collection, helps compile old Linux kernels in LLVM bitcode. It replaces GCC to clang and adjusts other flags in the make command lines to generate bitcode files, and then links them all together to a vmlinux.bc . (Co-authors and Maintainer) openwrt-build-docker supports automatically building the OpenWrt project given a target/subtarget of a specific OpenWrt revision from 10.03 to 19.07.1. (Co-author and Maintainer) FirmGuide can help you to develop a QEMU virtual machine for a Linux-based embedded system, especially boosting the capability of dynamic analysis of the corresponding Linux kernel. In the emulator, you can debug, trace, and test the Linux kernel to collect runtime information that can be used to understand vulnerabilities, PoCs, root causes of crashes in the Linux kernel. FirmGuide is an effectively complementary to Firmadyne that focuses on user space programs - FirmGuide focuses on the Linux kernel. (Co-author and Maintainer) ECMO receives a firmware image, and it can successfully re-host the Linux kernel inside the image to get the shell. Due to the variety of peripherals in embedded firmware images. It is rather hard to build a general emulator that supports all kinds of machines. The basic idea of ECMO is to transplant the peripherals by support ones into the target Linux kernel, hence solve the problem of peripheral variety. (Maintainer) 0x01 Android Authentication This project tries to evaluate existing and propose new implicit continuous authentication approaches. The implicit continuous authentication can be a second authentication factor for fingerprint and face identification. I joined this project as an intern and then proposed this project to be my final project for my Bachelor's degree. Relative research papers are RiskCog (TMC'20) , ESPIALCOG (TMC'20)(5th author) , and One Cycle Attack (TIFS'20) (3rd author) . 0x00 Network Protocol Fuzzing (Archived) This project tries to fuzz network protocols, especially router protocols. I joined this project as an intern and wrote several Peach Pits by 1) learning the grammar of Peach Pit, 2) understanding specific network protocols via their specifications. Blogs Please raise issues if any questions or comments. 2021-12-13 A brief summary of CS-725 2021-11-03 Coverage Control in libFuzzer 2021-11-18 ASE'21 - FirmGuide 2021-10-27 Introduction to Bhyve 2021-10-24 CS-725 Presentation - Fuzz Testing 2021-08-18 Display in QEMU 2020-11-30 Clang, wllvm, passes, QEMU for x86_64 2020-11-18 Buildroot, QEMU and Linux kernel for x86_64 Summary when visiting EPFL in 2021 0x10 How to Do [System|Software] (Security) Research 0x0f Programming Skills for Research 0x0e Principles of Research Presentation Summary after CCS 2019 (London) 0x0d Summary of CCS'19 (London) Blogs when living Hangzhou in 2018 0x0c \u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u4e8c\u5341\u4e03\u5929 0x0b \u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u5341\u5929 0x0a \u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u4e5d\u5929 0x09 \u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u4e09\u5929 0x08 \u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u4e8c\u5929 0x07 \u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u4e00\u5929 Blogs when visiting ANU in early 2018 0x06 ANU\u6691\u671f\u5b66\u6821-\u5c3e\u58f0 0x05 ANU\u6691\u671f\u5b66\u6821-\u751f\u6d3b\u548c\u5de5\u4f5c 0x04 ANU\u6691\u671f\u5b66\u6821-\u60ca\u5947 0x03 ANU\u6691\u671f\u5b66\u6821-\u6211\u7684\u77db\u76fe 0x02 ANU\u6691\u671f\u5b66\u6821-\u6211\u7684\u77db\u76fe\uff08\u63d0\u7eb2\uff09 0x01 ANU\u6691\u671f\u5b66\u6821-\u7efd\u653e 0x00 ANU\u6691\u671f\u5b66\u6821-\u65e0\u9898","title":"Qiang Liu's Homepage"},{"location":"#qiang-lius-homepage","text":"","title":"Qiang Liu's Homepage"},{"location":"#introduction","text":"Hi, my name is Qiang Liu. I am currently a Ph.D. student at the College of Computer Science of Zhejiang University (ZJU), Hangzhou, China. I visited HEXHIVE at EPFL from 2021.08 to 2022.03. My research interests include system and software security. It is welcome to contact me by email at cyruscyliu@gmail.com. CV Google Scholar GitHub Twitter","title":"Introduction"},{"location":"#news","text":"Our Paper \"ECMO: Peripheral Transplantation to Rehost Embedded Linux Kernels\" got accepted at CCS'21! Our Paper \"FirmGuide: Boosting the Capability of Rehosting Embedded Linux Kernels through Model-Guided Kernel Execution\" got accepted at @ASE_conf 2021! #ASE2021 @zhclhy @JMuhui @yajinzhou.","title":"News"},{"location":"#projects-publications-and-real-impact","text":"","title":"Projects, Publications, and Real Impact"},{"location":"#0x02-embedded-system-rehosting","text":"This project tries to rehost embedded Linux kernels for routers, cameras, and other high-end devices. Then, we can dynamically analyze bugs or vulnerabilities, detect bugs or vulnerabilities, make honey pots, detect and inspect malware. Relative research papers are FirmGuide (ASE'21, co-first-authors) , and ECMO (CCS'21, 4th author) . We open source the following projects. + pyqemulog is the qemu-log ported to Python. It converts the structured trace generated by QEMU with -d to JSON. (Author and Maintainer) llbic , which is short for LLVM Linux Build Issues Collection, helps compile old Linux kernels in LLVM bitcode. It replaces GCC to clang and adjusts other flags in the make command lines to generate bitcode files, and then links them all together to a vmlinux.bc . (Co-authors and Maintainer) openwrt-build-docker supports automatically building the OpenWrt project given a target/subtarget of a specific OpenWrt revision from 10.03 to 19.07.1. (Co-author and Maintainer) FirmGuide can help you to develop a QEMU virtual machine for a Linux-based embedded system, especially boosting the capability of dynamic analysis of the corresponding Linux kernel. In the emulator, you can debug, trace, and test the Linux kernel to collect runtime information that can be used to understand vulnerabilities, PoCs, root causes of crashes in the Linux kernel. FirmGuide is an effectively complementary to Firmadyne that focuses on user space programs - FirmGuide focuses on the Linux kernel. (Co-author and Maintainer) ECMO receives a firmware image, and it can successfully re-host the Linux kernel inside the image to get the shell. Due to the variety of peripherals in embedded firmware images. It is rather hard to build a general emulator that supports all kinds of machines. The basic idea of ECMO is to transplant the peripherals by support ones into the target Linux kernel, hence solve the problem of peripheral variety. (Maintainer)","title":"0x02 Embedded System Rehosting"},{"location":"#0x01-android-authentication","text":"This project tries to evaluate existing and propose new implicit continuous authentication approaches. The implicit continuous authentication can be a second authentication factor for fingerprint and face identification. I joined this project as an intern and then proposed this project to be my final project for my Bachelor's degree. Relative research papers are RiskCog (TMC'20) , ESPIALCOG (TMC'20)(5th author) , and One Cycle Attack (TIFS'20) (3rd author) .","title":"0x01 Android Authentication"},{"location":"#0x00-network-protocol-fuzzing-archived","text":"This project tries to fuzz network protocols, especially router protocols. I joined this project as an intern and wrote several Peach Pits by 1) learning the grammar of Peach Pit, 2) understanding specific network protocols via their specifications.","title":"0x00 Network Protocol Fuzzing (Archived)"},{"location":"#blogs","text":"Please raise issues if any questions or comments. 2021-12-13 A brief summary of CS-725 2021-11-03 Coverage Control in libFuzzer 2021-11-18 ASE'21 - FirmGuide 2021-10-27 Introduction to Bhyve 2021-10-24 CS-725 Presentation - Fuzz Testing 2021-08-18 Display in QEMU 2020-11-30 Clang, wllvm, passes, QEMU for x86_64 2020-11-18 Buildroot, QEMU and Linux kernel for x86_64","title":"Blogs"},{"location":"#summary-when-visiting-epfl-in-2021","text":"0x10 How to Do [System|Software] (Security) Research 0x0f Programming Skills for Research 0x0e Principles of Research Presentation","title":"Summary when visiting EPFL in 2021"},{"location":"#summary-after-ccs-2019-london","text":"0x0d Summary of CCS'19 (London)","title":"Summary after CCS 2019 (London)"},{"location":"#blogs-when-living-hangzhou-in-2018","text":"0x0c \u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u4e8c\u5341\u4e03\u5929 0x0b \u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u5341\u5929 0x0a \u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u4e5d\u5929 0x09 \u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u4e09\u5929 0x08 \u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u4e8c\u5929 0x07 \u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u4e00\u5929","title":"Blogs when living Hangzhou in 2018"},{"location":"#blogs-when-visiting-anu-in-early-2018","text":"0x06 ANU\u6691\u671f\u5b66\u6821-\u5c3e\u58f0 0x05 ANU\u6691\u671f\u5b66\u6821-\u751f\u6d3b\u548c\u5de5\u4f5c 0x04 ANU\u6691\u671f\u5b66\u6821-\u60ca\u5947 0x03 ANU\u6691\u671f\u5b66\u6821-\u6211\u7684\u77db\u76fe 0x02 ANU\u6691\u671f\u5b66\u6821-\u6211\u7684\u77db\u76fe\uff08\u63d0\u7eb2\uff09 0x01 ANU\u6691\u671f\u5b66\u6821-\u7efd\u653e 0x00 ANU\u6691\u671f\u5b66\u6821-\u65e0\u9898","title":"Blogs when visiting ANU in early 2018"},{"location":"posts/2018-01-19-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E6%88%91%E7%9A%84%E7%9F%9B%E7%9B%BE%EF%BC%88%E6%8F%90%E7%BA%B2%EF%BC%89/","text":"ANU\u6691\u671f\u5b66\u6821-\u6211\u7684\u77db\u76fe\uff08\u63d0\u7eb2\uff09 \u7eaf\u7cb9\u751f\u6d3b\u4e0e\u7eaf\u7cb9\u5de5\u4f5c\u662f\u4e0d\u53ef\u8c03\u548c\u7684\u3002\u4ed6\u4eec\u7684\u53e6\u4e00\u4e0d\u540c\u5728\u4e8e\u7eaf\u7cb9\u751f\u6d3b\u4f1a\u8ba9\u4eba\u5feb\u901f\u9677\u5165\u8ff7\u9189\u4e4b\u4e2d\uff0c\u81f3\u5c11\u4e00\u5468\u6216\u51e0\u4ef6\u5927\u4e8b\uff0c\u624d\u8ba9\u4eba\u9192\u609f\uff1b\u800c\u540e\u8005\u8ba9\u4eba\u65f6\u65f6\u523b\u523b\u90fd\u5145\u6ee1\u4e86\u7126\u8651\u3002 \u603b\u7ed3\u8fc7\u53bb\u534a\u5e74\u7684\u79d1\u7814\u751f\u6d3b\u4e0e\u672c\u5468\u77ed\u6682\u7684\u65b0\u5c1d\u8bd5\u8fdb\u884c\u5bf9\u6bd4\u3002\u91cd\u70b9\u8c08\u8bba\u5fc3\u6001\u3001\u65f6\u95f4\u95ee\u9898\u3002\u53ef\u4ee5\u7ed3\u5408\u4e0eZ\u541b\u7684\u53d9\u65e7\u4e4b\u8bed\uff0c\u56de\u987e\uff08\u518d\u4e00\u6b21\uff09\u5927\u5b66\u751f\u6d3b\u3001\u5fc3\u8def\u5386\u7a0b\u3002\u63a2\u7d22\u81ea\u5df1\u7684\u5bfb\u627e\u7684\u53ef\u80fd\u6027\u4e0e\u751f\u6d3b\u7684\u8c03\u5242\u3002","title":"ANU\u6691\u671f\u5b66\u6821-\u6211\u7684\u77db\u76fe\uff08\u63d0\u7eb2\uff09"},{"location":"posts/2018-01-19-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E6%88%91%E7%9A%84%E7%9F%9B%E7%9B%BE%EF%BC%88%E6%8F%90%E7%BA%B2%EF%BC%89/#anu-","text":"\u7eaf\u7cb9\u751f\u6d3b\u4e0e\u7eaf\u7cb9\u5de5\u4f5c\u662f\u4e0d\u53ef\u8c03\u548c\u7684\u3002\u4ed6\u4eec\u7684\u53e6\u4e00\u4e0d\u540c\u5728\u4e8e\u7eaf\u7cb9\u751f\u6d3b\u4f1a\u8ba9\u4eba\u5feb\u901f\u9677\u5165\u8ff7\u9189\u4e4b\u4e2d\uff0c\u81f3\u5c11\u4e00\u5468\u6216\u51e0\u4ef6\u5927\u4e8b\uff0c\u624d\u8ba9\u4eba\u9192\u609f\uff1b\u800c\u540e\u8005\u8ba9\u4eba\u65f6\u65f6\u523b\u523b\u90fd\u5145\u6ee1\u4e86\u7126\u8651\u3002 \u603b\u7ed3\u8fc7\u53bb\u534a\u5e74\u7684\u79d1\u7814\u751f\u6d3b\u4e0e\u672c\u5468\u77ed\u6682\u7684\u65b0\u5c1d\u8bd5\u8fdb\u884c\u5bf9\u6bd4\u3002\u91cd\u70b9\u8c08\u8bba\u5fc3\u6001\u3001\u65f6\u95f4\u95ee\u9898\u3002\u53ef\u4ee5\u7ed3\u5408\u4e0eZ\u541b\u7684\u53d9\u65e7\u4e4b\u8bed\uff0c\u56de\u987e\uff08\u518d\u4e00\u6b21\uff09\u5927\u5b66\u751f\u6d3b\u3001\u5fc3\u8def\u5386\u7a0b\u3002\u63a2\u7d22\u81ea\u5df1\u7684\u5bfb\u627e\u7684\u53ef\u80fd\u6027\u4e0e\u751f\u6d3b\u7684\u8c03\u5242\u3002","title":"ANU\u6691\u671f\u5b66\u6821-\u6211\u7684\u77db\u76fe\uff08\u63d0\u7eb2\uff09"},{"location":"posts/2018-01-21-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E6%83%8A%E5%A5%87/","text":"ANU\u6691\u671f\u5b66\u6821-\u60ca\u5947 \u5e8f \u8fd9\u7bc7\u6587\u7ae0\u624d\u662f\u5728ANU\u6691\u671f\u5b66\u6821\u5199\u4e0b\u7684\u7b2c\u4e00\u7bc7\u6587\u7ae0\uff0c\u7f16\u8f91\u7684\u65f6\u5019\u628a\u5b83\u5fd8\u6389\u4e86\u3002\u7b2c\u4e00\u8ba9\u4eba\u5360\u4e86\u53bb\uff0c\u59d1\u4e14\u843d\u4e2a\u7b2c\u4e94\u540d\u7f62\uff01 \u6b63\u6587 \u4e2d\u56fd\u4eba\u5f88\u65e9\u5c31\u63cf\u8ff0\u8fc7\u4fef\u77b0\u4e4b\u666f\u8272\uff0c\u6bd4\u5982\u201c\u6797\u6d77\u96ea\u539f\u201d\u3001\u201c\u677e\u6d9b\u9635\u9635\u201d\u4e4b\u7c7b\u7684\u3002\u4e2d\u56fd\u4eba\u4e5f\u5411\u5f80\u98de\u884c\uff0c\u5f53\u6211\u4e58\u5750\u7740\u6ce2\u97f3787\u7ff1\u7fd4\u572812500\u516c\u5c3a\u7684\u9ad8\u7a7a\u4e2d\uff0c\u900f\u7740\u5c0f\u7a97\u5ba1\u89c6\u56db\u5468\u65f6\uff0c\u65f6\u95f4\u548c\u7a7a\u95f4\u90fd\u51dd\u56fa\u4e86\uff0c\u4e0d\u6d41\u52a8\u4ea6\u65e0\u6240\u5c3d\uff1b\u8fd9\u4e91\u6d77\u662f\u9759\u7684\uff0c\u662f\u6ce2\u6d9b\u6c79\u6d8c\u65f6\u5019\u7684\u5b9a\u683c\uff1b\u8fd9\u4e91\u6d77\u662f\u74f7\u76d8\uff0c\u9752\u82b1\u7f8e\u5999\u3001\u5929\u7a79\u8986\u76d6\u3002\u5fc3\u91cc\u662f\u60ca\u53f9\uff0c\u8111\u4e2d\u662f\u7ffb\u6d8c\u3002\u4e2d\u56fd\u53e4\u4ee3\u6587\u4eba\uff0c\u8981\u662f\u6709\u4e00\u4e2a\u80fd\u629f\u6276\u6447\u76f4\u4e0a\u4e5d\u4e07\u91cc\uff0c\u4ed6\u5c06\u5199\u4e0b\u600e\u6837\u7684\u5343\u53e4\u540d\u7bc7\uff1f\u60ca\u5947\uff01\u8fd9\u91cc\u662f\u4e00\u4e2a\u5f02\u6837\u7684\u4e16\u754c\u3002 \u4e91\u5c42\u6e10\u6e10\u7a00\u8584\uff0c\u8fce\u9762\u800c\u6765\u7684\u662f\u5411\u5fc3\u7684\u6d77\u6c34\u3002\u8fd9\u592a\u5e73\u6d0b\u7684\u529b\u91cf\u771f\u662f\u96be\u4ee5\u4f30\u91cf\uff1b\u5f53\u4ed6\u76f4\u7acb\u5728\u6211\u7684\u9762\u524d\u65f6\uff0c\u7a92\u606f\u3001\u60ca\u614c\uff0c\u8fd9\u662f\u600e\u6837\u7684\u5947\u666f\uff0c\u94f6\u6cb3\u843d\u4e5d\u5929\u4ea6\u6709\u6240\u4e0d\u5982\u554a\uff01\u6089\u5c3c\u7684\u590f\u5929\u70ed\u70c8\u800c\u6f6e\u6e7f\uff0c\u6ca1\u6709\u4e45\u7559\uff0c\u4fbf\u5954\u53bb\u4e86\u582a\u57f9\u62c9\u3002\u5c0f\u61a9\u521d\u9192\uff0c\u73af\u987e\u5de6\u53f3\uff0c\u51fa\u4e86\u57ce\u8d70\u6811\u4e1b\u73af\u62b1\u7684\u516c\u8def\uff0c\u7adf\u8ddf\u5bb6\u4e61\u6ca1\u6709\u4ec0\u4e48\u5206\u522b\u3002\u4e0d\u8fc7\uff0c\u6e10\u6e10\u5730\uff0c\u4e5f\u6709\u4e9b\u4e50\u8da3\u3002 \u7b2c\u4e00\u4e2a\u4fbf\u662f\u770b\u8f66\u724c\u3002\u82f1\u6587\u5b57\u6bcd\u6709\u81ea\u5df1\u7684\u72ec\u7279\u7684\u6784\u56fe\u65b9\u6cd5\uff0c\u4f60\u51e0\u4e4e\u627e\u4e0d\u5230\u4ed6\u4eec\u5728\u7b14\u5212\u7c97\u7ec6\u3001\u7b14\u52bf\u67b6\u6784\u65b9\u9762\u7684\u8bbe\u8ba1\uff0c\u4f46\u5728\u8272\u5f69\u3001\u95f4\u8ddd\u3001\u5b57\u53f7\u3001\u5206\u5272\u7b49\u65b9\u9762\uff0c\u82f1\u6587\u5b57\u6bcd\u53ef\u4ee5\u7ed9\u4eba\u4e00\u79cd\u72ec\u7279\u7684\u7f8e\u611f\u2014\u2014\u6781\u5177\u5bf9\u6bd4\u5ea6\u7684\u3001\u6e05\u6670\u7684\u3001\u4eca\u4eba\u5fc3\u65f7\u795e\u6021\u7684\u2014\u2014\u73b0\u4ee3\u7684\u7f8e\u611f\u3002\u800c\u4e2d\u6587\u4e66\u6cd5\u591a\u4ee5\u9ed1\u767d\u4e3a\u4e3b\uff0c\u5c11\u6570\u5229\u7528\u8272\u5f69\u6765\u6807\u8bc6\u7c7b\u4f3c\u201d\u6731\u6279\u201c\u8fd9\u6837\u7684\u7279\u6b8a\u529f\u80fd\u3002\u540c\u65f6\uff0c\u5728\u7b14\u5212\u7684\u5934\u3001\u8eab\u3001\u5c3e\u8bbe\u8ba1\u4e0a\u53ca\u5176\u8bb2\u7a76\uff0c\u751a\u81f3\u58a8\u91cf\u3001\u8f7b\u91cd\u4e5f\u80fd\u8868\u73b0\u4e0d\u540c\u7684\u60c5\u7eea\uff0c\u5728\u7b14\u52bf\u67b6\u6784\u4e0a\u53c8\u4e30\u5bcc\u591a\u6837\u3002\u60f3\u5230\u8fd9\u513f\uff0c\u504f\u504f\u8bc4\u4e0d\u51fa\u4e00\u4e2a\u9ad8\u4e0b\u6765\uff0c\u5c31\u80fd\u7406\u89e3\uff0c\u4e3a\u4ec0\u4e48\u5dee\u5f02\u4f1a\u5e26\u6765\u75db\u82e6\u3002 \u8fd9\u91cc\u7684\u4e91\u5f69\u6781\u5177\u7ae5\u8bdd\u8272\u5f69\u3002\u6d77\u4e0a\u4e91\uff0c\u4eff\u4f5b\u8ba9\u4eba\u7f6e\u8eab\u4e8e\u8d3e\u4ead\u897f\uff0c\u201d\u6c34\u9762\u521d\u5e73\u4e91\u811a\u4f4e\u201c\u3002\u8349\u539f\u4e0a\u4e91\uff0c\u5c31\u662f\u90a3\u6574\u9f50\u6392\u5217\u7684\u7a3b\u8349\u4eba\uff0c\u662f\u519c\u4eba\u4eb2\u624b\u9020\u7684\u3001\u52e4\u52b3\u800c\u6e0a\u535a\u3002\u5c71\u4e0a\u4e91\uff0c\u662f\u86c7\u8eab\u96c0\u5c3e\uff0c\u90a3\u662f\u51e4\u51f0\uff0c\u6b63\u6b32\u8d77\u98de\u821e\u52a8\u4e8e\u4e5d\u5929\u4e4b\u4e0a\u3002\u5bc4\u751f\u4e8e\u94a2\u94c1\u73bb\u7483\u4e2d\u591a\u5e74\u540e\uff0c\u8fd9\u6837\u7684\u60ca\u5947\u96be\u514d\u53d1\u751f\u3002\u5bb6\u91cc\u7684\u5929\u7a7a\u4e5f\u662f\u5f88\u901a\u900f\u7684\uff0c\u4f46\u90a3\u4e9b\u90fd\u662f\u7ae5\u5e74\u7684\u8bb0\u5fc6\u4e86\u3002\u8fd9\u5757\u513f\u5927\u9646\u7684\u4e0a\u7a7a\uff0c\u751f\u5b58\u7740\u4e00\u4f4d\u8ba9\u4eba\u56de\u5f52\u4e50\u8da3\u7684\u795e\u79d8\u4e3b\u6559\uff0c\u5979\u4e0d\u65ad\u7684\u9020\u578b\uff0c\u4e0d\u65ad\u7684\u5b89\u7f6e\uff0c\u65e0\u8bba\u4f60\u7684\u5954\u884c\u7684\u901f\u5ea6\u6709\u591a\u5757\uff0c\u4e5f\u80fd\u8ba9\u4f60\u5e94\u63a5\u4e0d\u6687\uff0c\u4e91\u5f71\u5929\u5149\uff0c\u5176\u4e50\u65e0\u7a77\u3002 \u81ea\u7136\u6216\u8bb8\u662f\u8fd9\u6837\u7684\u4e00\u79cd\u5f62\u6001\uff1a\u6811\u8981\u4e48\u677e\u6563\u9ad8\u5927\uff0c\u8981\u4e48\u5bc6\u96c6\u4f4e\u77ee\uff1b\u679d\u8513\u4ece\u6839\u90e8\u6063\u610f\u6563\u53d1\uff0c\u6781\u5c3d\u8212\u5c55\u3002\u67af\u85e4\u8001\u6811\uff0c\u7edd\u65e0\u8427\u7d22\u4e4b\u610f\uff0c\u53cd\u800c\u866c\u52b2\u9b41\u68a7\uff0c\u4f3c\u6709\u5927\u53e3\u6c14\uff0c\u8981\u518d\u6d3b\u4e0a\u4e00\u5343\u5e74\uff1b\u4e5f\u6709\u7684\u8eab\u578b\u82d7\u6761\uff0c\u98ce\u59ff\u7ef0\u7ea6\uff0c\u6307\u5c16\u6258\u8d77\u7684\u662f\u7389\u76d8\u73cd\u7f9e\uff0c\u8981\u732e\u7ed9\u5929\u795e\u3002 \u5f02\u4e61\u5f02\u666f\uff0c\u53ef\u4ed4\u7ec6\u89c2\u5bdf\uff0c\u8fd9\u96be\u5230\u4e0d\u5c31\u662f\u5bb6\u4e61\u4e48\uff1f\u8fd9\u98ce\u666f\u96be\u5230\u4e0d\u5c31\u662f\u81ea\u7136\u4e48\uff1f","title":"ANU\u6691\u671f\u5b66\u6821-\u60ca\u5947"},{"location":"posts/2018-01-21-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E6%83%8A%E5%A5%87/#anu-","text":"","title":"ANU\u6691\u671f\u5b66\u6821-\u60ca\u5947"},{"location":"posts/2018-01-21-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E6%83%8A%E5%A5%87/#_1","text":"\u8fd9\u7bc7\u6587\u7ae0\u624d\u662f\u5728ANU\u6691\u671f\u5b66\u6821\u5199\u4e0b\u7684\u7b2c\u4e00\u7bc7\u6587\u7ae0\uff0c\u7f16\u8f91\u7684\u65f6\u5019\u628a\u5b83\u5fd8\u6389\u4e86\u3002\u7b2c\u4e00\u8ba9\u4eba\u5360\u4e86\u53bb\uff0c\u59d1\u4e14\u843d\u4e2a\u7b2c\u4e94\u540d\u7f62\uff01","title":"\u5e8f"},{"location":"posts/2018-01-21-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E6%83%8A%E5%A5%87/#_2","text":"\u4e2d\u56fd\u4eba\u5f88\u65e9\u5c31\u63cf\u8ff0\u8fc7\u4fef\u77b0\u4e4b\u666f\u8272\uff0c\u6bd4\u5982\u201c\u6797\u6d77\u96ea\u539f\u201d\u3001\u201c\u677e\u6d9b\u9635\u9635\u201d\u4e4b\u7c7b\u7684\u3002\u4e2d\u56fd\u4eba\u4e5f\u5411\u5f80\u98de\u884c\uff0c\u5f53\u6211\u4e58\u5750\u7740\u6ce2\u97f3787\u7ff1\u7fd4\u572812500\u516c\u5c3a\u7684\u9ad8\u7a7a\u4e2d\uff0c\u900f\u7740\u5c0f\u7a97\u5ba1\u89c6\u56db\u5468\u65f6\uff0c\u65f6\u95f4\u548c\u7a7a\u95f4\u90fd\u51dd\u56fa\u4e86\uff0c\u4e0d\u6d41\u52a8\u4ea6\u65e0\u6240\u5c3d\uff1b\u8fd9\u4e91\u6d77\u662f\u9759\u7684\uff0c\u662f\u6ce2\u6d9b\u6c79\u6d8c\u65f6\u5019\u7684\u5b9a\u683c\uff1b\u8fd9\u4e91\u6d77\u662f\u74f7\u76d8\uff0c\u9752\u82b1\u7f8e\u5999\u3001\u5929\u7a79\u8986\u76d6\u3002\u5fc3\u91cc\u662f\u60ca\u53f9\uff0c\u8111\u4e2d\u662f\u7ffb\u6d8c\u3002\u4e2d\u56fd\u53e4\u4ee3\u6587\u4eba\uff0c\u8981\u662f\u6709\u4e00\u4e2a\u80fd\u629f\u6276\u6447\u76f4\u4e0a\u4e5d\u4e07\u91cc\uff0c\u4ed6\u5c06\u5199\u4e0b\u600e\u6837\u7684\u5343\u53e4\u540d\u7bc7\uff1f\u60ca\u5947\uff01\u8fd9\u91cc\u662f\u4e00\u4e2a\u5f02\u6837\u7684\u4e16\u754c\u3002 \u4e91\u5c42\u6e10\u6e10\u7a00\u8584\uff0c\u8fce\u9762\u800c\u6765\u7684\u662f\u5411\u5fc3\u7684\u6d77\u6c34\u3002\u8fd9\u592a\u5e73\u6d0b\u7684\u529b\u91cf\u771f\u662f\u96be\u4ee5\u4f30\u91cf\uff1b\u5f53\u4ed6\u76f4\u7acb\u5728\u6211\u7684\u9762\u524d\u65f6\uff0c\u7a92\u606f\u3001\u60ca\u614c\uff0c\u8fd9\u662f\u600e\u6837\u7684\u5947\u666f\uff0c\u94f6\u6cb3\u843d\u4e5d\u5929\u4ea6\u6709\u6240\u4e0d\u5982\u554a\uff01\u6089\u5c3c\u7684\u590f\u5929\u70ed\u70c8\u800c\u6f6e\u6e7f\uff0c\u6ca1\u6709\u4e45\u7559\uff0c\u4fbf\u5954\u53bb\u4e86\u582a\u57f9\u62c9\u3002\u5c0f\u61a9\u521d\u9192\uff0c\u73af\u987e\u5de6\u53f3\uff0c\u51fa\u4e86\u57ce\u8d70\u6811\u4e1b\u73af\u62b1\u7684\u516c\u8def\uff0c\u7adf\u8ddf\u5bb6\u4e61\u6ca1\u6709\u4ec0\u4e48\u5206\u522b\u3002\u4e0d\u8fc7\uff0c\u6e10\u6e10\u5730\uff0c\u4e5f\u6709\u4e9b\u4e50\u8da3\u3002 \u7b2c\u4e00\u4e2a\u4fbf\u662f\u770b\u8f66\u724c\u3002\u82f1\u6587\u5b57\u6bcd\u6709\u81ea\u5df1\u7684\u72ec\u7279\u7684\u6784\u56fe\u65b9\u6cd5\uff0c\u4f60\u51e0\u4e4e\u627e\u4e0d\u5230\u4ed6\u4eec\u5728\u7b14\u5212\u7c97\u7ec6\u3001\u7b14\u52bf\u67b6\u6784\u65b9\u9762\u7684\u8bbe\u8ba1\uff0c\u4f46\u5728\u8272\u5f69\u3001\u95f4\u8ddd\u3001\u5b57\u53f7\u3001\u5206\u5272\u7b49\u65b9\u9762\uff0c\u82f1\u6587\u5b57\u6bcd\u53ef\u4ee5\u7ed9\u4eba\u4e00\u79cd\u72ec\u7279\u7684\u7f8e\u611f\u2014\u2014\u6781\u5177\u5bf9\u6bd4\u5ea6\u7684\u3001\u6e05\u6670\u7684\u3001\u4eca\u4eba\u5fc3\u65f7\u795e\u6021\u7684\u2014\u2014\u73b0\u4ee3\u7684\u7f8e\u611f\u3002\u800c\u4e2d\u6587\u4e66\u6cd5\u591a\u4ee5\u9ed1\u767d\u4e3a\u4e3b\uff0c\u5c11\u6570\u5229\u7528\u8272\u5f69\u6765\u6807\u8bc6\u7c7b\u4f3c\u201d\u6731\u6279\u201c\u8fd9\u6837\u7684\u7279\u6b8a\u529f\u80fd\u3002\u540c\u65f6\uff0c\u5728\u7b14\u5212\u7684\u5934\u3001\u8eab\u3001\u5c3e\u8bbe\u8ba1\u4e0a\u53ca\u5176\u8bb2\u7a76\uff0c\u751a\u81f3\u58a8\u91cf\u3001\u8f7b\u91cd\u4e5f\u80fd\u8868\u73b0\u4e0d\u540c\u7684\u60c5\u7eea\uff0c\u5728\u7b14\u52bf\u67b6\u6784\u4e0a\u53c8\u4e30\u5bcc\u591a\u6837\u3002\u60f3\u5230\u8fd9\u513f\uff0c\u504f\u504f\u8bc4\u4e0d\u51fa\u4e00\u4e2a\u9ad8\u4e0b\u6765\uff0c\u5c31\u80fd\u7406\u89e3\uff0c\u4e3a\u4ec0\u4e48\u5dee\u5f02\u4f1a\u5e26\u6765\u75db\u82e6\u3002 \u8fd9\u91cc\u7684\u4e91\u5f69\u6781\u5177\u7ae5\u8bdd\u8272\u5f69\u3002\u6d77\u4e0a\u4e91\uff0c\u4eff\u4f5b\u8ba9\u4eba\u7f6e\u8eab\u4e8e\u8d3e\u4ead\u897f\uff0c\u201d\u6c34\u9762\u521d\u5e73\u4e91\u811a\u4f4e\u201c\u3002\u8349\u539f\u4e0a\u4e91\uff0c\u5c31\u662f\u90a3\u6574\u9f50\u6392\u5217\u7684\u7a3b\u8349\u4eba\uff0c\u662f\u519c\u4eba\u4eb2\u624b\u9020\u7684\u3001\u52e4\u52b3\u800c\u6e0a\u535a\u3002\u5c71\u4e0a\u4e91\uff0c\u662f\u86c7\u8eab\u96c0\u5c3e\uff0c\u90a3\u662f\u51e4\u51f0\uff0c\u6b63\u6b32\u8d77\u98de\u821e\u52a8\u4e8e\u4e5d\u5929\u4e4b\u4e0a\u3002\u5bc4\u751f\u4e8e\u94a2\u94c1\u73bb\u7483\u4e2d\u591a\u5e74\u540e\uff0c\u8fd9\u6837\u7684\u60ca\u5947\u96be\u514d\u53d1\u751f\u3002\u5bb6\u91cc\u7684\u5929\u7a7a\u4e5f\u662f\u5f88\u901a\u900f\u7684\uff0c\u4f46\u90a3\u4e9b\u90fd\u662f\u7ae5\u5e74\u7684\u8bb0\u5fc6\u4e86\u3002\u8fd9\u5757\u513f\u5927\u9646\u7684\u4e0a\u7a7a\uff0c\u751f\u5b58\u7740\u4e00\u4f4d\u8ba9\u4eba\u56de\u5f52\u4e50\u8da3\u7684\u795e\u79d8\u4e3b\u6559\uff0c\u5979\u4e0d\u65ad\u7684\u9020\u578b\uff0c\u4e0d\u65ad\u7684\u5b89\u7f6e\uff0c\u65e0\u8bba\u4f60\u7684\u5954\u884c\u7684\u901f\u5ea6\u6709\u591a\u5757\uff0c\u4e5f\u80fd\u8ba9\u4f60\u5e94\u63a5\u4e0d\u6687\uff0c\u4e91\u5f71\u5929\u5149\uff0c\u5176\u4e50\u65e0\u7a77\u3002 \u81ea\u7136\u6216\u8bb8\u662f\u8fd9\u6837\u7684\u4e00\u79cd\u5f62\u6001\uff1a\u6811\u8981\u4e48\u677e\u6563\u9ad8\u5927\uff0c\u8981\u4e48\u5bc6\u96c6\u4f4e\u77ee\uff1b\u679d\u8513\u4ece\u6839\u90e8\u6063\u610f\u6563\u53d1\uff0c\u6781\u5c3d\u8212\u5c55\u3002\u67af\u85e4\u8001\u6811\uff0c\u7edd\u65e0\u8427\u7d22\u4e4b\u610f\uff0c\u53cd\u800c\u866c\u52b2\u9b41\u68a7\uff0c\u4f3c\u6709\u5927\u53e3\u6c14\uff0c\u8981\u518d\u6d3b\u4e0a\u4e00\u5343\u5e74\uff1b\u4e5f\u6709\u7684\u8eab\u578b\u82d7\u6761\uff0c\u98ce\u59ff\u7ef0\u7ea6\uff0c\u6307\u5c16\u6258\u8d77\u7684\u662f\u7389\u76d8\u73cd\u7f9e\uff0c\u8981\u732e\u7ed9\u5929\u795e\u3002 \u5f02\u4e61\u5f02\u666f\uff0c\u53ef\u4ed4\u7ec6\u89c2\u5bdf\uff0c\u8fd9\u96be\u5230\u4e0d\u5c31\u662f\u5bb6\u4e61\u4e48\uff1f\u8fd9\u98ce\u666f\u96be\u5230\u4e0d\u5c31\u662f\u81ea\u7136\u4e48\uff1f","title":"\u6b63\u6587"},{"location":"posts/2018-01-23-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E6%97%A0%E9%A2%98/","text":"ANU\u6691\u671f\u5b66\u6821-\u65e0\u9898 \u4e00 \u73b0\u4ee3\u5316\u7684\u57ce\u5e02\u3001\u5bf9\u81ea\u7136\u7684\u8fc7\u5ea6\u7834\u574f\uff0c\u8ba9\u4e2d\u56fd\u7684\u5e74\u8f7b\u4e00\u4ee3\u96be\u4ee5\u4f53\u4f1a\u5230\u4e00\u4e9b\u7c7b\u4f3c\u4e8e\u201c\u8349\u957f\u83ba\u98de\u201d\u3001\u201c\u843d\u971e\u5b64\u9e6d\u201d\u7684\u666f\u81f4\u4e86\u3002\u5982\u679c\u8fd9\u4e2a\u7ed3\u8bba\u4e0d\u80fd\u666e\u904d\u6210\u7acb\uff0c\u5bf9\u6211\u81ea\u5df1\u603b\u662f\u6210\u7acb\u7684\u3002 \u9ed1\u571f\u5730\u4e0a\u7565\u6709\u4e9b\u5355\u8c03\u4e86\uff0c\u4e0d\u8fc7\u5bb6\u4e61\u4ea6\u6709\u4e9b\u666f\u81f4\uff0c\u5c31\u6bd4\u5982\u7ed3\u70c8\u6cb3\u6cbf\u5cb8\u7684\u6e7f\u5730\uff0c\u5916\u52a0\u4f4e\u77ee\u7684\u704c\u6728\uff0c\u5c42\u6b21\u9519\u843d\u7684\uff0c\u4e5f\u6709\u4e9b\u5982\u753b\u4e4b\u666f\u3002\u6211\u662f\u89c1\u8fc7\u9e70\u7684\uff1b\u8fd8\u6709\u4e9b\u8da3\u5473\u5341\u8db3\u7684\u67ab\u53f6\uff0c\u6211\u603b\u6311\u4e86\u4e9b\u9001\u7ed9\u559c\u6b22\u7684\u4eba\u3002 \u4ece\u5bb6\u51fa\u6765\u4e0a\u5b66\u4e4b\u540e\uff0c\u5c31\u53d8\u5f97\u66f4\u52a0\u5355\u8c03\u3002\u4e1c\u5317\u7684\u5c71\u3001\u516c\u56ed\u5927\u540c\u5c0f\u5f02\uff0c\u6587\u5316\u7684\u79ef\u6dc0\u751a\u5c11\u3002\u6765\u5230\u5317\u4eac\uff0c\u4e5f\u6ca1\u591a\u4f53\u4f1a\u5230\u6587\u5316\u53e4\u90fd\u3001\u540d\u57ce\u7684\u8ff7\u9189\u4e4b\u610f\u3002\u5f53\u7136\u8fd9\u4e9b\u5931\u610f\u591a\u534a\u662f\u81ea\u5df1\u9020\u6210\u7684\uff0c\u73b0\u5728\u89c9\u609f\uff0c\u9ad8\u4e2d\u3001\u5927\u5b66\u6ca1\u6709\u610f\u8bc6\u53bb\u611f\u53d7\uff0c\u624d\u9020\u6210\u4e86\u5bf9\u98ce\u5149\u548c\u53e4\u57ce\u7684\u5931\u671b\u3002 \u4e2d\u56fd\u4eba\u4e00\u76f4\uff0c\u5728\u8fc7\u53bb\u7684\u51e0\u5343\u5e74\u4e2d\uff0c\u90fd\u662f\u8ddf\u81ea\u7136\u751f\u6d3b\u5728\u4e00\u8d77\u7684\u3002\u6210\u201c\u548c\u5408\u201d\u4e4b\u5883\uff0c\u662f\u6211\u4eec\u4e00\u8d2f\u7684\u3001\u6700\u9ad8\u7684\u8ffd\u6c42\u3002\u73b0\u4ee3\u5de5\u5177\u8bbe\u65bd\u5bf9\u81ea\u7136\u7684\u5165\u4fb5\u4e0e\u7834\u574f\u5df2\u7ecf\u9020\u6210\u4e86\u4e00\u79cd\u4eba\u4e0e\u81ea\u7136\u7684\u9694\u79bb\uff1b\u5728\u6063\u610f\u82b3\u534e\u7684\u5e74\u9f84\uff0c\u53bb\u65e0\u5fc3\u611f\u53d7\u8fd9\u5468\u906d\u82b1\u8349\u866b\u9c7c\uff0c\u5b9e\u5728\u662f\u6709\u4e9b\u53ef\u7b11\u3002\u4f46\u8fd9\u4f3c\u4e4e\u662f\u5fc5\u7136\u7684\uff0c\u91ce\u86ee\u7684\u53d1\u5c55\u3001\u7e41\u91cd\u7684\u5b66\u4e1a\u548c\u7ecf\u6d4e\u538b\u529b\u2026\u2026\u4eba\u4e0e\u81ea\u7136\u7684\u548c\u5408\u6015\u53ea\u80fd\u51fa\u73b0\u5728\u201c\u4eba\u95f2\u6842\u82b1\u843d\uff0c\u591c\u9759\u6625\u5c71\u7a7a\u201d\u7684\u8bd7\u53e5\u4e2d\u4e86\u3002 \u4e8c \u582a\u57f9\u62c9\u5374\u662f\u4e0d\u540c\u7684\u3002 \u6211\u5728\u60f3\uff0c\u6b27\u7f8e\u7684\u4e00\u4e9b\u5730\u65b9\u662f\u4e0d\u662f\u4e0e\u582a\u57f9\u62c9\u7c7b\u4f3c\uff0c\u5bf9\u81ea\u7136\u7684\u5e72\u6270\u51e0\u8fd1\u4e3a\u96f6\uff0c\u751a\u81f3\u6709\u4e9b\u201c\u539f\u59cb\u201d\u3002\u8fd9\u79cd\u201c\u539f\u59cb\u201d\u4e0e\u9ad8\u5ea6\u53d1\u8fbe\u7684\u73b0\u4ee3\u6587\u660e\u7684\u9c9c\u660e\u5bf9\u6bd4\u662f\u6700\u6709\u8da3\u7684\u90e8\u5206\u3002\u5728ANU\u7684\u6821\u56ed\u91cc\uff0c\u4f60\u53ef\u4ee5\u95fb\u5230\u82b1\u9999\uff0c\u6b23\u8d4f\u4ece\u6839\u90e8\u5c31\u6563\u53d1\u679d\u8513\u7684\u9020\u578b\uff0c\u770b\u5230\u6ee1\u5929\u7e41\u661f\uff0c\u542c\u5154\u5988\u5988\u8bb2\u6545\u4e8b\uff08\u5927\u591a\u6570\u65f6\u95f4\u5728\u5403\u4e1c\u897f\uff09\uff0c\u60f3\u8c61\u7740\u7fa4\u9e1f\u4e89\u9e23\u5e26\u6765\u7684\u5bf9\u672a\u77e5\u7684\u65e0\u9650\u7684\u597d\u5947\u4e0e\u5fe7\u60e7\u3002 \u6682\u65f6\u63d2\u5165\u4e00\u6bb5\u5bf9\u5efa\u7b51\u7684\u63cf\u8ff0\u3002\u542c\u859b\u534e\u514b\u8001\u5e08\u8bb2\uff08\u6b64\u5904\u4e3a\u610f\u4f1a\uff09\uff0c\u4e2d\u56fd\u7684\u57ce\u5e02\u662f\u6781\u5ea6\u7f3a\u4e4f\u7f8e\u611f\u7684\uff0c\u697c\u623f\u7684\u5ba1\u7f8e\u4ef7\u503c\u5df2\u88ab\u964d\u5230\u6700\u4f4e\uff0c\u7b80\u5355\u6765\u8bf4\u5c31\u662f\u201c\u5343\u57ce\u4e00\u9762\u201d\u3002\u540e\u6765\u6211\u81ea\u5df1\u5728\u540e\u6d77\u6e38\u73a9\u65f6\uff0c\u77ac\u95f4\u5bf9\u4ed6\u7684\u89c2\u70b9\u6709\u4e9b\u66f4\u6df1\u5165\u7684\u8ba4\u8bc6\u4e86\u3002\u4e00\u4e2a\u57ce\u5e02\u662f\u4ec0\u4e48\u6837\u7684\uff0c\u770b\u6765\u8981\u5148\u628a\u4e00\u4e9b\u4e11\u964b\u7684\u3001\u65e0\u804a\u7684\u3001\u76f8\u540c\u7684\u697c\u5b87\u62c6\u6389\uff0c\u770b\u770b\u8fd8\u5269\u4e0b\u4ec0\u4e48\uff0c\u90a3\u4fbf\u662f\u8fd9\u4e2a\u57ce\u5e02\u4e86\u3002\u8981\u62c6\u5317\u7406\u5de5\uff0c\u90a3\u5317\u7406\u5de5\u4fbf\u4ec0\u4e48\u4e5f\u4e0d\u5269\u4e86\uff0c\u5317\u5916\u7684\u56fe\u4e66\u9986\u662f\u4e0d\u820d\u5f97\u62c6\u6389\u7684\uff0c\u5b83\u7684\u5916\u5899\u5145\u5206\u4f53\u73b0\u4e86\u5b83\u7684\u7f8e\u611f\uff1b\u5317\u4eac\u4e94\u73af\u516d\u73af\uff0c\u5927\u90e8\u5206\u4e5f\u53ef\u62c6\u6389\uff0c\u4e09\u56db\u73af\u53ef\u5269\u4e0b\u4e00\u4e9b\u73b0\u4ee3\u5efa\u7b51\uff0c\u5185\u57ce\u91cc\u9762\uff0c\u5927\u90e8\u5206\u7684\u6c11\u5c45\u3001\u5bab\u6bbf\u90fd\u53ef\u4ee5\u4fdd\u7559\u3002\u6211\u773c\u4e2d\u7684\u5317\u4eac\u4fbf\u662f\u8fd9\u6837\u7684\u6e05\u6670\u4e86\uff0c\u524d\u95e8\u81f3\u5929\u5b89\u95e8\uff0c\u7e41\u534e\u4e8e\u4e16\uff0c\u5a01\u4e25\u5373\u81f3\uff0c\u6545\u5bab\u4e0e\u666f\u5c71\u3001\u4ec0\u5239\u6d77\u3001\u540e\u6d77\u4fbf\u662f\u5b98\u4e0e\u6c11\u7684\u3001\u6b63\u895f\u5371\u5750\u4e0e\u60ec\u610f\u7684\u5bf9\u6bd4\u3002\u5317\u4eac\u5c31\u662f\u4e00\u4e2a\uff1a\u5a01\u800c\u6709\u95f2\uff0c\u73e0\u5149\u5b9d\u6c14\u53c8\u60a0\u5f97\u81ea\u7136\u7684\u5730\u65b9\u3002 \u56de\u5230\u582a\u57f9\u62c9\uff0c\u6211\u4eec\u6cbf\u7740\u4e61\u6751\u5c0f\u8def\u6765\u4f53\u4f1a\u4e00\u4e0b\u5979\u7684\u201c\u539f\u59cb\u201d\u3002\u79bb\u5f00\u5bb6\u4e61\u591a\u5e74\uff0c\u6211\u5df2\u7ecf\u592a\u4e45\u672a\u89c1\u5230\u6beb\u65e0\u4fee\u847a\u7684\u201c\u4e61\u95f4\u5c0f\u8def\u201d\u4e86\uff0c\u8fd9\u79cd\u201c\u5e7d\u5f84\u201d\u5728\u6211\u5bb6\u662f\u6709\u7684\u3002\u8fd9\u91cc\u7684\u5c0f\u8def\u4e00\u822c\u6cbf\u6cb3\u624d\u6709\u3002\u662f\u201c\u8d70\u7684\u4eba\u591a\u4e86\u201d\u8e29\u51fa\u7684\u5c0f\u8def\uff0c\u662f\u4e0d\u5e73\u6574\u7684\u3001\u8513\u8349\u4e1b\u751f\u7684\u5c0f\u8def\u3002\u201c\u4e94\u4e5d\u516d\u4e5d\uff0c\u6cbf\u6cb3\u770b\u67f3\u201d\u867d\u5199\u521d\u6625\uff0c\u7528\u5230\u8fd9\u91cc\u4ea6\u6070\u5982\u5176\u5206\u3002\u53ea\u6709\u5728\u6cb3\u8fb9\uff08\u83ab\u6717\u683c\u6d1b\u6cb3\uff09\u624d\u6709\u67f3\u6811\u3002\u8fdc\u671b\u5782\u67f3\uff0c\u679c\u5982\u65b0\u5a18\u3002\u8d70\u5230\u4e00\u5904\uff0c\u873f\u8712\u6d41\u8f6c\uff0c\u5f69\u9547\u7ae5\u8bdd\uff0c\u6eaa\u6d41\u3001\u7eff\u6811\u3001\u884c\u4eba\u5728\u4e00\u77ac\u95f4\u8fbe\u5230\u548c\u8c10\uff0c\u6b63\u662f\u201c\u5f2f\u5f2f\u7684\u6d41\u6c34\u554a\uff0c\u84dd\u84dd\u7684\u5929\uff1b\u7eff\u6cb9\u6cb9\u7684\u8349\u5730\u554a\uff0c\u9752\u9752\u7684\u5c71\u201d\u3002\u6cb3\u6d41\u873f\u8712\uff0c\u5c31\u8981\u8fc7\u6865\u3002\u6865\u4ea6\u662f\u4e0d\u53ef\u7f3a\u5c11\u7684\u5143\u7d20\uff0c\u201c\u5c0f\u6865\u6d41\u6c34\u4eba\u5bb6\u201d\uff0c\u8fd9\u4e9b\u603b\u662f\u5728\u4e00\u8d77\u7684\uff0c\u8fd9\u6fb3\u6d32\u4eba\u7684\u5ba1\u7f8e\u4e0e\u4e2d\u56fd\u4eba\u4e5f\u6ca1\u6709\u4ec0\u4e48\u4e0d\u540c\u554a\u3002\u6cbf\u6cb3\u53f3\u5cb8\u5411\u5357\u8d70\uff0c\u8fc7\u4e00\u7247\u6797\u5730\u4fbf\u4f3c\u6ca1\u6709\u8def\u4e86\u3002\u6211\u5728\u6797\u4e2d\uff0c\u7b2c\u4e00\u6b21\u770b\u89c1\u4e86\u58c1\u864e\uff1b\u6211\u5728\u8fd9\u6797\u4e2d\uff0c\u4e5f\u770b\u5230\u4e86\u201c\u6e14\u6a35\u201d\u4e4b\u4e8b\u3002\u6709\u4e9b\u7f81\u7eca\u7684\u5c0f\u8def\uff0c\u5145\u6ee1\u4e86\u9677\u9631\u4e0e\u60ca\u5947\uff08\u6b8b\u679d\u4e4b\u4e0b\uff0c\u4e2d\u7a7a\u4e5f\uff0c\u730e\u4eba\u6280\uff09\u3002\u7ee7\u7eed\u5411\u5357\u63a2\u53bb\uff08\u56e0\u6211\u4eec\u770b\u5230\u8fdc\u5904\u7684\u9ad8\u67b6\uff09\uff0c\u679c\u7136\u662f\u201c\u5c71\u91cd\u6c34\u590d\u7591\u65e0\u8def\uff0c\u67f3\u6697\u82b1\u660e\u53c8\u4e00\u6751\u201d\u3002\u6211\u4eec\u53d1\u73b0\u4e86\u8d70\u51fa\u6797\u5730\u524d\u5f80\u516c\u8def\u7684\u6377\u5f84\uff0c\u4fbf\u8e0f\u4e86\u4e0a\u53bb\u3002\u8fc7\u4e86\u9a6c\u8def\uff0c\u6765\u5230\u9ad8\u67b6\u6865\u4e0b\u3002\u6709\u4eba\u51b2\u4e0a\u9ad8\u67b6\u6865\u7684\u9661\u5761\uff0c\u60f3\u4e00\u7779\u683c\u91cc\u82ac\u6e56\u7684\u9762\u5bb9\uff0c\u5c31\u50cf\u662f\u770b\u5362\u820d\u90a3\u5927\u4f5b\u65f6\u5019\u7684\u90a3\u79cd\u610f\u5883\uff0c\u6cbf\u9636\u800c\u4e0a\uff0c\u5362\u820d\u90a3\u4e00\u70b9\u4e00\u70b9\u5730\u51fa\u73b0\uff0c\u90a3\u89c6\u89c9\u7684\u51b2\u51fb\u548c\u5fc3\u7406\u7684\u51b2\u51fb\u662f\u6781\u5176\u5f3a\u70c8\u7684\u3002\u662f\u201c\u795e\u5723\u201d\u4e0e\u201c\u60ca\u559c\u7684\u7ed3\u5408\u201d\uff0c\u662f\u201c\u6cbf\u9636\u800c\u4e0a\u201d\u548c\u201c\u4ece\u4e0a\u81f3\u4e0b\u6d6e\u73b0\u201d\u7684\u76f8\u6620\u6210\u8da3\u3002\u672c\u60f3\uff0c\u683c\u91cc\u82ac\u6e56\u7684\u8fdc\u895f\u8981\u65e9\u51fa\u73b0\uff0c\u7d27\u63a5\u7740\u662f\u5982\u5c71\u7684\u9f3b\u5b50\uff0c\u518d\u5c31\u662f\u660e\u955c\u822c\u7684\u773c\u7738\u2026\u2026\u5b81\u9759\u81f4\u8fdc\uff0c\u5fc3\u65f7\u795e\u6021\u3002\u54ce\u54ce\u54ce\uff0c\u53f9\u53f9\u53f9\uff01\u8fd9\u683c\u91cc\u82ac\u6e56\u662f\u4e2a\u6781\u5bb3\u7f9e\u7684\u7f8e\u4eba\uff0c\u8ba9\u4e00\u6392\u6392\u7684\u201c\u68a7\u6850\u201d\uff08\u6216\u8bb8\u662f\u68a7\u6850\uff09\u548c\u5782\u67f3\u505a\u4e86\u73e0\u5e18\uff0c\u786c\u8981\u60f9\u4f60\u63a5\u8fd1\uff0c\u4eb2\u81ea\u5377\u5e18\u624d\u6ee1\u8db3\u5462\uff01 \u4e09 \u6cbf\u7740\u6cb3\u8fb9\u5c0f\u8def\u5411\u4e1c\u884c\uff0c\u8fd9\u662f\u4e2a10\u516c\u91cc\u7684\u81ea\u884c\u8f66\u8d5b\u9053\uff0c\u4e5f\u6709\u4eba\u5728\u8dd1\u6b65\uff0c\u4ea6\u6709\u4e9b\u7f8e\u4e3d\u7684\u8bf4\u4e0d\u51fa\u540d\u5b57\u7684\u9e1f\u548c\u6210\u7a9d\u7684\u5154\u5b50\u3002\u8fd9\u91cc\u53ef\u4ee5\u7ed9\u4e88\u4e00\u5207\u5bf9\u6e56\u5149\u5c71\u8272\u7684\u524d\u666f\u7684\u60f3\u8c61\uff0c\u6811\u6797\u9634\u7ff3\uff0c\u660e\u6697\u76f8\u95f4\uff0c\u6e56\u98ce\u5148\u81f3\uff0c\u7fe0\u9e1f\u683e\u9e23\u2026\u2026\u771f\u613f\u8eba\u4e0b\uff0c\u7528\u808c\u80a4\u53bb\u542c\uff0c\u7528\u773c\u775b\u53bb\u95fb\uff0c\u7528\u9f3b\u5b50\u53bb\u770b\uff0c\u7528\u5fc3\u53bb\u7545\u60f3\uff0c\u7528\u8111\u53bb\u4f53\u4f1a\u751f\u547d\u7684\u5f8b\u52a8\u3002 \u6765\u5230\u4e00\u7247\u5c0f\u9614\u5730\uff0c\u987a\u7740\u655e\u53e3\u8fdc\u773a\uff0c\u5fc3\u662f\u6026\u6026\u76f4\u8df3\uff0c\u811a\u662f\u4e0d\u7531\u81ea\u4e3b\uff0c\u8fd9\u662f\u4ec0\u4e48\u611f\u89c9\u554a\uff01\u8fd9\u662f\u4e00\u89c1\u949f\u60c5\u554a\uff01\u8fd9\u6e56\u5149\u5c71\u8272\uff0c\u8be5\u600e\u4e48\u5f62\u5bb9\uff1f\u662f\u201c\u843d\u971e\u4e0e\u5b64\u9e5c\u9f50\u98de\uff0c\u79cb\u6c34\u5171\u957f\u5929\u4e00\u8272\u201d\u4e48\uff1f\u843d\u971e\u4ea6\u5982\u683c\u91cc\u82ac\u6e56\u4e00\u822c\u7f9e\u6da9\uff0c\u8499\u4e86\u7eb1\uff0c\u8fdc\u8fdc\u5f97\u8eb2\u5728\u5c71\u540e\u9762\uff0c\u9732\u51fa\u4e00\u70b9\u7aef\u502a\uff0c\u98de\u9e1f\u7fe9\u7fe9\uff0c\u8f7b\u76c8\u52a8\u4eba\uff1b\u786e\u662f\u201c\u6c34\u5171\u957f\u5929\u4e00\u8272\u201d\u7684\uff0c\u53ea\u4e0d\u8fc7\uff0c\u73b0\u5728\u662f\u6fb3\u6d32\u76848\u6708\uff0c\u8bf4\u79cb\u6709\u4e9b\u65e9\u4e86\u3002\u662f\u201c\u534a\u4ea9\u65b9\u5858\u4e00\u9274\u5f00\uff0c\u5929\u5149\u4e91\u5f71\u5171\u5f98\u5f8a\u201d\u4e48\uff1f\u8fd9\u6e56\u7684\u5927\u5c0f\u771f\u662f\u6070\u5230\u597d\u5904\uff0c\u6211\u4eec\u5927\u6982\u5728\u6e56\u5317\u4e2d\u90e8\u504f\u897f\uff0c\u6e56\u6c34\u4e00\u6620\u773c\u5e95\u4e14\u9752\u5c71\u7686\u5982\u542b\u82de\u70b9\u7f00\u6216\u8fde\u7f00\u5728\u6e56\u7684\u4e09\u9762\uff0c\u5c31\u50cf\u662f\u660e\u955c\u7684\u82b1\u8fb9\uff0c\u4f46\u5374\u6709\u65e0\u9650\u7684\u751f\u673a\uff1b\u6070\u5f53\u7684\u5e03\u5c40\u8ba9\u4f60\u60c5\u4e0d\u81ea\u7981\u5730\u60f3\u62e5\u62b1\u5979\uff0c\u56e0\u4e3a\u5728\u5979\u9762\u524d\uff0c\u4eba\u4f3c\u4e4e\u6709\u8db3\u591f\u7684\u4f38\u5c55\u529b\u4e86\uff1b\u201c\u5929\u5149\u4e91\u5f71\u201d\u53ea\u5360\u4e91\u5f71\uff0c\u201c\u5929\u5149\u4e91\u5f71\u201d\u5199\u7684\u662f\u84dd\u5929\u767d\u4e91\uff0c\u800c\u4e14\u662f\u6210\u6735\u7684\u7a00\u758f\u7684\u767d\u4e91\uff0c\u5012\u6620\u6c34\u4e2d\uff0c\u4efb\u7531\u7fa4\u9e2d\u63a8\u5f00\u6e56\u9762\u3002\u508d\u665a\u4ee5\u81f4\uff0c\u4e91\u6709\u4e9b\u9634\uff0c\u6574\u4f53\u8272\u8c03\u504f\u6697\uff0c\u4e91\u5f71\u5145\u6ee1\u6c34\u9762\uff0c\u4ece\u4e2d\u53ef\u4ee5\u770b\u5230\u6c34\u58a8\u753b\uff0c\u662f\u6d53\u6de1\u3001\u6392\u5e03\u7684\u827a\u672f\u3002\u6e56\u98ce\u6251\u9762\uff0c\u7a7a\u6c14\u6e7f\u6da6\uff0c\u8fd9\u9634\u4e91\u5e26\u6765\u7684\u4e00\u70b9\u513f\u4e5f\u4e0d\u662f\u538b\u6291\uff0c\u800c\u662f\u8ba9\u4f60\u6781\u5c3d\u5730\u8212\u5c55\uff0c\u8ba9\u4f60\u5fc3\u8fdc\u610f\u8fc1\uff0c\u7ed9\u4f60\u65e0\u9650\u7684\u60ec\u610f\u4e0e\u4eab\u53d7\u3002\u843d\u65e5\u5c3d\u4e8e\u5c71\u524d\uff0c\u4fbf\u662f\u201c\u534a\u6c5f\u745f\u745f\u534a\u6c5f\u7ea2\u201d\uff0c\u56e0\u6765\u7684\u7a0d\u665a\uff0c\u201c\u4e00\u9053\u6b8b\u9633\u201d\u4e0d\u590d\u518d\u73b0\u4e86\u3002\u6ca1\u6709\u9057\u61be\uff0c\u51ed\u4ec0\u4e48\u6000\u5ff5\uff1f\u6211\u51b3\u5b9a\u8981\u8d70\uff0c\u8ba9\u5979\u6210\u4e3a\u8bb0\u5fc6\uff0c\u8ba9\u6211\u6c38\u4e45\u7684\u56de\u5473\u5427\u3002 \u56db \u7ee7\u5411\u4e1c\u884c\uff0c\u6298\u5de6\u5411\u5317\u7531\u8fdb\u5165\u4e86ANU\u7684\u6821\u56ed\uff0c\u73b0\u5728\u6211\u4eec\u5728\u6cb3\u7684\u53e6\u4e00\u5cb8\u3002\u6821\u56ed\u5bc2\u9759\uff0c\u8def\u9762\u8d77\u4f0f\uff0c\u6211\u4eec\u8d39\u4e86\u4e9b\u529f\u592b\u624d\u56de\u5230\u4f4f\u5904\uff08Bruce Hall\uff09\u3002 \u51e0\u65e5\u4e4b\u884c\uff0c\u9971\u7779\u98ce\u5149\uff0c\u5fc3\u7eea\u4e07\u5343\uff0c\u4f5c\u6587\u7559\u5ff5\u3002","title":"ANU\u6691\u671f\u5b66\u6821-\u65e0\u9898"},{"location":"posts/2018-01-23-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E6%97%A0%E9%A2%98/#anu-","text":"","title":"ANU\u6691\u671f\u5b66\u6821-\u65e0\u9898"},{"location":"posts/2018-01-23-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E6%97%A0%E9%A2%98/#_1","text":"\u73b0\u4ee3\u5316\u7684\u57ce\u5e02\u3001\u5bf9\u81ea\u7136\u7684\u8fc7\u5ea6\u7834\u574f\uff0c\u8ba9\u4e2d\u56fd\u7684\u5e74\u8f7b\u4e00\u4ee3\u96be\u4ee5\u4f53\u4f1a\u5230\u4e00\u4e9b\u7c7b\u4f3c\u4e8e\u201c\u8349\u957f\u83ba\u98de\u201d\u3001\u201c\u843d\u971e\u5b64\u9e6d\u201d\u7684\u666f\u81f4\u4e86\u3002\u5982\u679c\u8fd9\u4e2a\u7ed3\u8bba\u4e0d\u80fd\u666e\u904d\u6210\u7acb\uff0c\u5bf9\u6211\u81ea\u5df1\u603b\u662f\u6210\u7acb\u7684\u3002 \u9ed1\u571f\u5730\u4e0a\u7565\u6709\u4e9b\u5355\u8c03\u4e86\uff0c\u4e0d\u8fc7\u5bb6\u4e61\u4ea6\u6709\u4e9b\u666f\u81f4\uff0c\u5c31\u6bd4\u5982\u7ed3\u70c8\u6cb3\u6cbf\u5cb8\u7684\u6e7f\u5730\uff0c\u5916\u52a0\u4f4e\u77ee\u7684\u704c\u6728\uff0c\u5c42\u6b21\u9519\u843d\u7684\uff0c\u4e5f\u6709\u4e9b\u5982\u753b\u4e4b\u666f\u3002\u6211\u662f\u89c1\u8fc7\u9e70\u7684\uff1b\u8fd8\u6709\u4e9b\u8da3\u5473\u5341\u8db3\u7684\u67ab\u53f6\uff0c\u6211\u603b\u6311\u4e86\u4e9b\u9001\u7ed9\u559c\u6b22\u7684\u4eba\u3002 \u4ece\u5bb6\u51fa\u6765\u4e0a\u5b66\u4e4b\u540e\uff0c\u5c31\u53d8\u5f97\u66f4\u52a0\u5355\u8c03\u3002\u4e1c\u5317\u7684\u5c71\u3001\u516c\u56ed\u5927\u540c\u5c0f\u5f02\uff0c\u6587\u5316\u7684\u79ef\u6dc0\u751a\u5c11\u3002\u6765\u5230\u5317\u4eac\uff0c\u4e5f\u6ca1\u591a\u4f53\u4f1a\u5230\u6587\u5316\u53e4\u90fd\u3001\u540d\u57ce\u7684\u8ff7\u9189\u4e4b\u610f\u3002\u5f53\u7136\u8fd9\u4e9b\u5931\u610f\u591a\u534a\u662f\u81ea\u5df1\u9020\u6210\u7684\uff0c\u73b0\u5728\u89c9\u609f\uff0c\u9ad8\u4e2d\u3001\u5927\u5b66\u6ca1\u6709\u610f\u8bc6\u53bb\u611f\u53d7\uff0c\u624d\u9020\u6210\u4e86\u5bf9\u98ce\u5149\u548c\u53e4\u57ce\u7684\u5931\u671b\u3002 \u4e2d\u56fd\u4eba\u4e00\u76f4\uff0c\u5728\u8fc7\u53bb\u7684\u51e0\u5343\u5e74\u4e2d\uff0c\u90fd\u662f\u8ddf\u81ea\u7136\u751f\u6d3b\u5728\u4e00\u8d77\u7684\u3002\u6210\u201c\u548c\u5408\u201d\u4e4b\u5883\uff0c\u662f\u6211\u4eec\u4e00\u8d2f\u7684\u3001\u6700\u9ad8\u7684\u8ffd\u6c42\u3002\u73b0\u4ee3\u5de5\u5177\u8bbe\u65bd\u5bf9\u81ea\u7136\u7684\u5165\u4fb5\u4e0e\u7834\u574f\u5df2\u7ecf\u9020\u6210\u4e86\u4e00\u79cd\u4eba\u4e0e\u81ea\u7136\u7684\u9694\u79bb\uff1b\u5728\u6063\u610f\u82b3\u534e\u7684\u5e74\u9f84\uff0c\u53bb\u65e0\u5fc3\u611f\u53d7\u8fd9\u5468\u906d\u82b1\u8349\u866b\u9c7c\uff0c\u5b9e\u5728\u662f\u6709\u4e9b\u53ef\u7b11\u3002\u4f46\u8fd9\u4f3c\u4e4e\u662f\u5fc5\u7136\u7684\uff0c\u91ce\u86ee\u7684\u53d1\u5c55\u3001\u7e41\u91cd\u7684\u5b66\u4e1a\u548c\u7ecf\u6d4e\u538b\u529b\u2026\u2026\u4eba\u4e0e\u81ea\u7136\u7684\u548c\u5408\u6015\u53ea\u80fd\u51fa\u73b0\u5728\u201c\u4eba\u95f2\u6842\u82b1\u843d\uff0c\u591c\u9759\u6625\u5c71\u7a7a\u201d\u7684\u8bd7\u53e5\u4e2d\u4e86\u3002","title":"\u4e00"},{"location":"posts/2018-01-23-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E6%97%A0%E9%A2%98/#_2","text":"\u582a\u57f9\u62c9\u5374\u662f\u4e0d\u540c\u7684\u3002 \u6211\u5728\u60f3\uff0c\u6b27\u7f8e\u7684\u4e00\u4e9b\u5730\u65b9\u662f\u4e0d\u662f\u4e0e\u582a\u57f9\u62c9\u7c7b\u4f3c\uff0c\u5bf9\u81ea\u7136\u7684\u5e72\u6270\u51e0\u8fd1\u4e3a\u96f6\uff0c\u751a\u81f3\u6709\u4e9b\u201c\u539f\u59cb\u201d\u3002\u8fd9\u79cd\u201c\u539f\u59cb\u201d\u4e0e\u9ad8\u5ea6\u53d1\u8fbe\u7684\u73b0\u4ee3\u6587\u660e\u7684\u9c9c\u660e\u5bf9\u6bd4\u662f\u6700\u6709\u8da3\u7684\u90e8\u5206\u3002\u5728ANU\u7684\u6821\u56ed\u91cc\uff0c\u4f60\u53ef\u4ee5\u95fb\u5230\u82b1\u9999\uff0c\u6b23\u8d4f\u4ece\u6839\u90e8\u5c31\u6563\u53d1\u679d\u8513\u7684\u9020\u578b\uff0c\u770b\u5230\u6ee1\u5929\u7e41\u661f\uff0c\u542c\u5154\u5988\u5988\u8bb2\u6545\u4e8b\uff08\u5927\u591a\u6570\u65f6\u95f4\u5728\u5403\u4e1c\u897f\uff09\uff0c\u60f3\u8c61\u7740\u7fa4\u9e1f\u4e89\u9e23\u5e26\u6765\u7684\u5bf9\u672a\u77e5\u7684\u65e0\u9650\u7684\u597d\u5947\u4e0e\u5fe7\u60e7\u3002 \u6682\u65f6\u63d2\u5165\u4e00\u6bb5\u5bf9\u5efa\u7b51\u7684\u63cf\u8ff0\u3002\u542c\u859b\u534e\u514b\u8001\u5e08\u8bb2\uff08\u6b64\u5904\u4e3a\u610f\u4f1a\uff09\uff0c\u4e2d\u56fd\u7684\u57ce\u5e02\u662f\u6781\u5ea6\u7f3a\u4e4f\u7f8e\u611f\u7684\uff0c\u697c\u623f\u7684\u5ba1\u7f8e\u4ef7\u503c\u5df2\u88ab\u964d\u5230\u6700\u4f4e\uff0c\u7b80\u5355\u6765\u8bf4\u5c31\u662f\u201c\u5343\u57ce\u4e00\u9762\u201d\u3002\u540e\u6765\u6211\u81ea\u5df1\u5728\u540e\u6d77\u6e38\u73a9\u65f6\uff0c\u77ac\u95f4\u5bf9\u4ed6\u7684\u89c2\u70b9\u6709\u4e9b\u66f4\u6df1\u5165\u7684\u8ba4\u8bc6\u4e86\u3002\u4e00\u4e2a\u57ce\u5e02\u662f\u4ec0\u4e48\u6837\u7684\uff0c\u770b\u6765\u8981\u5148\u628a\u4e00\u4e9b\u4e11\u964b\u7684\u3001\u65e0\u804a\u7684\u3001\u76f8\u540c\u7684\u697c\u5b87\u62c6\u6389\uff0c\u770b\u770b\u8fd8\u5269\u4e0b\u4ec0\u4e48\uff0c\u90a3\u4fbf\u662f\u8fd9\u4e2a\u57ce\u5e02\u4e86\u3002\u8981\u62c6\u5317\u7406\u5de5\uff0c\u90a3\u5317\u7406\u5de5\u4fbf\u4ec0\u4e48\u4e5f\u4e0d\u5269\u4e86\uff0c\u5317\u5916\u7684\u56fe\u4e66\u9986\u662f\u4e0d\u820d\u5f97\u62c6\u6389\u7684\uff0c\u5b83\u7684\u5916\u5899\u5145\u5206\u4f53\u73b0\u4e86\u5b83\u7684\u7f8e\u611f\uff1b\u5317\u4eac\u4e94\u73af\u516d\u73af\uff0c\u5927\u90e8\u5206\u4e5f\u53ef\u62c6\u6389\uff0c\u4e09\u56db\u73af\u53ef\u5269\u4e0b\u4e00\u4e9b\u73b0\u4ee3\u5efa\u7b51\uff0c\u5185\u57ce\u91cc\u9762\uff0c\u5927\u90e8\u5206\u7684\u6c11\u5c45\u3001\u5bab\u6bbf\u90fd\u53ef\u4ee5\u4fdd\u7559\u3002\u6211\u773c\u4e2d\u7684\u5317\u4eac\u4fbf\u662f\u8fd9\u6837\u7684\u6e05\u6670\u4e86\uff0c\u524d\u95e8\u81f3\u5929\u5b89\u95e8\uff0c\u7e41\u534e\u4e8e\u4e16\uff0c\u5a01\u4e25\u5373\u81f3\uff0c\u6545\u5bab\u4e0e\u666f\u5c71\u3001\u4ec0\u5239\u6d77\u3001\u540e\u6d77\u4fbf\u662f\u5b98\u4e0e\u6c11\u7684\u3001\u6b63\u895f\u5371\u5750\u4e0e\u60ec\u610f\u7684\u5bf9\u6bd4\u3002\u5317\u4eac\u5c31\u662f\u4e00\u4e2a\uff1a\u5a01\u800c\u6709\u95f2\uff0c\u73e0\u5149\u5b9d\u6c14\u53c8\u60a0\u5f97\u81ea\u7136\u7684\u5730\u65b9\u3002 \u56de\u5230\u582a\u57f9\u62c9\uff0c\u6211\u4eec\u6cbf\u7740\u4e61\u6751\u5c0f\u8def\u6765\u4f53\u4f1a\u4e00\u4e0b\u5979\u7684\u201c\u539f\u59cb\u201d\u3002\u79bb\u5f00\u5bb6\u4e61\u591a\u5e74\uff0c\u6211\u5df2\u7ecf\u592a\u4e45\u672a\u89c1\u5230\u6beb\u65e0\u4fee\u847a\u7684\u201c\u4e61\u95f4\u5c0f\u8def\u201d\u4e86\uff0c\u8fd9\u79cd\u201c\u5e7d\u5f84\u201d\u5728\u6211\u5bb6\u662f\u6709\u7684\u3002\u8fd9\u91cc\u7684\u5c0f\u8def\u4e00\u822c\u6cbf\u6cb3\u624d\u6709\u3002\u662f\u201c\u8d70\u7684\u4eba\u591a\u4e86\u201d\u8e29\u51fa\u7684\u5c0f\u8def\uff0c\u662f\u4e0d\u5e73\u6574\u7684\u3001\u8513\u8349\u4e1b\u751f\u7684\u5c0f\u8def\u3002\u201c\u4e94\u4e5d\u516d\u4e5d\uff0c\u6cbf\u6cb3\u770b\u67f3\u201d\u867d\u5199\u521d\u6625\uff0c\u7528\u5230\u8fd9\u91cc\u4ea6\u6070\u5982\u5176\u5206\u3002\u53ea\u6709\u5728\u6cb3\u8fb9\uff08\u83ab\u6717\u683c\u6d1b\u6cb3\uff09\u624d\u6709\u67f3\u6811\u3002\u8fdc\u671b\u5782\u67f3\uff0c\u679c\u5982\u65b0\u5a18\u3002\u8d70\u5230\u4e00\u5904\uff0c\u873f\u8712\u6d41\u8f6c\uff0c\u5f69\u9547\u7ae5\u8bdd\uff0c\u6eaa\u6d41\u3001\u7eff\u6811\u3001\u884c\u4eba\u5728\u4e00\u77ac\u95f4\u8fbe\u5230\u548c\u8c10\uff0c\u6b63\u662f\u201c\u5f2f\u5f2f\u7684\u6d41\u6c34\u554a\uff0c\u84dd\u84dd\u7684\u5929\uff1b\u7eff\u6cb9\u6cb9\u7684\u8349\u5730\u554a\uff0c\u9752\u9752\u7684\u5c71\u201d\u3002\u6cb3\u6d41\u873f\u8712\uff0c\u5c31\u8981\u8fc7\u6865\u3002\u6865\u4ea6\u662f\u4e0d\u53ef\u7f3a\u5c11\u7684\u5143\u7d20\uff0c\u201c\u5c0f\u6865\u6d41\u6c34\u4eba\u5bb6\u201d\uff0c\u8fd9\u4e9b\u603b\u662f\u5728\u4e00\u8d77\u7684\uff0c\u8fd9\u6fb3\u6d32\u4eba\u7684\u5ba1\u7f8e\u4e0e\u4e2d\u56fd\u4eba\u4e5f\u6ca1\u6709\u4ec0\u4e48\u4e0d\u540c\u554a\u3002\u6cbf\u6cb3\u53f3\u5cb8\u5411\u5357\u8d70\uff0c\u8fc7\u4e00\u7247\u6797\u5730\u4fbf\u4f3c\u6ca1\u6709\u8def\u4e86\u3002\u6211\u5728\u6797\u4e2d\uff0c\u7b2c\u4e00\u6b21\u770b\u89c1\u4e86\u58c1\u864e\uff1b\u6211\u5728\u8fd9\u6797\u4e2d\uff0c\u4e5f\u770b\u5230\u4e86\u201c\u6e14\u6a35\u201d\u4e4b\u4e8b\u3002\u6709\u4e9b\u7f81\u7eca\u7684\u5c0f\u8def\uff0c\u5145\u6ee1\u4e86\u9677\u9631\u4e0e\u60ca\u5947\uff08\u6b8b\u679d\u4e4b\u4e0b\uff0c\u4e2d\u7a7a\u4e5f\uff0c\u730e\u4eba\u6280\uff09\u3002\u7ee7\u7eed\u5411\u5357\u63a2\u53bb\uff08\u56e0\u6211\u4eec\u770b\u5230\u8fdc\u5904\u7684\u9ad8\u67b6\uff09\uff0c\u679c\u7136\u662f\u201c\u5c71\u91cd\u6c34\u590d\u7591\u65e0\u8def\uff0c\u67f3\u6697\u82b1\u660e\u53c8\u4e00\u6751\u201d\u3002\u6211\u4eec\u53d1\u73b0\u4e86\u8d70\u51fa\u6797\u5730\u524d\u5f80\u516c\u8def\u7684\u6377\u5f84\uff0c\u4fbf\u8e0f\u4e86\u4e0a\u53bb\u3002\u8fc7\u4e86\u9a6c\u8def\uff0c\u6765\u5230\u9ad8\u67b6\u6865\u4e0b\u3002\u6709\u4eba\u51b2\u4e0a\u9ad8\u67b6\u6865\u7684\u9661\u5761\uff0c\u60f3\u4e00\u7779\u683c\u91cc\u82ac\u6e56\u7684\u9762\u5bb9\uff0c\u5c31\u50cf\u662f\u770b\u5362\u820d\u90a3\u5927\u4f5b\u65f6\u5019\u7684\u90a3\u79cd\u610f\u5883\uff0c\u6cbf\u9636\u800c\u4e0a\uff0c\u5362\u820d\u90a3\u4e00\u70b9\u4e00\u70b9\u5730\u51fa\u73b0\uff0c\u90a3\u89c6\u89c9\u7684\u51b2\u51fb\u548c\u5fc3\u7406\u7684\u51b2\u51fb\u662f\u6781\u5176\u5f3a\u70c8\u7684\u3002\u662f\u201c\u795e\u5723\u201d\u4e0e\u201c\u60ca\u559c\u7684\u7ed3\u5408\u201d\uff0c\u662f\u201c\u6cbf\u9636\u800c\u4e0a\u201d\u548c\u201c\u4ece\u4e0a\u81f3\u4e0b\u6d6e\u73b0\u201d\u7684\u76f8\u6620\u6210\u8da3\u3002\u672c\u60f3\uff0c\u683c\u91cc\u82ac\u6e56\u7684\u8fdc\u895f\u8981\u65e9\u51fa\u73b0\uff0c\u7d27\u63a5\u7740\u662f\u5982\u5c71\u7684\u9f3b\u5b50\uff0c\u518d\u5c31\u662f\u660e\u955c\u822c\u7684\u773c\u7738\u2026\u2026\u5b81\u9759\u81f4\u8fdc\uff0c\u5fc3\u65f7\u795e\u6021\u3002\u54ce\u54ce\u54ce\uff0c\u53f9\u53f9\u53f9\uff01\u8fd9\u683c\u91cc\u82ac\u6e56\u662f\u4e2a\u6781\u5bb3\u7f9e\u7684\u7f8e\u4eba\uff0c\u8ba9\u4e00\u6392\u6392\u7684\u201c\u68a7\u6850\u201d\uff08\u6216\u8bb8\u662f\u68a7\u6850\uff09\u548c\u5782\u67f3\u505a\u4e86\u73e0\u5e18\uff0c\u786c\u8981\u60f9\u4f60\u63a5\u8fd1\uff0c\u4eb2\u81ea\u5377\u5e18\u624d\u6ee1\u8db3\u5462\uff01","title":"\u4e8c"},{"location":"posts/2018-01-23-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E6%97%A0%E9%A2%98/#_3","text":"\u6cbf\u7740\u6cb3\u8fb9\u5c0f\u8def\u5411\u4e1c\u884c\uff0c\u8fd9\u662f\u4e2a10\u516c\u91cc\u7684\u81ea\u884c\u8f66\u8d5b\u9053\uff0c\u4e5f\u6709\u4eba\u5728\u8dd1\u6b65\uff0c\u4ea6\u6709\u4e9b\u7f8e\u4e3d\u7684\u8bf4\u4e0d\u51fa\u540d\u5b57\u7684\u9e1f\u548c\u6210\u7a9d\u7684\u5154\u5b50\u3002\u8fd9\u91cc\u53ef\u4ee5\u7ed9\u4e88\u4e00\u5207\u5bf9\u6e56\u5149\u5c71\u8272\u7684\u524d\u666f\u7684\u60f3\u8c61\uff0c\u6811\u6797\u9634\u7ff3\uff0c\u660e\u6697\u76f8\u95f4\uff0c\u6e56\u98ce\u5148\u81f3\uff0c\u7fe0\u9e1f\u683e\u9e23\u2026\u2026\u771f\u613f\u8eba\u4e0b\uff0c\u7528\u808c\u80a4\u53bb\u542c\uff0c\u7528\u773c\u775b\u53bb\u95fb\uff0c\u7528\u9f3b\u5b50\u53bb\u770b\uff0c\u7528\u5fc3\u53bb\u7545\u60f3\uff0c\u7528\u8111\u53bb\u4f53\u4f1a\u751f\u547d\u7684\u5f8b\u52a8\u3002 \u6765\u5230\u4e00\u7247\u5c0f\u9614\u5730\uff0c\u987a\u7740\u655e\u53e3\u8fdc\u773a\uff0c\u5fc3\u662f\u6026\u6026\u76f4\u8df3\uff0c\u811a\u662f\u4e0d\u7531\u81ea\u4e3b\uff0c\u8fd9\u662f\u4ec0\u4e48\u611f\u89c9\u554a\uff01\u8fd9\u662f\u4e00\u89c1\u949f\u60c5\u554a\uff01\u8fd9\u6e56\u5149\u5c71\u8272\uff0c\u8be5\u600e\u4e48\u5f62\u5bb9\uff1f\u662f\u201c\u843d\u971e\u4e0e\u5b64\u9e5c\u9f50\u98de\uff0c\u79cb\u6c34\u5171\u957f\u5929\u4e00\u8272\u201d\u4e48\uff1f\u843d\u971e\u4ea6\u5982\u683c\u91cc\u82ac\u6e56\u4e00\u822c\u7f9e\u6da9\uff0c\u8499\u4e86\u7eb1\uff0c\u8fdc\u8fdc\u5f97\u8eb2\u5728\u5c71\u540e\u9762\uff0c\u9732\u51fa\u4e00\u70b9\u7aef\u502a\uff0c\u98de\u9e1f\u7fe9\u7fe9\uff0c\u8f7b\u76c8\u52a8\u4eba\uff1b\u786e\u662f\u201c\u6c34\u5171\u957f\u5929\u4e00\u8272\u201d\u7684\uff0c\u53ea\u4e0d\u8fc7\uff0c\u73b0\u5728\u662f\u6fb3\u6d32\u76848\u6708\uff0c\u8bf4\u79cb\u6709\u4e9b\u65e9\u4e86\u3002\u662f\u201c\u534a\u4ea9\u65b9\u5858\u4e00\u9274\u5f00\uff0c\u5929\u5149\u4e91\u5f71\u5171\u5f98\u5f8a\u201d\u4e48\uff1f\u8fd9\u6e56\u7684\u5927\u5c0f\u771f\u662f\u6070\u5230\u597d\u5904\uff0c\u6211\u4eec\u5927\u6982\u5728\u6e56\u5317\u4e2d\u90e8\u504f\u897f\uff0c\u6e56\u6c34\u4e00\u6620\u773c\u5e95\u4e14\u9752\u5c71\u7686\u5982\u542b\u82de\u70b9\u7f00\u6216\u8fde\u7f00\u5728\u6e56\u7684\u4e09\u9762\uff0c\u5c31\u50cf\u662f\u660e\u955c\u7684\u82b1\u8fb9\uff0c\u4f46\u5374\u6709\u65e0\u9650\u7684\u751f\u673a\uff1b\u6070\u5f53\u7684\u5e03\u5c40\u8ba9\u4f60\u60c5\u4e0d\u81ea\u7981\u5730\u60f3\u62e5\u62b1\u5979\uff0c\u56e0\u4e3a\u5728\u5979\u9762\u524d\uff0c\u4eba\u4f3c\u4e4e\u6709\u8db3\u591f\u7684\u4f38\u5c55\u529b\u4e86\uff1b\u201c\u5929\u5149\u4e91\u5f71\u201d\u53ea\u5360\u4e91\u5f71\uff0c\u201c\u5929\u5149\u4e91\u5f71\u201d\u5199\u7684\u662f\u84dd\u5929\u767d\u4e91\uff0c\u800c\u4e14\u662f\u6210\u6735\u7684\u7a00\u758f\u7684\u767d\u4e91\uff0c\u5012\u6620\u6c34\u4e2d\uff0c\u4efb\u7531\u7fa4\u9e2d\u63a8\u5f00\u6e56\u9762\u3002\u508d\u665a\u4ee5\u81f4\uff0c\u4e91\u6709\u4e9b\u9634\uff0c\u6574\u4f53\u8272\u8c03\u504f\u6697\uff0c\u4e91\u5f71\u5145\u6ee1\u6c34\u9762\uff0c\u4ece\u4e2d\u53ef\u4ee5\u770b\u5230\u6c34\u58a8\u753b\uff0c\u662f\u6d53\u6de1\u3001\u6392\u5e03\u7684\u827a\u672f\u3002\u6e56\u98ce\u6251\u9762\uff0c\u7a7a\u6c14\u6e7f\u6da6\uff0c\u8fd9\u9634\u4e91\u5e26\u6765\u7684\u4e00\u70b9\u513f\u4e5f\u4e0d\u662f\u538b\u6291\uff0c\u800c\u662f\u8ba9\u4f60\u6781\u5c3d\u5730\u8212\u5c55\uff0c\u8ba9\u4f60\u5fc3\u8fdc\u610f\u8fc1\uff0c\u7ed9\u4f60\u65e0\u9650\u7684\u60ec\u610f\u4e0e\u4eab\u53d7\u3002\u843d\u65e5\u5c3d\u4e8e\u5c71\u524d\uff0c\u4fbf\u662f\u201c\u534a\u6c5f\u745f\u745f\u534a\u6c5f\u7ea2\u201d\uff0c\u56e0\u6765\u7684\u7a0d\u665a\uff0c\u201c\u4e00\u9053\u6b8b\u9633\u201d\u4e0d\u590d\u518d\u73b0\u4e86\u3002\u6ca1\u6709\u9057\u61be\uff0c\u51ed\u4ec0\u4e48\u6000\u5ff5\uff1f\u6211\u51b3\u5b9a\u8981\u8d70\uff0c\u8ba9\u5979\u6210\u4e3a\u8bb0\u5fc6\uff0c\u8ba9\u6211\u6c38\u4e45\u7684\u56de\u5473\u5427\u3002","title":"\u4e09"},{"location":"posts/2018-01-23-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E6%97%A0%E9%A2%98/#_4","text":"\u7ee7\u5411\u4e1c\u884c\uff0c\u6298\u5de6\u5411\u5317\u7531\u8fdb\u5165\u4e86ANU\u7684\u6821\u56ed\uff0c\u73b0\u5728\u6211\u4eec\u5728\u6cb3\u7684\u53e6\u4e00\u5cb8\u3002\u6821\u56ed\u5bc2\u9759\uff0c\u8def\u9762\u8d77\u4f0f\uff0c\u6211\u4eec\u8d39\u4e86\u4e9b\u529f\u592b\u624d\u56de\u5230\u4f4f\u5904\uff08Bruce Hall\uff09\u3002 \u51e0\u65e5\u4e4b\u884c\uff0c\u9971\u7779\u98ce\u5149\uff0c\u5fc3\u7eea\u4e07\u5343\uff0c\u4f5c\u6587\u7559\u5ff5\u3002","title":"\u56db"},{"location":"posts/2018-01-24-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E7%BB%BD%E6%94%BE/","text":"ANU\u6691\u671f\u5b66\u6821-\u7efd\u653e \u4f4e\u843d\u7684\u65e5\u5b50 \u5728\u79ef\u7d2f\u60c5\u7eea \u7efd\u653e\u4e8e\u7b14\u5c16\u7684 \u662f\u98ce\u666f\u7684\u5fc3\u60c5 \u7eda\u70c2\u8fc7\u540e \u662f\u6ca1\u843d \u662f\u7a7a\u767d \u4e00\u6b21\u6bd4\u4e00\u6b21 \u75db\u82e6 \u4e00\u6b21\u6bd4\u4e00\u6b21 \u6765\u5f97\u5feb \u4e0d\u884c\u8d70\u4e86 \u4e0d\u611f\u77e5\u4e86 \u8ba9\u75db\u82e6\u8fdc\u4e9b\u5427 \u7206\u53d1\u7684\u72c2\u559c\u4e5f\u4e0d\u8981\u4e86 \u65f6\u95f4\u5b9a\u683c\u5427 \u8ba9\u4fb5\u4e0a\u7684\u75db\u505c\u4f4f\u5427 \u5509 \u6211\u4ec0\u4e48\u4e5f\u65e0\u529b\u963b\u6b62","title":"ANU\u6691\u671f\u5b66\u6821-\u7efd\u653e"},{"location":"posts/2018-01-24-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E7%BB%BD%E6%94%BE/#anu-","text":"\u4f4e\u843d\u7684\u65e5\u5b50 \u5728\u79ef\u7d2f\u60c5\u7eea \u7efd\u653e\u4e8e\u7b14\u5c16\u7684 \u662f\u98ce\u666f\u7684\u5fc3\u60c5 \u7eda\u70c2\u8fc7\u540e \u662f\u6ca1\u843d \u662f\u7a7a\u767d \u4e00\u6b21\u6bd4\u4e00\u6b21 \u75db\u82e6 \u4e00\u6b21\u6bd4\u4e00\u6b21 \u6765\u5f97\u5feb \u4e0d\u884c\u8d70\u4e86 \u4e0d\u611f\u77e5\u4e86 \u8ba9\u75db\u82e6\u8fdc\u4e9b\u5427 \u7206\u53d1\u7684\u72c2\u559c\u4e5f\u4e0d\u8981\u4e86 \u65f6\u95f4\u5b9a\u683c\u5427 \u8ba9\u4fb5\u4e0a\u7684\u75db\u505c\u4f4f\u5427 \u5509 \u6211\u4ec0\u4e48\u4e5f\u65e0\u529b\u963b\u6b62","title":"ANU\u6691\u671f\u5b66\u6821-\u7efd\u653e"},{"location":"posts/2018-02-01-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E6%88%91%E7%9A%84%E7%9F%9B%E7%9B%BE/","text":"ANU\u6691\u671f\u5b66\u6821-\u6211\u7684\u77db\u76fe \u4e00 \u8bf4\u8d77\u82f1\u8bed\u5b66\u4e60\uff0c\u53ef\u771f\u662f\u4e00\u8a00\u96be\u5c3d\u3002\u5373\u4fbf\u662f\u62a5\u4e86\u8865\u4e60\u73ed\uff0c\u6bcf\u5929\u4e5f\u52aa\u529b\u5730\u5b66\u4e60\uff0c\u8fd8\u662f\u89c9\u5f97\u4e0d\u53ef\u80fd\u628a\u82f1\u8bed\u5b66\u597d\u3002\u8001\u5e08\u6559\u3001\u81ea\u5df1\u5b66\u3001\u82f1\u8bed\u73af\u5883\uff0c\u5982\u679c\u8bf4\u8fd9\u4e09\u70b9\u90fd\u6ee1\u8db3\u5c31\u80fd\u628a\u82f1\u8bed\u5b66\u597d\uff0c\u6015\u6211\u65e9\u5c31\u662f\u82f1\u8bed\u80fd\u624b\u4e86\u3002\u4e8b\u60c5\u5f80\u5f80\u4e0d\u662f\u90a3\u4e48\u7b80\u5355\uff0c\u66f4\u4f55\u51b5\uff0c\u4ece\u6765\u90fd\u6ca1\u6709\u6784\u5efa\u4e00\u4e2a\u82f1\u8bed\u73af\u5883\u3002\u8fd9\u6b21\u5230\u56fd\u5916\u6765\uff0c\u4e5f\u6709\u4e00\u4e9b\u5173\u4e8e\u6784\u5efa\u82f1\u8bed\u73af\u5883\u7684\u60f3\u6cd5\uff0c\u6bd4\u5982\uff0c\u7528\u82f1\u8bed\u601d\u8003\u3001\u5fc3\u91cc\u9ed8\u5ff5\u522b\u4eba\u8bf4\u7684\u8bdd\u3001\u67e5\u770b\u56fd\u5916\u52a8\u7269\u56ed\u7684\u7f51\u7ad9\u2026\u2026\u8fd9\u4e00\u6b21\u51fa\u884c\uff0c\u4e00\u822c\u7684\u4ea4\u6d41\u7528\u5230\u7684\u8bcd\u6c47\u51e0\u4e4e\u6ca1\u6709\u8d85\u8fc7\u81ea\u5df1\u7684\u6c34\u5e73\uff085000\u5de6\u53f3\uff09;\u4f46\u662f\u7a0d\u5fae\u6b63\u5f0f\u4e00\u70b9\u513f\u7684\u670d\u52a1\u4e0e\u6f14\u8bb2\u5c31\u8981\u6d89\u53ca\u66f4\u591a\u7684\u8bcd\u6c47\u4e86\uff0c\u6bd4\u5982\u70b9\u9910\u3001\u53f8\u673a\u5e08\u5085\u5728\u5f00\u8f66\u524d\u3001\u9014\u4e2d\u548c\u7ec8\u70b9\u524d\u7684\u6e29\u99a8\u63d0\u793a\u3002\u5982\u679c\u8981\u60f3\u542c\u61c2\u8fd9\u4e9b\uff0c\u786e\u5b9e\u8981\u8d39\u4e9b\u65f6\u65e5\u3002\u5982\u679c\u628a\u6211\u653e\u5728\u56fd\u5916\uff0c\u6211\u60f3\u6211\u56de\u627e\u4e00\u4e2a\u5916\u56fd\u4eba\u4f7f\u52b2\u513f\u5730\u95ee\uff0c\u8fd9\u4e2a\u4ec0\u4e48\u90a3\u662f\u4ec0\u4e48\uff0c\u6765\u5b66\u4e60\u751f\u8bcd\u548c\u53e5\u5b50\u3002\u6211\u8fd8\u4f1a\u5c3d\u53ef\u80fd\u7684\u9605\u8bfb\u82f1\u6587\u7684\u4ecb\u7ecd\u548c\u80cc\u666f\u77e5\u8bc6\u3002\u6211\u4f1a\u5c3d\u53ef\u80fd\u5730\u63a5\u89e6\u751f\u6d3b\u7684\u6bcf\u4e00\u65b9\u9762\uff0c\u5b66\u4e60\u8bcd\u6c47\u548c\u77ed\u8bed\u3002\u6211\u4f1a\u5c3d\u53ef\u80fd\u7684\u4e0e\u5916\u56fd\u4eba\u4ea4\u6d41\uff0c\u56de\u987e\u548c\u5c55\u671b\uff0c\u518d\u8fdb\u4e00\u6b65\u8ba8\u8bba\u6587\u5316\u3002\u603b\u7ed3\u8d77\u6765\uff0c\u65e0\u975e\u5c31\u662f\u6700\u5927\u9650\u5ea6\u7684\u878d\u5165\u4ed6\u4eec\u3002 \u8865\u5145\u4e00\u4e9b\u4e0eX\u541b\u7684\u4ea4\u6d41\u3002\u201c\u7528\u82f1\u8bed\u601d\u8003\u3001\u5927\u91cf\u7684\u57fa\u7840\u9605\u8bfb\uff08\u8bfe\u7a0b\uff09\u4ee5\u53ca\u5199\u4f5c\u662f\u8f83\u597d\u7684\u5b66\u4e60\u8bed\u8a00\u7684\u8981\u7d20\u201d\u3002 \u4ee5\u4e0a\u8fd9\u4e9b\u7edd\u5bf9\u662f\u8bf4\u7684\u8f7b\u677e\uff0c\u505a\u8d77\u6765\u96be\u3002\u65f6\u95f4\uff0c\u9700\u8981\u65f6\u95f4\u3002\u5982\u679c\u6bcf\u5929\u9700\u89813\u4e2a\u5c0f\u65f6\uff0c\u90a3\u5c31\u5f97\u534a\u5e74\u624d\u521d\u89c1\u7aef\u502a\u3002\u5f88\u663e\u7136\uff0c\u4e0d\u53ef\u80fd\u6bcf\u5929\u6709\u90a3\u4e48\u591a\u7684\u65f6\u95f4\u3002\u5982\u679c\uff0c\u73b0\u5728\u8ba9\u6211\u9009\u62e9\uff0c\u6211\u5927\u6982\u4f1a\u8fdb\u4e00\u6b65\u538b\u7f29\u793e\u4ea4\u4e0e\u751f\u6d3b\u7684\u65f6\u95f4\uff0c\u8ba9\u5de5\u4f5c\u7684\u6bcf\u4e00\u5929\u5c3d\u53ef\u80fd\u9ad8\u6548\u548c\u5145\u5b9e\u3002\u56e0\u4e3a\u6211\u6700\u8fd1\u660e\u767d\u8fc7\u6765\uff0c\u4e0d\u7eaf\u7cb9\u7684\u4f11\u606f\u603b\u662f\u4e00\u70b9\u610f\u4e49\u90fd\u6ca1\u6709\u7684\u3002\u4f60\u6839\u672c\u65e0\u6cd5\u5f97\u5230\u751f\u6d3b\u7684\u52a8\u529b\uff0c\u90a3\u79cd\u4f11\u606f\u7eaf\u7cb9\u662f\u8eab\u4f53\u4e0a\u4f11\u606f\uff0c\u4f46\u7cbe\u795e\u4e0a\u7684\u4e4f\u4e0d\u89e3\uff0c\u4e00\u6837\u6ca1\u6709\u7528\u3002\u5de5\u4f5c\u65f6\u6bb5\u8ba4\u771f\u5de5\u4f5c\u3001\u4eab\u53d7\u5de5\u4f5c\uff0c\u6512\u94b1\u5ea6\u5047\uff0c\u8d70\u8fdc\u4e00\u4e9b\uff0c\u65f6\u95f4\u957f\u4e00\u4e9b\uff08\u81f3\u5c11\u4e00\u5468\uff09\uff0c\u80fd\u5728\u6781\u5927\u653e\u677e\u7684\u540c\u65f6\u83b7\u5f97\u6781\u5927\u7684\u80fd\u91cf\uff0c\u53ef\u4ee5\u652f\u6491\u8f83\u957f\u65f6\u95f4\u7684\u503e\u60c5\u6295\u5165\u3002\u6b63\u5f0f\u6253\u7834\u4e86\u4e4b\u524d\u7684\u5e73\u8861\u4e00\u5207\u7684\u7406\u8bba\uff0c\u83b7\u53d6\u53ef\u4ee5\u51cf\u8f7b\u4e00\u4e9b\u75db\u82e6\u3002 \u7ee7\u7eed\u8bf4\u65f6\u95f4\u3002\u8fd9\u6837\u6211\u53ef\u4ee5\u505a\u4e00\u4e2a\u8f83\u957f\u65f6\u95f4\u7684\u8ba1\u5212\u3002\u4e00\u4e2a\u6708\u751a\u81f3\u51e0\u4e2a\u6708\uff0c\u5de5\u4f5c\u4e2d\u6709\u6210\u679c\u6709\u8fdb\u5c55\u3002\u6fb3\u5927\u5229\u4e9a\u662f\u4e2a\u65c5\u6e38\u7684\u597d\u5730\u65b9\uff08\u8fd9\u53e5\u8bdd\u662f\u4e2a\u4e07\u80fd\u7684\u53e5\u5b50\uff09\u3002\u8fd9\u91cc\u7684\u8282\u594f\u9002\u5408\u65c5\u6e38\u3002\u4e0d\u8981\u5f88\u5927\u7684\u56e2\uff0c\u51e0\u4e2a\u4eba\u4e00\u8d77\uff0c\u8981\u6709\u70ed\u60c5\u7684\u3001\u8981\u6709\u8bd7\u610f\u7684\u3001\u6709\u903b\u8f91\u7684\u3002\u5982\u679c\u8981\u505a\u4e00\u4e9b\u65c5\u6e38\u7684\u8ba1\u5212\uff0c\u5c31\u53ef\u4ee5\u6765\u6fb3\u6d32\u3002\u5de5\u4f5c\u7684\u73af\u5883\u4e5f\u5f88\u91cd\u8981\uff0c\u6700\u597d\u662f\u6709\u4e00\u4e2a\u6bd4\u8f83\u72ec\u7acb\u7684\u7a7a\u95f4\uff0c\u53ef\u4ee5\u662f\u5f00\u653e\u5f0f\u7684\uff0c\u4f46\u8981\u76f8\u5bf9\u4e0d\u88ab\u6253\u6270\u3002\u8fd9\u6837\u7684\u5de5\u4f5c\u6761\u4ef6\u53ef\u4ee5\u8ba9\u4eba\u4fdd\u6301\u826f\u597d\u7684\u5fc3\u60c5\u3001\u79ef\u6781\u7684\u6001\u5ea6\u3002\u5f53\u7136\u56e2\u961f\u4e5f\u5f88\u91cd\u8981\uff0c\u5c24\u5176\u662f\u4e00\u4e2a\u4eba\u7684\u79d1\u7814\u89c2\u5ff5\u521a\u521a\u5efa\u7acb\u7684\u65f6\u5019\u3002\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u662f\u65e0\u6cd5\u6d3b\u5f97\u8fd9\u6837\u7684\u5de5\u4f5c\u6761\u4ef6\u7684\uff0c\u6240\u4ee5\u53ea\u80fd\u968f\u7f18\u4e86\u3002\u5f53\u7136\u66f4\u5e0c\u671b\uff0c\u539f\u5219\u4e0a\u751f\u6d3b\u4e0e\u5de5\u4f5c\u5206\u5f00\u3002\u5de5\u4f5c\u7684\u65f6\u95f4\u53ef\u4ee5\u66f4\u957f\u4e00\u4e9b\uff0c\u7559\u597d\u9700\u8981\u5b66\u4e60\u7684\u65f6\u95f4\uff0c\u5c3d\u53ef\u80fd\u538b\u7f29\u5403\u996d\u7684\u65f6\u95f4\uff08\u5b58\u7591\uff0c\u5916\u56fd\u4eba\u5403\u996d\u65f6\u5019\u804a\u5929\u624d\u662f\u4e3b\u4e1a\uff09\u3002 \u5f53\u7136\uff0c\u6211\u4eec\u7684\u751f\u6d3b\u9700\u8981\u8c03\u5473\u5242\uff0c\u50cf\u4e00\u4e2a\u8bd7\u4eba\u4e00\u6837\u611f\u53d7\u5168\u4e16\u754c\u7684\u65f6\u5019\u96be\u514d\u5931\u53bb\u81ea\u6211\u3002\u800c\u611f\u53d7\u7684\u76ee\u7684\u6070\u6070\u662f\u4e3a\u4e86\u8868\u8fbe\u81ea\u6211\u3002\u8981\u5148\u5931\u53bb\uff08\u4e0a\u4e00\u6b21\u8868\u8fbe\uff09\uff0c\u5728\u9010\u6e10\u627e\u56de\u672c\u771f\u7684\u65f6\u5019\u628a\u4ed6\u4eec\u5199\u4e0b\u6765\uff0c\u53d1\u8868\u51fa\u53bb\u6216\u4f5c\u4e3a\u79c1\u5bb6\u65e5\u8bb0\uff0c\u518d\u4e00\u6b21\u628a\u81ea\u5df1\u653e\u7a7a\uff0c\u8ba9\u5185\u5fc3\u5145\u6ee1\u6e34\u671b\uff08\u5f53\u7136\u4e5f\u662f\u7a7a\u865a\uff09\uff0c\u4e00\u6b21\u6587\u7ae0\u4fbf\u662f\u4e00\u6b21\u8c03\u5242\u4e86\u3002\u8fd9\u662f\u4e00\u79cd\u7eda\u70c2\u7684\u8c03\u5242\uff0c\u4e00\u5207\u7684\u76ee\u7684\uff0c\u4e00\u5207\u7684\u5f52\u5bbf\u3002\u5728\u5de5\u4f5c\u4e2d\uff0c\u4f3c\u4e4e\u6709\u70b9\u68d8\u624b\u3002\u5de5\u4f5c\u4e2d\u7684\u8c03\u5242\u53c8\u662f\u4ec0\u4e48\u5462\uff1f\u8fd8\u6ca1\u6709\u7b54\u6848\uff0c\u662f\u751f\u6d3b\u4e48\uff1f\u5c31\u50cf\u4f53\u9a8c\u7684\u6700\u7ec8\u662f\u5199\u4e00\u7bc7\u6587\u7ae0\uff0c\u90a3\u5de5\u4f5c\u7684\u7ec8\u7ed3\u662f\u4ec0\u4e48\u5462\uff1f\u6362\u4e2a\u89d2\u5ea6\u601d\u8003\uff0c\u5199\u4e00\u7bc7\u6587\u7ae0\u662f\u6d88\u8017\uff0c\u662f\u4e3a\u4e86\u8ba9\u81ea\u5df1\u4fdd\u6301\u6e34\u671b\uff0c\u90a3\u5de5\u4f5c\u7684\u6d88\u8017\u53c8\u662f\u4ec0\u4e48\u5462\uff1f\u8ba9\u6211\u4eec\u5148\u653e\u4e00\u653e\u3002 \u603b\u4e4b\uff0c\u6211\u53c8\u62e5\u6709\u4e86\u4e00\u79cd\u65b0\u7684\u4f53\u609f\uff0c\u53ef\u4ee5\u8f83\u5c11\u75db\u82e6\u3002\u6295\u5165\u3001\u8c03\u5242\uff0c\u65e0\u6b62\u5883\u7684\u601d\u8003\u4e0e\u70ed\u60c5\u3002 \u4e8c \u8bf4\u8d77\u8bed\u8a00\u5b66\u4e60\uff0c\u4e0d\u5f97\u4e0d\u8bf4\u8d77\u6cd5\u8bed\u7684\u5b66\u4e60\u3002\u6cd5\u8bed\u7684\u5b66\u4e60\u6700\u7ec8\u8ba9\u6211\u5bfb\u5230\u4e86\u4e00\u79cd\u751f\u547d\u7684\u53ef\u80fd\u3002\u4e0d\u77e5\u9053\u8fc7\u53bb\u662f\u4e0d\u662f\u540c\u6837\u7684\u611f\u53d7\uff0c\u89c9\u5f97\u81ea\u5df1\u7684\u672a\u6765\u5df2\u7ecf\u627e\u5230\u3002\u6211\u8fd9\u6b21\u806a\u660e\u4e86\uff0c\u4e0d\u90a3\u4e48\u8bf4\u4e00\u5b9a\u3002\u6211\u60f3\u672a\u6765\u51e0\u5e74\u5e94\u8be5\u662f\u8fd9\u6837\u7684\uff0c\u800c\u4e14\u5bf9\u8fd9\u79cd\u751f\u6d3b\u7684\u53ef\u80fd\u6027\uff0c\u8ba9\u4eba\u7edd\u4e0d\u6000\u7591\u3002 \u8fd9\u79cd\u751f\u547d\u8ba9\u4eba\u6781\u5176\u4e30\u5bcc\u3002\u8fd9\u79cd\u751f\u547d\u8981\u6c42\u4f60\u6781\u5927\u7684\u878d\u5165\u751f\u6d3b\u3002\u4e3a\u4ec0\u4e48\u6211\u521a\u521a\u8ba4\u8bc6\u5230\u81ea\u5df1\u8981\u6781\u5927\u7684\u878d\u5165\u751f\u6d3b\uff1f\u9ad8\u4e2d\u6bd5\u4e1a\u7684\u65f6\u5019\u4fbf\u6709\u4e00\u4e9b\u840c\u82bd\uff0c\u4f46\u662f\u90a3\u65f6\u5019\u505a\u7684\u53ea\u662f\u5bf9\u5b66\u4e60\u7684\u53cd\u6297\uff0c\u4ee5\u4e3a\u4e0d\u5b66\u4e60\u5c31\u662f\u751f\u6d3b\u4e86\u3002\u5176\u5b9e\u4e0d\u662f\u3002\u800c\u65b0\u5b66\u4e60\u4e00\u95e8\u8bed\u8a00\u8ba9\u9ebb\u6728\u7684\u795e\u7ecf\u82cf\u9192\uff0c\u539f\u6765\uff0c\u6211\u4eec\u90a3\u4e48\u4e0d\u4e86\u89e3\u81ea\u5df1\u7684\u751f\u6d3b\u7684\u57ce\u5e02\uff08\u5f53\u7136\u8fd9\u4e5f\u6709C\u541b\u5bf9\u6211\u7684\u523a\u6fc0\uff09\uff0c\u5730\u6807\u3001\u6c11\u4fd7\u3001\u6587\u5316\u3001\u4ea4\u901a\u3001\u52a8\u7269\u56ed\u3001\u79d1\u6280\u9986\u3001\u996e\u98df\u3001\u5929\u6c14\u3001\u6cd5\u5f8b\u3001\u7535\u5f71\u9662\uff0c\u4e00\u5207\u4e00\u5207\u7684\u751f\u6d3b\u5c31\u5728\u751f\u6d3b\u4e4b\u4e2d\u3002\u91cd\u65b0\u5b66\u4e60\u4e00\u95e8\u8bed\u8a00\u5c31\u9700\u8981\u638c\u63e1\u8fd9\u4e9b\u8bcd\u6c47\uff0c\u5c31\u9700\u8981\u7528\u8033\u6735\u542c\uff0c\u7528\u773c\u775b\u770b\uff0c\u7528\u5fc3\u53bb\u611f\u53d7\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u5b66\u4e60\u65b0\u8bed\u8a00\u8ba9\u6211\u89e3\u5f00\u4e86\u4e00\u4e2a\u7591\u95ee\uff1a\u6211\u7a76\u7adf\u5fd8\u4e86\u4ec0\u4e48\uff1f\u6211\u5fd8\u4e86\u8981\u597d\u597d\u5730\u505a\u4f5c\u4e1a\u3001\u542c\u8bfe\u3001\u597d\u597d\u590d\u4e60\uff0c\u8981\u52aa\u529b\u8ddf\u4e0a\u8fdb\u5ea6\uff0c\u8981\u82b1\u8d39\u957f\u65f6\u95f4\u7684\u8fdb\u884c\u8bad\u7ec3\u548c\u62d3\u5c55\uff0c\u5f53\u7136\u770b\u4e66\u4e00\u904d\u4e0d\u8db3\u591f\uff0c\u5c31\u518d\u6765\u51e0\u904d\u3002\u6211\u6240\u4f1a\u7684\u53ea\u662f\u7a81\u51fb\u8003\u8bd5\u7f62\u4e86\u3002 \u6587\u521d\u4f5c\u4e8eQuestacon\uff08\u79d1\u6280\u9986\uff09G\u5c42Cafe\u5916\uff0c\u5f55\u5fc5\u601d\u65ad\uff0c\u65e0\u6cd5\u7eed\u5199\uff0c\u6b8b\u6587\u800c\u5df2\u3002","title":"ANU\u6691\u671f\u5b66\u6821-\u6211\u7684\u77db\u76fe"},{"location":"posts/2018-02-01-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E6%88%91%E7%9A%84%E7%9F%9B%E7%9B%BE/#anu-","text":"","title":"ANU\u6691\u671f\u5b66\u6821-\u6211\u7684\u77db\u76fe"},{"location":"posts/2018-02-01-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E6%88%91%E7%9A%84%E7%9F%9B%E7%9B%BE/#_1","text":"\u8bf4\u8d77\u82f1\u8bed\u5b66\u4e60\uff0c\u53ef\u771f\u662f\u4e00\u8a00\u96be\u5c3d\u3002\u5373\u4fbf\u662f\u62a5\u4e86\u8865\u4e60\u73ed\uff0c\u6bcf\u5929\u4e5f\u52aa\u529b\u5730\u5b66\u4e60\uff0c\u8fd8\u662f\u89c9\u5f97\u4e0d\u53ef\u80fd\u628a\u82f1\u8bed\u5b66\u597d\u3002\u8001\u5e08\u6559\u3001\u81ea\u5df1\u5b66\u3001\u82f1\u8bed\u73af\u5883\uff0c\u5982\u679c\u8bf4\u8fd9\u4e09\u70b9\u90fd\u6ee1\u8db3\u5c31\u80fd\u628a\u82f1\u8bed\u5b66\u597d\uff0c\u6015\u6211\u65e9\u5c31\u662f\u82f1\u8bed\u80fd\u624b\u4e86\u3002\u4e8b\u60c5\u5f80\u5f80\u4e0d\u662f\u90a3\u4e48\u7b80\u5355\uff0c\u66f4\u4f55\u51b5\uff0c\u4ece\u6765\u90fd\u6ca1\u6709\u6784\u5efa\u4e00\u4e2a\u82f1\u8bed\u73af\u5883\u3002\u8fd9\u6b21\u5230\u56fd\u5916\u6765\uff0c\u4e5f\u6709\u4e00\u4e9b\u5173\u4e8e\u6784\u5efa\u82f1\u8bed\u73af\u5883\u7684\u60f3\u6cd5\uff0c\u6bd4\u5982\uff0c\u7528\u82f1\u8bed\u601d\u8003\u3001\u5fc3\u91cc\u9ed8\u5ff5\u522b\u4eba\u8bf4\u7684\u8bdd\u3001\u67e5\u770b\u56fd\u5916\u52a8\u7269\u56ed\u7684\u7f51\u7ad9\u2026\u2026\u8fd9\u4e00\u6b21\u51fa\u884c\uff0c\u4e00\u822c\u7684\u4ea4\u6d41\u7528\u5230\u7684\u8bcd\u6c47\u51e0\u4e4e\u6ca1\u6709\u8d85\u8fc7\u81ea\u5df1\u7684\u6c34\u5e73\uff085000\u5de6\u53f3\uff09;\u4f46\u662f\u7a0d\u5fae\u6b63\u5f0f\u4e00\u70b9\u513f\u7684\u670d\u52a1\u4e0e\u6f14\u8bb2\u5c31\u8981\u6d89\u53ca\u66f4\u591a\u7684\u8bcd\u6c47\u4e86\uff0c\u6bd4\u5982\u70b9\u9910\u3001\u53f8\u673a\u5e08\u5085\u5728\u5f00\u8f66\u524d\u3001\u9014\u4e2d\u548c\u7ec8\u70b9\u524d\u7684\u6e29\u99a8\u63d0\u793a\u3002\u5982\u679c\u8981\u60f3\u542c\u61c2\u8fd9\u4e9b\uff0c\u786e\u5b9e\u8981\u8d39\u4e9b\u65f6\u65e5\u3002\u5982\u679c\u628a\u6211\u653e\u5728\u56fd\u5916\uff0c\u6211\u60f3\u6211\u56de\u627e\u4e00\u4e2a\u5916\u56fd\u4eba\u4f7f\u52b2\u513f\u5730\u95ee\uff0c\u8fd9\u4e2a\u4ec0\u4e48\u90a3\u662f\u4ec0\u4e48\uff0c\u6765\u5b66\u4e60\u751f\u8bcd\u548c\u53e5\u5b50\u3002\u6211\u8fd8\u4f1a\u5c3d\u53ef\u80fd\u7684\u9605\u8bfb\u82f1\u6587\u7684\u4ecb\u7ecd\u548c\u80cc\u666f\u77e5\u8bc6\u3002\u6211\u4f1a\u5c3d\u53ef\u80fd\u5730\u63a5\u89e6\u751f\u6d3b\u7684\u6bcf\u4e00\u65b9\u9762\uff0c\u5b66\u4e60\u8bcd\u6c47\u548c\u77ed\u8bed\u3002\u6211\u4f1a\u5c3d\u53ef\u80fd\u7684\u4e0e\u5916\u56fd\u4eba\u4ea4\u6d41\uff0c\u56de\u987e\u548c\u5c55\u671b\uff0c\u518d\u8fdb\u4e00\u6b65\u8ba8\u8bba\u6587\u5316\u3002\u603b\u7ed3\u8d77\u6765\uff0c\u65e0\u975e\u5c31\u662f\u6700\u5927\u9650\u5ea6\u7684\u878d\u5165\u4ed6\u4eec\u3002 \u8865\u5145\u4e00\u4e9b\u4e0eX\u541b\u7684\u4ea4\u6d41\u3002\u201c\u7528\u82f1\u8bed\u601d\u8003\u3001\u5927\u91cf\u7684\u57fa\u7840\u9605\u8bfb\uff08\u8bfe\u7a0b\uff09\u4ee5\u53ca\u5199\u4f5c\u662f\u8f83\u597d\u7684\u5b66\u4e60\u8bed\u8a00\u7684\u8981\u7d20\u201d\u3002 \u4ee5\u4e0a\u8fd9\u4e9b\u7edd\u5bf9\u662f\u8bf4\u7684\u8f7b\u677e\uff0c\u505a\u8d77\u6765\u96be\u3002\u65f6\u95f4\uff0c\u9700\u8981\u65f6\u95f4\u3002\u5982\u679c\u6bcf\u5929\u9700\u89813\u4e2a\u5c0f\u65f6\uff0c\u90a3\u5c31\u5f97\u534a\u5e74\u624d\u521d\u89c1\u7aef\u502a\u3002\u5f88\u663e\u7136\uff0c\u4e0d\u53ef\u80fd\u6bcf\u5929\u6709\u90a3\u4e48\u591a\u7684\u65f6\u95f4\u3002\u5982\u679c\uff0c\u73b0\u5728\u8ba9\u6211\u9009\u62e9\uff0c\u6211\u5927\u6982\u4f1a\u8fdb\u4e00\u6b65\u538b\u7f29\u793e\u4ea4\u4e0e\u751f\u6d3b\u7684\u65f6\u95f4\uff0c\u8ba9\u5de5\u4f5c\u7684\u6bcf\u4e00\u5929\u5c3d\u53ef\u80fd\u9ad8\u6548\u548c\u5145\u5b9e\u3002\u56e0\u4e3a\u6211\u6700\u8fd1\u660e\u767d\u8fc7\u6765\uff0c\u4e0d\u7eaf\u7cb9\u7684\u4f11\u606f\u603b\u662f\u4e00\u70b9\u610f\u4e49\u90fd\u6ca1\u6709\u7684\u3002\u4f60\u6839\u672c\u65e0\u6cd5\u5f97\u5230\u751f\u6d3b\u7684\u52a8\u529b\uff0c\u90a3\u79cd\u4f11\u606f\u7eaf\u7cb9\u662f\u8eab\u4f53\u4e0a\u4f11\u606f\uff0c\u4f46\u7cbe\u795e\u4e0a\u7684\u4e4f\u4e0d\u89e3\uff0c\u4e00\u6837\u6ca1\u6709\u7528\u3002\u5de5\u4f5c\u65f6\u6bb5\u8ba4\u771f\u5de5\u4f5c\u3001\u4eab\u53d7\u5de5\u4f5c\uff0c\u6512\u94b1\u5ea6\u5047\uff0c\u8d70\u8fdc\u4e00\u4e9b\uff0c\u65f6\u95f4\u957f\u4e00\u4e9b\uff08\u81f3\u5c11\u4e00\u5468\uff09\uff0c\u80fd\u5728\u6781\u5927\u653e\u677e\u7684\u540c\u65f6\u83b7\u5f97\u6781\u5927\u7684\u80fd\u91cf\uff0c\u53ef\u4ee5\u652f\u6491\u8f83\u957f\u65f6\u95f4\u7684\u503e\u60c5\u6295\u5165\u3002\u6b63\u5f0f\u6253\u7834\u4e86\u4e4b\u524d\u7684\u5e73\u8861\u4e00\u5207\u7684\u7406\u8bba\uff0c\u83b7\u53d6\u53ef\u4ee5\u51cf\u8f7b\u4e00\u4e9b\u75db\u82e6\u3002 \u7ee7\u7eed\u8bf4\u65f6\u95f4\u3002\u8fd9\u6837\u6211\u53ef\u4ee5\u505a\u4e00\u4e2a\u8f83\u957f\u65f6\u95f4\u7684\u8ba1\u5212\u3002\u4e00\u4e2a\u6708\u751a\u81f3\u51e0\u4e2a\u6708\uff0c\u5de5\u4f5c\u4e2d\u6709\u6210\u679c\u6709\u8fdb\u5c55\u3002\u6fb3\u5927\u5229\u4e9a\u662f\u4e2a\u65c5\u6e38\u7684\u597d\u5730\u65b9\uff08\u8fd9\u53e5\u8bdd\u662f\u4e2a\u4e07\u80fd\u7684\u53e5\u5b50\uff09\u3002\u8fd9\u91cc\u7684\u8282\u594f\u9002\u5408\u65c5\u6e38\u3002\u4e0d\u8981\u5f88\u5927\u7684\u56e2\uff0c\u51e0\u4e2a\u4eba\u4e00\u8d77\uff0c\u8981\u6709\u70ed\u60c5\u7684\u3001\u8981\u6709\u8bd7\u610f\u7684\u3001\u6709\u903b\u8f91\u7684\u3002\u5982\u679c\u8981\u505a\u4e00\u4e9b\u65c5\u6e38\u7684\u8ba1\u5212\uff0c\u5c31\u53ef\u4ee5\u6765\u6fb3\u6d32\u3002\u5de5\u4f5c\u7684\u73af\u5883\u4e5f\u5f88\u91cd\u8981\uff0c\u6700\u597d\u662f\u6709\u4e00\u4e2a\u6bd4\u8f83\u72ec\u7acb\u7684\u7a7a\u95f4\uff0c\u53ef\u4ee5\u662f\u5f00\u653e\u5f0f\u7684\uff0c\u4f46\u8981\u76f8\u5bf9\u4e0d\u88ab\u6253\u6270\u3002\u8fd9\u6837\u7684\u5de5\u4f5c\u6761\u4ef6\u53ef\u4ee5\u8ba9\u4eba\u4fdd\u6301\u826f\u597d\u7684\u5fc3\u60c5\u3001\u79ef\u6781\u7684\u6001\u5ea6\u3002\u5f53\u7136\u56e2\u961f\u4e5f\u5f88\u91cd\u8981\uff0c\u5c24\u5176\u662f\u4e00\u4e2a\u4eba\u7684\u79d1\u7814\u89c2\u5ff5\u521a\u521a\u5efa\u7acb\u7684\u65f6\u5019\u3002\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u662f\u65e0\u6cd5\u6d3b\u5f97\u8fd9\u6837\u7684\u5de5\u4f5c\u6761\u4ef6\u7684\uff0c\u6240\u4ee5\u53ea\u80fd\u968f\u7f18\u4e86\u3002\u5f53\u7136\u66f4\u5e0c\u671b\uff0c\u539f\u5219\u4e0a\u751f\u6d3b\u4e0e\u5de5\u4f5c\u5206\u5f00\u3002\u5de5\u4f5c\u7684\u65f6\u95f4\u53ef\u4ee5\u66f4\u957f\u4e00\u4e9b\uff0c\u7559\u597d\u9700\u8981\u5b66\u4e60\u7684\u65f6\u95f4\uff0c\u5c3d\u53ef\u80fd\u538b\u7f29\u5403\u996d\u7684\u65f6\u95f4\uff08\u5b58\u7591\uff0c\u5916\u56fd\u4eba\u5403\u996d\u65f6\u5019\u804a\u5929\u624d\u662f\u4e3b\u4e1a\uff09\u3002 \u5f53\u7136\uff0c\u6211\u4eec\u7684\u751f\u6d3b\u9700\u8981\u8c03\u5473\u5242\uff0c\u50cf\u4e00\u4e2a\u8bd7\u4eba\u4e00\u6837\u611f\u53d7\u5168\u4e16\u754c\u7684\u65f6\u5019\u96be\u514d\u5931\u53bb\u81ea\u6211\u3002\u800c\u611f\u53d7\u7684\u76ee\u7684\u6070\u6070\u662f\u4e3a\u4e86\u8868\u8fbe\u81ea\u6211\u3002\u8981\u5148\u5931\u53bb\uff08\u4e0a\u4e00\u6b21\u8868\u8fbe\uff09\uff0c\u5728\u9010\u6e10\u627e\u56de\u672c\u771f\u7684\u65f6\u5019\u628a\u4ed6\u4eec\u5199\u4e0b\u6765\uff0c\u53d1\u8868\u51fa\u53bb\u6216\u4f5c\u4e3a\u79c1\u5bb6\u65e5\u8bb0\uff0c\u518d\u4e00\u6b21\u628a\u81ea\u5df1\u653e\u7a7a\uff0c\u8ba9\u5185\u5fc3\u5145\u6ee1\u6e34\u671b\uff08\u5f53\u7136\u4e5f\u662f\u7a7a\u865a\uff09\uff0c\u4e00\u6b21\u6587\u7ae0\u4fbf\u662f\u4e00\u6b21\u8c03\u5242\u4e86\u3002\u8fd9\u662f\u4e00\u79cd\u7eda\u70c2\u7684\u8c03\u5242\uff0c\u4e00\u5207\u7684\u76ee\u7684\uff0c\u4e00\u5207\u7684\u5f52\u5bbf\u3002\u5728\u5de5\u4f5c\u4e2d\uff0c\u4f3c\u4e4e\u6709\u70b9\u68d8\u624b\u3002\u5de5\u4f5c\u4e2d\u7684\u8c03\u5242\u53c8\u662f\u4ec0\u4e48\u5462\uff1f\u8fd8\u6ca1\u6709\u7b54\u6848\uff0c\u662f\u751f\u6d3b\u4e48\uff1f\u5c31\u50cf\u4f53\u9a8c\u7684\u6700\u7ec8\u662f\u5199\u4e00\u7bc7\u6587\u7ae0\uff0c\u90a3\u5de5\u4f5c\u7684\u7ec8\u7ed3\u662f\u4ec0\u4e48\u5462\uff1f\u6362\u4e2a\u89d2\u5ea6\u601d\u8003\uff0c\u5199\u4e00\u7bc7\u6587\u7ae0\u662f\u6d88\u8017\uff0c\u662f\u4e3a\u4e86\u8ba9\u81ea\u5df1\u4fdd\u6301\u6e34\u671b\uff0c\u90a3\u5de5\u4f5c\u7684\u6d88\u8017\u53c8\u662f\u4ec0\u4e48\u5462\uff1f\u8ba9\u6211\u4eec\u5148\u653e\u4e00\u653e\u3002 \u603b\u4e4b\uff0c\u6211\u53c8\u62e5\u6709\u4e86\u4e00\u79cd\u65b0\u7684\u4f53\u609f\uff0c\u53ef\u4ee5\u8f83\u5c11\u75db\u82e6\u3002\u6295\u5165\u3001\u8c03\u5242\uff0c\u65e0\u6b62\u5883\u7684\u601d\u8003\u4e0e\u70ed\u60c5\u3002","title":"\u4e00"},{"location":"posts/2018-02-01-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E6%88%91%E7%9A%84%E7%9F%9B%E7%9B%BE/#_2","text":"\u8bf4\u8d77\u8bed\u8a00\u5b66\u4e60\uff0c\u4e0d\u5f97\u4e0d\u8bf4\u8d77\u6cd5\u8bed\u7684\u5b66\u4e60\u3002\u6cd5\u8bed\u7684\u5b66\u4e60\u6700\u7ec8\u8ba9\u6211\u5bfb\u5230\u4e86\u4e00\u79cd\u751f\u547d\u7684\u53ef\u80fd\u3002\u4e0d\u77e5\u9053\u8fc7\u53bb\u662f\u4e0d\u662f\u540c\u6837\u7684\u611f\u53d7\uff0c\u89c9\u5f97\u81ea\u5df1\u7684\u672a\u6765\u5df2\u7ecf\u627e\u5230\u3002\u6211\u8fd9\u6b21\u806a\u660e\u4e86\uff0c\u4e0d\u90a3\u4e48\u8bf4\u4e00\u5b9a\u3002\u6211\u60f3\u672a\u6765\u51e0\u5e74\u5e94\u8be5\u662f\u8fd9\u6837\u7684\uff0c\u800c\u4e14\u5bf9\u8fd9\u79cd\u751f\u6d3b\u7684\u53ef\u80fd\u6027\uff0c\u8ba9\u4eba\u7edd\u4e0d\u6000\u7591\u3002 \u8fd9\u79cd\u751f\u547d\u8ba9\u4eba\u6781\u5176\u4e30\u5bcc\u3002\u8fd9\u79cd\u751f\u547d\u8981\u6c42\u4f60\u6781\u5927\u7684\u878d\u5165\u751f\u6d3b\u3002\u4e3a\u4ec0\u4e48\u6211\u521a\u521a\u8ba4\u8bc6\u5230\u81ea\u5df1\u8981\u6781\u5927\u7684\u878d\u5165\u751f\u6d3b\uff1f\u9ad8\u4e2d\u6bd5\u4e1a\u7684\u65f6\u5019\u4fbf\u6709\u4e00\u4e9b\u840c\u82bd\uff0c\u4f46\u662f\u90a3\u65f6\u5019\u505a\u7684\u53ea\u662f\u5bf9\u5b66\u4e60\u7684\u53cd\u6297\uff0c\u4ee5\u4e3a\u4e0d\u5b66\u4e60\u5c31\u662f\u751f\u6d3b\u4e86\u3002\u5176\u5b9e\u4e0d\u662f\u3002\u800c\u65b0\u5b66\u4e60\u4e00\u95e8\u8bed\u8a00\u8ba9\u9ebb\u6728\u7684\u795e\u7ecf\u82cf\u9192\uff0c\u539f\u6765\uff0c\u6211\u4eec\u90a3\u4e48\u4e0d\u4e86\u89e3\u81ea\u5df1\u7684\u751f\u6d3b\u7684\u57ce\u5e02\uff08\u5f53\u7136\u8fd9\u4e5f\u6709C\u541b\u5bf9\u6211\u7684\u523a\u6fc0\uff09\uff0c\u5730\u6807\u3001\u6c11\u4fd7\u3001\u6587\u5316\u3001\u4ea4\u901a\u3001\u52a8\u7269\u56ed\u3001\u79d1\u6280\u9986\u3001\u996e\u98df\u3001\u5929\u6c14\u3001\u6cd5\u5f8b\u3001\u7535\u5f71\u9662\uff0c\u4e00\u5207\u4e00\u5207\u7684\u751f\u6d3b\u5c31\u5728\u751f\u6d3b\u4e4b\u4e2d\u3002\u91cd\u65b0\u5b66\u4e60\u4e00\u95e8\u8bed\u8a00\u5c31\u9700\u8981\u638c\u63e1\u8fd9\u4e9b\u8bcd\u6c47\uff0c\u5c31\u9700\u8981\u7528\u8033\u6735\u542c\uff0c\u7528\u773c\u775b\u770b\uff0c\u7528\u5fc3\u53bb\u611f\u53d7\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u5b66\u4e60\u65b0\u8bed\u8a00\u8ba9\u6211\u89e3\u5f00\u4e86\u4e00\u4e2a\u7591\u95ee\uff1a\u6211\u7a76\u7adf\u5fd8\u4e86\u4ec0\u4e48\uff1f\u6211\u5fd8\u4e86\u8981\u597d\u597d\u5730\u505a\u4f5c\u4e1a\u3001\u542c\u8bfe\u3001\u597d\u597d\u590d\u4e60\uff0c\u8981\u52aa\u529b\u8ddf\u4e0a\u8fdb\u5ea6\uff0c\u8981\u82b1\u8d39\u957f\u65f6\u95f4\u7684\u8fdb\u884c\u8bad\u7ec3\u548c\u62d3\u5c55\uff0c\u5f53\u7136\u770b\u4e66\u4e00\u904d\u4e0d\u8db3\u591f\uff0c\u5c31\u518d\u6765\u51e0\u904d\u3002\u6211\u6240\u4f1a\u7684\u53ea\u662f\u7a81\u51fb\u8003\u8bd5\u7f62\u4e86\u3002 \u6587\u521d\u4f5c\u4e8eQuestacon\uff08\u79d1\u6280\u9986\uff09G\u5c42Cafe\u5916\uff0c\u5f55\u5fc5\u601d\u65ad\uff0c\u65e0\u6cd5\u7eed\u5199\uff0c\u6b8b\u6587\u800c\u5df2\u3002","title":"\u4e8c"},{"location":"posts/2018-02-07-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E5%B0%BE%E5%A3%B0/","text":"ANU\u6691\u671f\u5b66\u6821-\u5c3e\u58f0 \u4e00 \u4eba\u5728\u4e00\u4e2a\u964c\u751f\u7684\u73af\u5883\uff0c\u4f1a\u4e0d\u7531\u81ea\u4e3b\u7684\u5c55\u73b0\u81ea\u5df1\u7684\u6f5c\u610f\u8bc6\uff0c\u8868\u73b0\u81ea\u5df1\u672c\u80fd\u7684\u6b32\u671b\u3002\u6bd4\u5982\u8bf4\uff0c\u4e00\u4e9b\u4eba\u81ea\u613f\u7684\u3001\u4e0d\u81ea\u613f\u7684\u5b66\u8fc7\u97f3\u4e50\uff0c\u56fd\u5185\u4ece\u672a\u9732\u8fc7\u4e00\u624b\uff0c\u5230\u8fd9\u90fd\u663e\u5f97\u65e0\u9650\u7737\u604b\u4e86\uff1b\u6bd4\u5982\u8bf4\uff0c\u4e00\u4e9b\u4eba\u613f\u610f\u73a9\u6e38\u620f\uff0c\u56fd\u5185\u6bcf\u65e5\u5fd9\u5f97\u5598\u4e0d\u8fc7\u6c14\u6765\uff0c\u5230\u8fd9\u6068\u4e0d\u5f97\u73a9\u513f\u5230\u5929\u4eae\uff1b\u6bd4\u5982\u8bf4\uff0c\u4e00\u4e9b\u4eba\u4eab\u53d7\u6e05\u5bc2\uff0c\u56fd\u5185\u88ab\u8feb\u7684\u4ecb\u5165\u5230\u590d\u6742\u7684\u5173\u7cfb\u4e2d\uff0c\u8fd9\u56de\u53ef\u4e0d\u7528\u7406\u90a3\u4e48\u591a\u4e86\u3002\u5f53\u7136\uff0c\u4e5f\u6709\u4e9b\u4eba\u4e00\u76f4\u5728\u5de5\u4f5c\uff0c\u8fd8\u6709\u4e9b\u4eba\u53ea\u4e0d\u8fc7\u662f\u6362\u4e86\u4e2a\u5730\u65b9\u901b\u8857\u3002 \u8fd9\u4eba\u7269\u7fa4\u50cf\uff0c\u603b\u4e0d\u662f\u90a3\u4e48\u597d\u63cf\u8ff0\u7684\uff1b\u5224\u65ad\u4e00\u4e2a\u4eba\u4e5f\u662f\u6781\u5176\u7684\u56f0\u96be\u3002\u4e3a\u4e86\u8ba9\u4e8b\u60c5\u53d8\u5f97\u7b80\u5355\uff0c\u6211\u4eec\u603b\u662f\u613f\u610f\u91c7\u7528\u7b80\u5355\u7684\u601d\u7ef4\uff0c\u6bd4\u5982\u4e8c\u5143\u5bf9\u7acb\u3002\u4e00\u4e2a\u4eba\u662f\u5065\u8c08\u8fd8\u662f\u5be1\u8a00\uff0c\u4e00\u4e2a\u4eba\u662f\u806a\u660e\u8fd8\u662f\u611a\u7b28\u3002\u4f46\u4e00\u4e2a\u4eba\u5f80\u5f80\u8981\u66f4\u590d\u6742\u3002\u8fd9\u5065\u8c08\u6216\u662f\u5be1\u8a00\uff0c\u8981\u518d\u52a0\u4e0a\u6761\u4ef6\uff0c\u6bd4\u5982\u201c\u4e0e\u964c\u751f\u4eba\u5728\u4e00\u8d77\u201d\uff0c\u624d\u66f4\u6709\u8c08\u8bba\u7684\u610f\u4e49\u3002\u6700\u540e\uff0c\u6211\u4eec\u53ef\u80fd\u4f1a\u5f97\u51fa\u7ed3\u8bba\uff0c\u8fd9\u4e2a\u4eba\u65e2\u662f\u5065\u8c08\u7684\u53c8\u662f\u5be1\u8a00\u7684\uff0c\u770b\u4f3c\u5341\u5206\u77db\u76fe\uff0c\u5b9e\u9645\u4e0a\u53c8\u662f\u5728\u4e0d\u540c\u7684\u6761\u4ef6\u4e0b\u6210\u7acb\u7684\u3002\u56e0\u4eba\u7684\u590d\u6742\u6027\u5bfc\u81f4\u4eba\u5f80\u5f80\u6ca1\u529e\u6cd5\u88ab\u6253\u4e00\u4e2a\u4fbf\u7b7e\u5c31\u53ef\u4ee5\u4ee3\u8868\u4ed6\u7684\u5168\u90e8\uff0c\u9047\u5230\u76f8\u4f3c\u7684\u60c5\u51b5\uff0c\u5c31\u8981\u591a\u601d\u8003\u4e00\u4e0b\uff0c\u5df2\u6709\u7684\u8bc4\u8bf4\u80cc\u540e\u7684\u771f\u5b9e\u610f\u56fe\u3002 \u4eba\u7684\u590d\u6742\u6027\u53c8\u5728\u4e8e\u4eba\u4eba\u4e0d\u540c\u3002\u5168\u4e16\u754c\u670970\u591a\u4ebf\u4eba\u53e3\uff0c\u6bcf\u4e00\u4e2a\u4e2a\u4f53\u90fd\u662f\u72ec\u4e00\u65e0\u4e8c\u7684\u3002\u629b\u5f00\u4eba\u79cd\u7684\u5dee\u5f02\u3001\u6027\u522b\u7684\u5dee\u5f02\uff0c\u4eba\u4eba\u4e0d\u540c\u7684\u539f\u56e0\u5728\u4e8e\u7ecf\u5386\u7684\u65e0\u9650\u6027\u548c\u601d\u8003\u7684\u65e0\u9650\u6027\uff1b\u533a\u57df\u5185\u6216\u8bb8\u4f1a\u9020\u6210\u7ecf\u5386\u7684\u540c\u8d28\uff0c\u4f46\u662f\u601d\u8003\u7edd\u4e0d\u53ef\u80fd\u662f\u4e00\u6837\u7684\u3002\u8981\u60f3\u628a\u81ea\u5df1\u4e0e\u522b\u4eba\u533a\u5206\u5f00\uff0c\u5c31\u8981\u60f3\u529e\u6cd5\u4ece\u81ea\u5df1\u7684\u7ecf\u5386\u548c\u601d\u8003\u5165\u624b\u3002\u4f46\u662f\uff0c\u6211\u4eec\u9762\u4e34\u7740\u4e00\u4e9b\u6781\u5927\u7684\u56f0\u5883\u3002\u793e\u4f1a\u5bf9\u4eba\u7684\u8981\u6c42\u6709\u5b83\u7684\u4f20\u7edf\uff0c\u6211\u4eec\u7684\u699c\u6837\u603b\u662f\u90a3\u6837\u7684\u3002\u4eba\u4eec\u603b\u662f\u4e0d\u81ea\u89c9\u7684\u88ab\u5b66\u4e60\u5404\u79cd\u80fd\u529b\uff0c\u751a\u81f3\u601d\u7ef4\u65b9\u5f0f\u548c\u601d\u8003\u5185\u5bb9\u3002\u6211\u4eec\u53ef\u4ee5\u7528\u70d9\u5370\u6765\u5f62\u5bb9\u8fd9\u79cd\u73b0\u8c61\u3002\u65f6\u4ee3\u7684\u70d9\u5370\u3001\u5b66\u6821\u7684\u70d9\u5370\u3001\u5bb6\u5ead\u7684\u70d9\u5370\u2026\u2026 \u4e8c \u4ee5\u4e0a\u79cd\u79cd\u590d\u6742\u6027\u5728\u4eba\u7fa4\u91cc\u90fd\u8868\u73b0\u5f97\u5341\u5206\u660e\u663e\u3002\u6700\u6d3b\u8dc3\u7684\u56e0\u7d20\u3001\u6700\u6709\u8da3\u7684\u90e8\u5206\u5c31\u662f\u8fd9\u4e9b\u5f62\u5f62\u8272\u8272\u7684\u4eba\u3002\u4f5c\u4e3a\u4e00\u4e2a\u89c2\u5bdf\u8005\uff0c\u9762\u5bf9\u8fd9\u4e9b\u590d\u6742\u6027\u65e2\u6b23\u559c\u53c8\u82e6\u607c\u3002\u6b23\u559c\u5728\u4e8e\u751f\u547d\u7684\u53ef\u80fd\u6027\u53c8\u88ab\u6269\u5c55\uff0c\u82e6\u607c\u5728\u4e8e\u96be\u4ee5\u628a\u63e1\u4eba\u6700\u6df1\u5c42\u7684\u9700\u6c42\u548c\u6e34\u671b\u3002 \u6700\u597d\u7684\u65b9\u5f0f\u4fbf\u662f\u81ea\u6211\u53cd\u601d\uff0c\u4efb\u4f55\u8bd5\u63a2\u6027\u7684\u8c08\u8bdd\u90fd\u65e0\u6cd5\u4ecb\u5165\u3002\u9762\u5bf9\u5916\u4eba\uff0c\u603b\u662f\u4f1a\u6709\u6240\u9690\u7792\u3002\u81ea\u6211\u53cd\u601d\u7684\u65f6\u5019\uff0c\u9700\u8981\u505a\u4e00\u4e9b\u5c0f\u5c0f\u7684\u7814\u7a76\uff0c\u66f4\u8981\u6781\u5ea6\u7684\u5411\u81ea\u5df1\u655e\u5f00\u81ea\u5df1\u3002\u5f53\u7136\uff0c\u4e5f\u4f1a\u5b58\u5728\u4e00\u4e9b\u7ec6\u5fae\u7684\u3001\u65e0\u6cd5\u4f53\u5bdf\u7684\u7279\u5f81\uff0c\u5c31\u53ea\u80fd\u7559\u7ed9\u672a\u6765\u4e86\u3002 \u4e09 \u56de\u5230\u719f\u6089\u7684\u73af\u5883\uff0c\u4f2a\u88c5\u4fbf\u56de\u6765\u4e86\u3002\u4f60\u53c8\u53d8\u6210\u4e86\u90a3\u4e2a\u522b\u4eba\u719f\u6089\u7684\u4f60\uff0c\u662fA\u7684\u5b69\u5b50\uff0c\u662fB\u7684\u540c\u5b66\uff0c\u662fC\u7684\u597d\u670b\u53cb\u3002\u6234\u7740\u4e0d\u540c\u7684\u9762\u5177\uff0c\u5728\u4e0d\u540c\u89d2\u8272\u4e4b\u95f4\u5207\u6362\uff0c\u8868\u73b0\u4f60\u4e00\u8d2f\u7684\u98ce\u91c7\u548c\u7ef0\u7ea6\u3002 \u771f\u7684\u81ea\u5df1\u5728\u54ea\u91cc\u5462\uff1f\u5728\u957f\u65f6\u95f4\u7684\u9762\u5177\u4e4b\u4e0b\u5462\uff1f\u8fd8\u662f\u5728\u77ed\u6682\u7684\u62bd\u79bb\u4e4b\u4e2d\u5462\uff1f \u65e0\u8bba\u5982\u4f55\uff0c\u90fd\u8981\u8fc7\u5f97\u5e78\u798f\u3002","title":"ANU\u6691\u671f\u5b66\u6821-\u5c3e\u58f0"},{"location":"posts/2018-02-07-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E5%B0%BE%E5%A3%B0/#anu-","text":"","title":"ANU\u6691\u671f\u5b66\u6821-\u5c3e\u58f0"},{"location":"posts/2018-02-07-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E5%B0%BE%E5%A3%B0/#_1","text":"\u4eba\u5728\u4e00\u4e2a\u964c\u751f\u7684\u73af\u5883\uff0c\u4f1a\u4e0d\u7531\u81ea\u4e3b\u7684\u5c55\u73b0\u81ea\u5df1\u7684\u6f5c\u610f\u8bc6\uff0c\u8868\u73b0\u81ea\u5df1\u672c\u80fd\u7684\u6b32\u671b\u3002\u6bd4\u5982\u8bf4\uff0c\u4e00\u4e9b\u4eba\u81ea\u613f\u7684\u3001\u4e0d\u81ea\u613f\u7684\u5b66\u8fc7\u97f3\u4e50\uff0c\u56fd\u5185\u4ece\u672a\u9732\u8fc7\u4e00\u624b\uff0c\u5230\u8fd9\u90fd\u663e\u5f97\u65e0\u9650\u7737\u604b\u4e86\uff1b\u6bd4\u5982\u8bf4\uff0c\u4e00\u4e9b\u4eba\u613f\u610f\u73a9\u6e38\u620f\uff0c\u56fd\u5185\u6bcf\u65e5\u5fd9\u5f97\u5598\u4e0d\u8fc7\u6c14\u6765\uff0c\u5230\u8fd9\u6068\u4e0d\u5f97\u73a9\u513f\u5230\u5929\u4eae\uff1b\u6bd4\u5982\u8bf4\uff0c\u4e00\u4e9b\u4eba\u4eab\u53d7\u6e05\u5bc2\uff0c\u56fd\u5185\u88ab\u8feb\u7684\u4ecb\u5165\u5230\u590d\u6742\u7684\u5173\u7cfb\u4e2d\uff0c\u8fd9\u56de\u53ef\u4e0d\u7528\u7406\u90a3\u4e48\u591a\u4e86\u3002\u5f53\u7136\uff0c\u4e5f\u6709\u4e9b\u4eba\u4e00\u76f4\u5728\u5de5\u4f5c\uff0c\u8fd8\u6709\u4e9b\u4eba\u53ea\u4e0d\u8fc7\u662f\u6362\u4e86\u4e2a\u5730\u65b9\u901b\u8857\u3002 \u8fd9\u4eba\u7269\u7fa4\u50cf\uff0c\u603b\u4e0d\u662f\u90a3\u4e48\u597d\u63cf\u8ff0\u7684\uff1b\u5224\u65ad\u4e00\u4e2a\u4eba\u4e5f\u662f\u6781\u5176\u7684\u56f0\u96be\u3002\u4e3a\u4e86\u8ba9\u4e8b\u60c5\u53d8\u5f97\u7b80\u5355\uff0c\u6211\u4eec\u603b\u662f\u613f\u610f\u91c7\u7528\u7b80\u5355\u7684\u601d\u7ef4\uff0c\u6bd4\u5982\u4e8c\u5143\u5bf9\u7acb\u3002\u4e00\u4e2a\u4eba\u662f\u5065\u8c08\u8fd8\u662f\u5be1\u8a00\uff0c\u4e00\u4e2a\u4eba\u662f\u806a\u660e\u8fd8\u662f\u611a\u7b28\u3002\u4f46\u4e00\u4e2a\u4eba\u5f80\u5f80\u8981\u66f4\u590d\u6742\u3002\u8fd9\u5065\u8c08\u6216\u662f\u5be1\u8a00\uff0c\u8981\u518d\u52a0\u4e0a\u6761\u4ef6\uff0c\u6bd4\u5982\u201c\u4e0e\u964c\u751f\u4eba\u5728\u4e00\u8d77\u201d\uff0c\u624d\u66f4\u6709\u8c08\u8bba\u7684\u610f\u4e49\u3002\u6700\u540e\uff0c\u6211\u4eec\u53ef\u80fd\u4f1a\u5f97\u51fa\u7ed3\u8bba\uff0c\u8fd9\u4e2a\u4eba\u65e2\u662f\u5065\u8c08\u7684\u53c8\u662f\u5be1\u8a00\u7684\uff0c\u770b\u4f3c\u5341\u5206\u77db\u76fe\uff0c\u5b9e\u9645\u4e0a\u53c8\u662f\u5728\u4e0d\u540c\u7684\u6761\u4ef6\u4e0b\u6210\u7acb\u7684\u3002\u56e0\u4eba\u7684\u590d\u6742\u6027\u5bfc\u81f4\u4eba\u5f80\u5f80\u6ca1\u529e\u6cd5\u88ab\u6253\u4e00\u4e2a\u4fbf\u7b7e\u5c31\u53ef\u4ee5\u4ee3\u8868\u4ed6\u7684\u5168\u90e8\uff0c\u9047\u5230\u76f8\u4f3c\u7684\u60c5\u51b5\uff0c\u5c31\u8981\u591a\u601d\u8003\u4e00\u4e0b\uff0c\u5df2\u6709\u7684\u8bc4\u8bf4\u80cc\u540e\u7684\u771f\u5b9e\u610f\u56fe\u3002 \u4eba\u7684\u590d\u6742\u6027\u53c8\u5728\u4e8e\u4eba\u4eba\u4e0d\u540c\u3002\u5168\u4e16\u754c\u670970\u591a\u4ebf\u4eba\u53e3\uff0c\u6bcf\u4e00\u4e2a\u4e2a\u4f53\u90fd\u662f\u72ec\u4e00\u65e0\u4e8c\u7684\u3002\u629b\u5f00\u4eba\u79cd\u7684\u5dee\u5f02\u3001\u6027\u522b\u7684\u5dee\u5f02\uff0c\u4eba\u4eba\u4e0d\u540c\u7684\u539f\u56e0\u5728\u4e8e\u7ecf\u5386\u7684\u65e0\u9650\u6027\u548c\u601d\u8003\u7684\u65e0\u9650\u6027\uff1b\u533a\u57df\u5185\u6216\u8bb8\u4f1a\u9020\u6210\u7ecf\u5386\u7684\u540c\u8d28\uff0c\u4f46\u662f\u601d\u8003\u7edd\u4e0d\u53ef\u80fd\u662f\u4e00\u6837\u7684\u3002\u8981\u60f3\u628a\u81ea\u5df1\u4e0e\u522b\u4eba\u533a\u5206\u5f00\uff0c\u5c31\u8981\u60f3\u529e\u6cd5\u4ece\u81ea\u5df1\u7684\u7ecf\u5386\u548c\u601d\u8003\u5165\u624b\u3002\u4f46\u662f\uff0c\u6211\u4eec\u9762\u4e34\u7740\u4e00\u4e9b\u6781\u5927\u7684\u56f0\u5883\u3002\u793e\u4f1a\u5bf9\u4eba\u7684\u8981\u6c42\u6709\u5b83\u7684\u4f20\u7edf\uff0c\u6211\u4eec\u7684\u699c\u6837\u603b\u662f\u90a3\u6837\u7684\u3002\u4eba\u4eec\u603b\u662f\u4e0d\u81ea\u89c9\u7684\u88ab\u5b66\u4e60\u5404\u79cd\u80fd\u529b\uff0c\u751a\u81f3\u601d\u7ef4\u65b9\u5f0f\u548c\u601d\u8003\u5185\u5bb9\u3002\u6211\u4eec\u53ef\u4ee5\u7528\u70d9\u5370\u6765\u5f62\u5bb9\u8fd9\u79cd\u73b0\u8c61\u3002\u65f6\u4ee3\u7684\u70d9\u5370\u3001\u5b66\u6821\u7684\u70d9\u5370\u3001\u5bb6\u5ead\u7684\u70d9\u5370\u2026\u2026","title":"\u4e00"},{"location":"posts/2018-02-07-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E5%B0%BE%E5%A3%B0/#_2","text":"\u4ee5\u4e0a\u79cd\u79cd\u590d\u6742\u6027\u5728\u4eba\u7fa4\u91cc\u90fd\u8868\u73b0\u5f97\u5341\u5206\u660e\u663e\u3002\u6700\u6d3b\u8dc3\u7684\u56e0\u7d20\u3001\u6700\u6709\u8da3\u7684\u90e8\u5206\u5c31\u662f\u8fd9\u4e9b\u5f62\u5f62\u8272\u8272\u7684\u4eba\u3002\u4f5c\u4e3a\u4e00\u4e2a\u89c2\u5bdf\u8005\uff0c\u9762\u5bf9\u8fd9\u4e9b\u590d\u6742\u6027\u65e2\u6b23\u559c\u53c8\u82e6\u607c\u3002\u6b23\u559c\u5728\u4e8e\u751f\u547d\u7684\u53ef\u80fd\u6027\u53c8\u88ab\u6269\u5c55\uff0c\u82e6\u607c\u5728\u4e8e\u96be\u4ee5\u628a\u63e1\u4eba\u6700\u6df1\u5c42\u7684\u9700\u6c42\u548c\u6e34\u671b\u3002 \u6700\u597d\u7684\u65b9\u5f0f\u4fbf\u662f\u81ea\u6211\u53cd\u601d\uff0c\u4efb\u4f55\u8bd5\u63a2\u6027\u7684\u8c08\u8bdd\u90fd\u65e0\u6cd5\u4ecb\u5165\u3002\u9762\u5bf9\u5916\u4eba\uff0c\u603b\u662f\u4f1a\u6709\u6240\u9690\u7792\u3002\u81ea\u6211\u53cd\u601d\u7684\u65f6\u5019\uff0c\u9700\u8981\u505a\u4e00\u4e9b\u5c0f\u5c0f\u7684\u7814\u7a76\uff0c\u66f4\u8981\u6781\u5ea6\u7684\u5411\u81ea\u5df1\u655e\u5f00\u81ea\u5df1\u3002\u5f53\u7136\uff0c\u4e5f\u4f1a\u5b58\u5728\u4e00\u4e9b\u7ec6\u5fae\u7684\u3001\u65e0\u6cd5\u4f53\u5bdf\u7684\u7279\u5f81\uff0c\u5c31\u53ea\u80fd\u7559\u7ed9\u672a\u6765\u4e86\u3002","title":"\u4e8c"},{"location":"posts/2018-02-07-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E5%B0%BE%E5%A3%B0/#_3","text":"\u56de\u5230\u719f\u6089\u7684\u73af\u5883\uff0c\u4f2a\u88c5\u4fbf\u56de\u6765\u4e86\u3002\u4f60\u53c8\u53d8\u6210\u4e86\u90a3\u4e2a\u522b\u4eba\u719f\u6089\u7684\u4f60\uff0c\u662fA\u7684\u5b69\u5b50\uff0c\u662fB\u7684\u540c\u5b66\uff0c\u662fC\u7684\u597d\u670b\u53cb\u3002\u6234\u7740\u4e0d\u540c\u7684\u9762\u5177\uff0c\u5728\u4e0d\u540c\u89d2\u8272\u4e4b\u95f4\u5207\u6362\uff0c\u8868\u73b0\u4f60\u4e00\u8d2f\u7684\u98ce\u91c7\u548c\u7ef0\u7ea6\u3002 \u771f\u7684\u81ea\u5df1\u5728\u54ea\u91cc\u5462\uff1f\u5728\u957f\u65f6\u95f4\u7684\u9762\u5177\u4e4b\u4e0b\u5462\uff1f\u8fd8\u662f\u5728\u77ed\u6682\u7684\u62bd\u79bb\u4e4b\u4e2d\u5462\uff1f \u65e0\u8bba\u5982\u4f55\uff0c\u90fd\u8981\u8fc7\u5f97\u5e78\u798f\u3002","title":"\u4e09"},{"location":"posts/2018-02-07-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E7%94%9F%E6%B4%BB%E5%92%8C%E5%B7%A5%E4%BD%9C/","text":"ANU\u6691\u671f\u5b66\u6821-\u751f\u6d3b\u548c\u5de5\u4f5c \u4e00 \u5728\u8fd9\u91cc\u6211\u6240\u5b9a\u4e49\u7684\u751f\u6d3b\u548c\u5de5\u4f5c\u90fd\u662f\u7eaf\u7cb9\u7684\u3002\u4e4b\u6240\u4ee5\u8981\u5b9a\u4e49\u8fd9\u4e24\u79cd\u751f\u5b58\u72b6\u6001\u662f\u56e0\u4e3a\u6211\u5e38\u5e38\u4f1a\u5728\u5e73\u8861\u4e2d\u9677\u5165\u4e00\u65b9\uff0c\u7d22\u6027\u5b9a\u4e49\u4e24\u79cd\u7eaf\u7cb9\u7684\u6982\u5ff5\uff0c\u4ee5\u4fbf\u533a\u5206\u3002 \u4e8c \u751f\u6d3b\u4fbf\u662f\u6ca1\u6709\u5de5\u4f5c\uff0c\u5de5\u4f5c\u4fbf\u662f\u6ca1\u6709\u751f\u6d3b\u3002 \u6211\u5f88\u5bb9\u6613\u5728\u751f\u6d3b\u4e2d\u8ff7\u5931\uff0c\u81ea\u4ee5\u4e3a\u4eba\u751f\u5c31\u662f\u751f\u6d3b\u7684\u6837\u5b50\uff0c\u662f\u7eaf\u7cb9\u7684\u611f\u53d7\u7684\u72b6\u6001\u3002\u5728\u8fd9\u79cd\u72b6\u6001\u91cc\uff0c\u4f60\u65e0\u9700\u89e3\u91ca\uff0c\u4f60\u5e26\u6765\u7684\u5c31\u662f\u4e00\u5207\u7f8e\u3002\u8fd9\u4e5f\u8574\u542b\u7740\u5931\u63a7\u7684\u98ce\u9669\uff0c\u5f88\u5bb9\u6613\u9020\u6210\u60c5\u611f\u548c\u7cbe\u795e\u5d29\u6e83\uff0c\u8868\u73b0\u4e3a\u60c5\u611f\u7684\u6063\u610f\u8868\u8fbe\u548c\u6b32\u671b\u7684\u65e0\u9650\u81a8\u80c0\u3002\u5f80\u5f80\u9700\u8981\u4e00\u6761\u6e20\u9053\u6765\u53d1\u6cc4\uff0c\u540c\u65f6\u8fd9\u6761\u6e20\u9053\u4e5f\u8d77\u5230\u4e86\u4f11\u6b62\u7b26\u7684\u4f5c\u7528\uff0c\u8ba9\u81ea\u5df1\u5728\u6b32\u671b\u4e0e\u73b0\u5b9e\u7684\u7d27\u5f20\u5173\u7cfb\u4e2d\u5f97\u5230\u653e\u677e\uff0c\u751a\u81f3\u89e3\u8131\u3002\u6211\u53d1\u73b0\u8fd9\u6761\u6e20\u9053\u5c31\u662f\u5199\u4f5c\u3002\u5199\u4f5c\u5f80\u5f80\u80fd\u4e00\u6b21\u6027\u5730\u5378\u7a7a\u6700\u8fd1\u4e00\u6bb5\u65f6\u95f4\u7684\u60c5\u7eea\uff0c\u8ba9\u4eba\u91cd\u65b0\u53d8\u6210\u4e00\u5757\u513f\u5e72\u71e5\u7684\u6d77\u7ef5\u3002\u5728\u5c1a\u672a\u5f00\u59cb\u6c72\u53d6\u6c34\u5206\u7684\u65f6\u5019\uff0c\u53ca\u65f6\u5730\u5207\u6362\u5230\u5de5\u4f5c\u72b6\u6001\u4e2d\u3002\u8fd9\u662f\u6781\u5176\u7406\u60f3\u7684\u72b6\u6001\uff0c\u56e0\u4e3a\u5728\u4e8b\u60c5\u7684\u5f00\u7aef\u505a\u51b3\u5b9a\uff0c\u603b\u662f\u4e0d\u4f1a\u53d7\u8bf8\u591a\u65e2\u5b9a\u56e0\u7d20\u7275\u7eca\u3002\u8fd9\u6837\u4e5f\u5c31\u514d\u4e8e\u8ff7\u5931\u5728\u751f\u6d3b\u4e4b\u4e2d\uff0c\u514d\u4e8e\u6df1\u9677\u75db\u82e6\u523b\u523b\u707c\u5fc3\u3002 \u5f53\u7136\uff0c\u6211\u4e5f\u5bb9\u6613\u8ff7\u5931\u5728\u5de5\u4f5c\u4e4b\u4e2d\uff0c\u81ea\u4ee5\u4e3a\u4eba\u751f\u8be5\u662f\u5de5\u4f5c\u7684\u6837\u5b50\u3002\u5de5\u4f5c\u65f6\u5019\uff0c\u662f\u7eaf\u7cb9\u7684\u81ea\u6211\u5b9e\u73b0\u7684\u72b6\u6001\u2014\u2014\u5728\u4e0d\u65ad\u7684\u6c72\u53d6\u77e5\u8bc6\u548c\u6280\u80fd\u3001\u8fbe\u6210\u76ee\u6807\u3001\u521b\u9020\u4ef7\u503c\u7684\u8fc7\u7a0b\u4e2d\u5b9e\u73b0\u81ea\u6211\u3002\u751f\u6d3b\u4f3c\u9759\u79cb\u4e4b\u6c34\uff0c\u5de5\u4f5c\u4f3c\u590f\u82b1\u7eda\u70c2\u3002\u5de5\u4f5c\u4e5f\u662f\u4e00\u79cd\u8fd0\u52a8\uff0c\u6bd4\u8f83\u8d77\u6765\u66f4\u50cf\u662f\u745c\u4f3d\u3002\u5de5\u4f5c\u5728\u67d0\u79cd\u5c42\u9762\u4e0a\u53c8\u8ba9\u4eba\u6210\u763e\uff0c\u4e0d\u7ba1\u662f\u5916\u90e8\u7763\u4fc3\uff0c\u8fd8\u662f\u5185\u751f\u7684\u8d23\u4efb\u611f\uff0c\u5de5\u4f5c\u8d77\u6765\u4fbf\u505c\u4e0d\u4f4f\u3002\u6240\u8c13\u8ff7\u5931\uff0c\u5c31\u662f\u65e5\u590d\u4e00\u65e5\u7684\u5de5\u4f5c\u65f6\u95f4\u5bf9\u751f\u6d3b\u65f6\u95f4\u7684\u4fb5\u5165\uff0c\u6700\u7ec8\u5219\u51e0\u8fd1\u5b8c\u5168\u5360\u636e\uff0c\u662f\u8ff7\u5931\u5728\u65f6\u95f4\u4e2d\u4e86\u3002\u53ef\u662f\uff0c\u53c8\u600e\u4e48\u89e3\u8131\u51fa\u6765\u5462\uff1f","title":"ANU\u6691\u671f\u5b66\u6821-\u751f\u6d3b\u548c\u5de5\u4f5c"},{"location":"posts/2018-02-07-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E7%94%9F%E6%B4%BB%E5%92%8C%E5%B7%A5%E4%BD%9C/#anu-","text":"","title":"ANU\u6691\u671f\u5b66\u6821-\u751f\u6d3b\u548c\u5de5\u4f5c"},{"location":"posts/2018-02-07-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E7%94%9F%E6%B4%BB%E5%92%8C%E5%B7%A5%E4%BD%9C/#_1","text":"\u5728\u8fd9\u91cc\u6211\u6240\u5b9a\u4e49\u7684\u751f\u6d3b\u548c\u5de5\u4f5c\u90fd\u662f\u7eaf\u7cb9\u7684\u3002\u4e4b\u6240\u4ee5\u8981\u5b9a\u4e49\u8fd9\u4e24\u79cd\u751f\u5b58\u72b6\u6001\u662f\u56e0\u4e3a\u6211\u5e38\u5e38\u4f1a\u5728\u5e73\u8861\u4e2d\u9677\u5165\u4e00\u65b9\uff0c\u7d22\u6027\u5b9a\u4e49\u4e24\u79cd\u7eaf\u7cb9\u7684\u6982\u5ff5\uff0c\u4ee5\u4fbf\u533a\u5206\u3002","title":"\u4e00"},{"location":"posts/2018-02-07-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E7%94%9F%E6%B4%BB%E5%92%8C%E5%B7%A5%E4%BD%9C/#_2","text":"\u751f\u6d3b\u4fbf\u662f\u6ca1\u6709\u5de5\u4f5c\uff0c\u5de5\u4f5c\u4fbf\u662f\u6ca1\u6709\u751f\u6d3b\u3002 \u6211\u5f88\u5bb9\u6613\u5728\u751f\u6d3b\u4e2d\u8ff7\u5931\uff0c\u81ea\u4ee5\u4e3a\u4eba\u751f\u5c31\u662f\u751f\u6d3b\u7684\u6837\u5b50\uff0c\u662f\u7eaf\u7cb9\u7684\u611f\u53d7\u7684\u72b6\u6001\u3002\u5728\u8fd9\u79cd\u72b6\u6001\u91cc\uff0c\u4f60\u65e0\u9700\u89e3\u91ca\uff0c\u4f60\u5e26\u6765\u7684\u5c31\u662f\u4e00\u5207\u7f8e\u3002\u8fd9\u4e5f\u8574\u542b\u7740\u5931\u63a7\u7684\u98ce\u9669\uff0c\u5f88\u5bb9\u6613\u9020\u6210\u60c5\u611f\u548c\u7cbe\u795e\u5d29\u6e83\uff0c\u8868\u73b0\u4e3a\u60c5\u611f\u7684\u6063\u610f\u8868\u8fbe\u548c\u6b32\u671b\u7684\u65e0\u9650\u81a8\u80c0\u3002\u5f80\u5f80\u9700\u8981\u4e00\u6761\u6e20\u9053\u6765\u53d1\u6cc4\uff0c\u540c\u65f6\u8fd9\u6761\u6e20\u9053\u4e5f\u8d77\u5230\u4e86\u4f11\u6b62\u7b26\u7684\u4f5c\u7528\uff0c\u8ba9\u81ea\u5df1\u5728\u6b32\u671b\u4e0e\u73b0\u5b9e\u7684\u7d27\u5f20\u5173\u7cfb\u4e2d\u5f97\u5230\u653e\u677e\uff0c\u751a\u81f3\u89e3\u8131\u3002\u6211\u53d1\u73b0\u8fd9\u6761\u6e20\u9053\u5c31\u662f\u5199\u4f5c\u3002\u5199\u4f5c\u5f80\u5f80\u80fd\u4e00\u6b21\u6027\u5730\u5378\u7a7a\u6700\u8fd1\u4e00\u6bb5\u65f6\u95f4\u7684\u60c5\u7eea\uff0c\u8ba9\u4eba\u91cd\u65b0\u53d8\u6210\u4e00\u5757\u513f\u5e72\u71e5\u7684\u6d77\u7ef5\u3002\u5728\u5c1a\u672a\u5f00\u59cb\u6c72\u53d6\u6c34\u5206\u7684\u65f6\u5019\uff0c\u53ca\u65f6\u5730\u5207\u6362\u5230\u5de5\u4f5c\u72b6\u6001\u4e2d\u3002\u8fd9\u662f\u6781\u5176\u7406\u60f3\u7684\u72b6\u6001\uff0c\u56e0\u4e3a\u5728\u4e8b\u60c5\u7684\u5f00\u7aef\u505a\u51b3\u5b9a\uff0c\u603b\u662f\u4e0d\u4f1a\u53d7\u8bf8\u591a\u65e2\u5b9a\u56e0\u7d20\u7275\u7eca\u3002\u8fd9\u6837\u4e5f\u5c31\u514d\u4e8e\u8ff7\u5931\u5728\u751f\u6d3b\u4e4b\u4e2d\uff0c\u514d\u4e8e\u6df1\u9677\u75db\u82e6\u523b\u523b\u707c\u5fc3\u3002 \u5f53\u7136\uff0c\u6211\u4e5f\u5bb9\u6613\u8ff7\u5931\u5728\u5de5\u4f5c\u4e4b\u4e2d\uff0c\u81ea\u4ee5\u4e3a\u4eba\u751f\u8be5\u662f\u5de5\u4f5c\u7684\u6837\u5b50\u3002\u5de5\u4f5c\u65f6\u5019\uff0c\u662f\u7eaf\u7cb9\u7684\u81ea\u6211\u5b9e\u73b0\u7684\u72b6\u6001\u2014\u2014\u5728\u4e0d\u65ad\u7684\u6c72\u53d6\u77e5\u8bc6\u548c\u6280\u80fd\u3001\u8fbe\u6210\u76ee\u6807\u3001\u521b\u9020\u4ef7\u503c\u7684\u8fc7\u7a0b\u4e2d\u5b9e\u73b0\u81ea\u6211\u3002\u751f\u6d3b\u4f3c\u9759\u79cb\u4e4b\u6c34\uff0c\u5de5\u4f5c\u4f3c\u590f\u82b1\u7eda\u70c2\u3002\u5de5\u4f5c\u4e5f\u662f\u4e00\u79cd\u8fd0\u52a8\uff0c\u6bd4\u8f83\u8d77\u6765\u66f4\u50cf\u662f\u745c\u4f3d\u3002\u5de5\u4f5c\u5728\u67d0\u79cd\u5c42\u9762\u4e0a\u53c8\u8ba9\u4eba\u6210\u763e\uff0c\u4e0d\u7ba1\u662f\u5916\u90e8\u7763\u4fc3\uff0c\u8fd8\u662f\u5185\u751f\u7684\u8d23\u4efb\u611f\uff0c\u5de5\u4f5c\u8d77\u6765\u4fbf\u505c\u4e0d\u4f4f\u3002\u6240\u8c13\u8ff7\u5931\uff0c\u5c31\u662f\u65e5\u590d\u4e00\u65e5\u7684\u5de5\u4f5c\u65f6\u95f4\u5bf9\u751f\u6d3b\u65f6\u95f4\u7684\u4fb5\u5165\uff0c\u6700\u7ec8\u5219\u51e0\u8fd1\u5b8c\u5168\u5360\u636e\uff0c\u662f\u8ff7\u5931\u5728\u65f6\u95f4\u4e2d\u4e86\u3002\u53ef\u662f\uff0c\u53c8\u600e\u4e48\u89e3\u8131\u51fa\u6765\u5462\uff1f","title":"\u4e8c"},{"location":"posts/2018-03-08-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%B8%80%E5%A4%A9/","text":"\u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u4e00\u5929 \u7b2c\u4e00\u5929 \u8fd9\u662f\u6211\u7b2c\u4e09\u6b21\u8d76\u8d74\u676d\u5dde\u3002\u7b2c\u4e00\u6b21\u662f2016\u5e74\u7684\u7aef\u5348\u201c\u51fa\u8d70\u201d\uff0c\u8fd9\u4e00\u6b21\u201c\u51fa\u8d70\u201d\u662f\u4e3a\u81ea\u5df1\u201c\u5fd9\u788c\u201c\u7684\u5927\u5b66\u751f\u6d3b\u7684\u7292\u8d4f\uff1b\u4ea6\u662f\u642c\u79bb\u826f\u4e61\u540e\u6323\u624e\u7684\u65e5\u5b50\u524d\u7684\u6700\u540e\u4e00\u6b21\u8fdc\u884c\uff08\u4e5f\u662f\u552f\u4e00\u4e00\u6b21\uff09\u3002\u7b2c\u4e8c\u6b21\u4fbf\u662f2017\u5e74\u7684\u6691\u5047\uff0c\u8fd9\u4e00\u6b21\u6211\u6218\u6218\u5162\u5162\u5730\u6765\u53c2\u52a0\u6d59\u6c5f\u5927\u5b66\u7684\u590f\u4ee4\u8425\uff0c\u751f\u6015\u8fd9\u6765\u4e4b\u4e0d\u6613\u7684\u673a\u4f1a\u6e9c\u8d70\u3002\u8fd9\u4e00\u6b21\uff0c2018\u5e743\u67083\u65e5\uff0c\u6211\u4eca\u665a\u4ece\u54c8\u5c14\u6ee8\u51fa\u53d1\uff0c\u53bb\u6d59\u6c5f\u5927\u5b66\u5b8c\u6210\u6211\u7684\u6bd5\u4e1a\u8bbe\u8ba1\u3002 \u51fa\u8d70\uff0c\u662f\u70d9\u5728\u6211\u8eab\u4e0a\u7684\u4e00\u751f\u7684\u6325\u4e4b\u4e0d\u53bb\u7684\u5370\u8bb0\u3002 \u54c8\u897f\u706b\u8f66\u7ad9\u6211\u5df2\u7ecf\u6765\u4e86\u8bb8\u591a\u6b21\u4e86\uff0c\u8fd9\u6b21\u8d76\u4e0a\u4e86\u7279\u6b8a\u7684\u54c8\u897f\u2014\u2014\u4ece\u672a\u4f53\u9a8c\u8fc7\u7684\u5165\u7ad9\u4e24\u68c0\uff0c\u4ee5\u53ca\u5bf9\u4e58\u5750\u5f00\u5f80\u5317\u4eac\u7684\u5217\u8f66\u7684\u4e58\u5ba2\u7684\u5dee\u522b\u5bf9\u5f85\u3002\u4e00\u5207\u5200\u5177\u3001\u706b\u6e90\u3001\u52a9\u71c3\u5242\u90fd\u8981\u4e3b\u52a8\u4ea4\u51fa\u6765\u3002\u5019\u8f66\u533a\u57df\u88ab\u56f4\u4e86\u8d77\u6765\uff0c\u6211\u4eec\u5728\u5916\u9762\u6392\u4e86\u4e24\u6761\u957f\u961f\uff0c\u53c8\u9047\u5230\u4e86\u518d\u4e00\u6b21\u7684\u91d1\u5c5e\u63a2\u6d4b\u548c\u968f\u673a\u5f00\u5305\u68c0\u67e5\u3002\u6211\u548cS\u541b\u987a\u5229\u7684\u901a\u8fc7\u4e86\u91d1\u5c5e\u63a2\u6d4b\uff0c\u6b63\u5c0f\u6b65\u8d76\u4e0a\u5df2\u8fdb\u7ad9\u7684\u4e58\u5ba2\uff0cY\u541b\u5374\u88ab\u53eb\u4f4f\uff0c\u5b89\u68c0\u4eba\u5458\u5f00\u59cb\u4e00\u70b9\u4e00\u70b9\u5730\u67e5\u770b\u5979\u7684\u65c5\u884c\u7bb1\u548c\u80cc\u5305\u4e86\u3002\u67e5\u51fa\u6765\u7684\u4e0d\u8fc7\u662f\u4fee\u7709\u5200\u4e4b\u7c7b\u7684\uff0c\u6211\u5e76\u4e0d\u8bb0\u5f97\u5f88\u6e05\u695a\u3002\u6211\u8bb0\u5f97\u6700\u6e05\u695a\u7684\u662f\u5979\u4e0e\u7537\u670b\u53cb\u95f4\u7684\u60dc\u522b\uff0c\u4e00\u53bb\u5343\u91cc\uff0c\u7adf\u6709\u4e9b\u6df1\u60c5\u4e0e\u51dd\u564e\u4e86\u3002\u8d70\u4e86\uff01 \u6211\u6709\u4e9b\u559c\u6b22\u54c8\u5c14\u6ee8\u8fd9\u4e2a\u57ce\u5e02\u4e86\u3002\u8fd9\u4e00\u6b21\uff0c\u6211\u5728\u8fd9\u5df2\u7ecf\u5f85\u4e8610\u5929\uff0c\u662f\u6700\u4e45\u7684\u4e00\u6b21\u3002\u4e0a\u4e16\u7eaa\u521d\u7684\u56fd\u9645\u5927\u90fd\u5e02\u4ecd\u7136\u5728\u8f7b\u76c8\u7684\u767d\u8863\u4e0b\u6563\u53d1\u7740\u5f02\u56fd\u98ce\u60c5\uff1b\u51b0\u57ce\u54c8\u5c14\u6ee8\uff0c\u4ecd\u7136\u5728\u7199\u7199\u6518\u6518\u7684\u4eba\u7fa4\u4e2d\u751f\u6d3b\u7740\u3002\u8fd9\u91cc\u7684\u5efa\u7b51\u7ba1\u4ed6\u662f\u4fdd\u7559\u7684\u8fd8\u662f\u91cd\u5efa\u7684\uff0c\u90fd\u786c\u751f\u751f\u7684\u628a\u54c8\u5c14\u6ee8\u8fd9\u5ea7\u57ce\u5e02\u7684\u5386\u53f2\u5ba3\u8bb2\u7740\uff0c\u5728\u4e2d\u592e\u5927\u8857\u7684\u671b\u4e0d\u5c3d\u7684\u5a5a\u7eb1\u62d6\u5c3e\u91cc\uff0c\u5fc3\u52a8\u548c\u60cb\u60dc\u5e76\u5b58\u3002 \u8d70\u4e86\uff01 \u706b\u8f66\u5df2\u7ecf\u5f00\u51fa\u54c8\u5c14\u6ee8\uff0c\u5165\u5173\u4fbf\u7531\u5510\u5c71\u6298\u5411\u5317\u4eac\u57ce\u3002\u8f66\u4e0a\u4eba\u4e0d\u662f\u6700\u591a\u7684\u60c5\u5f62\uff0c\u5eca\u9053\u4e0a\u6709\u4eba\u5750\u7740\u5c0f\u51f3\u7761\u89c9\u3001\u6709\u4eba\u65e0\u5ea7\u53c8\u6ca1\u51f3\u5b50\u4fbf\u7ad9\u7740\u3002\u5217\u8f66\u5458\u63a8\u7740\u7684\u98df\u54c1\u548c\u996e\u6c34\u8f66\u8fc7\u6765\u4e86\uff0c\u5927\u5bb6\u5c31\u90fd\u772f\u7740\u773c\u775b\u8d77\u6765\u8ba9\u3002\u6ca1\u6709\u4eba\u89c9\u5f97\u90a3\u5217\u8f66\u5458\u7684\u55d3\u95e8\u5927\uff0c\u4e5f\u6ca1\u6709\u4eba\u89c9\u5f97\u5217\u8f66\u4e0a\u7684\u8d27\u54c1\u8d35\uff0c\u4e5f\u6ca1\u6709\u4eba\u89c9\u5f97\u5728\u5217\u8f66\u4e0a\u7684\u8c08\u8bdd\u8981\u907f\u7740\u4eba\u3002\u706b\u8f66\u4e0a\uff0c\u4e0d\u8fc7\u662f\u4f60\u89c1\u4e86\u6211\uff0c\u6211\u89c1\u4e86\u4f60\uff0c\u6211\u8bf4\u4e86\u4ec0\u4e48\uff0c\u4f60\u53c8\u8bf4\u4e86\u4ec0\u4e48\uff0c\u4e0b\u4e86\u8f66\uff0c\u5c31\u90fd\u7559\u5728\u8f66\u53a2\u91cc\u968f\u5b83\u53bb\u4e86\u3002 S\u541b\u5728\u7761\u89c9\uff0c\u6211\u4e0eY\u541b\u804a\u5230\u540e\u534a\u591c\u4fbf\u90fd\u6df7\u6df7\u7761\u53bb\u3002\u8c08\u5230\u6700\u540e\uff0c\u58f0\u97f3\u4e5f\u542c\u4e0d\u89c1\u4e86\uff0c\u773c\u775b\u4e5f\u7741\u4e0d\u5f00\u4e86\uff0c\u5934\u8037\u62c9\u7740\u3002\u624b\u652f\u6491\u8d77\u81ea\u5df1\u4ee5\u4fbf\u627e\u5230\u4e00\u4e2a\u597d\u7684\u59ff\u52bf\u4f11\u606f\uff0c\u5373\u4fbf\u662f\u786c\u5ea7\uff0c\u4e5f\u8981\u627e\u4e00\u4e2a\u597d\u7684\u59ff\u52bf\u4f11\u606f\u3002Y\u541b\u6216\u8981\u8d74\u897f\u5317\u53bb\uff0c\u6709\u4e86\u7231\u4eba\u4fbf\u6709\u4e86\u4e00\u5207\u3002 \u4e4b\u524d\uff0c\u4e0e\u51e0\u4f4d\u670b\u53cb\u505a\u4e86\u6700\u540e\u7684\u9053\u522b\u3002\u4eba\u548c\u4eba\u4e4b\u95f4\u7684\u60c5\u611f\u53ea\u5269\u4e0b\u53ea\u8a00\u7247\u8bed\u7684\u65f6\u5019\uff0c\u4fbf\u8981\u7528\u773c\u795e\u4ea4\u6d41\uff0c\u4fbf\u8981\u7528\u80a2\u4f53\u4ea4\u6d41\u3002\u62e5\u62b1\u4f60\u7231\u7684\u4eba\uff0c\u76ee\u9001\u4f60\u5ba0\u7684\u4eba\uff0c\u4fbf\u6bd4\u4ec0\u4e48\u6d77\u8a93\u5c71\u76df\u66f4\u6709\u522b\u6837\u7684\u6ecb\u5473\u4e86\u3002\u6216\u8bb8\u518d\u89c1\uff0c\u6216\u8bb8\u518d\u4e5f\u4e0d\u89c1\uff0c\u8d70\u4e86\uff01 \u6668\u81f3\u5317\u4eac\u7ad9\uff0c\u6211\u4eec\u4e09\u4eba\u8f97\u8f6c\u5230\u5317\u4eac\u5357\uff0c\u5403\u4e86\u65e9\u996d\uff0c\u7ec8\u8e0f\u4e0a\u5f00\u5f80\u676d\u5dde\u7684\u706b\u8f66\u3002","title":"\u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u4e00\u5929"},{"location":"posts/2018-03-08-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%B8%80%E5%A4%A9/#100-","text":"","title":"\u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u4e00\u5929"},{"location":"posts/2018-03-08-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%B8%80%E5%A4%A9/#_1","text":"\u8fd9\u662f\u6211\u7b2c\u4e09\u6b21\u8d76\u8d74\u676d\u5dde\u3002\u7b2c\u4e00\u6b21\u662f2016\u5e74\u7684\u7aef\u5348\u201c\u51fa\u8d70\u201d\uff0c\u8fd9\u4e00\u6b21\u201c\u51fa\u8d70\u201d\u662f\u4e3a\u81ea\u5df1\u201c\u5fd9\u788c\u201c\u7684\u5927\u5b66\u751f\u6d3b\u7684\u7292\u8d4f\uff1b\u4ea6\u662f\u642c\u79bb\u826f\u4e61\u540e\u6323\u624e\u7684\u65e5\u5b50\u524d\u7684\u6700\u540e\u4e00\u6b21\u8fdc\u884c\uff08\u4e5f\u662f\u552f\u4e00\u4e00\u6b21\uff09\u3002\u7b2c\u4e8c\u6b21\u4fbf\u662f2017\u5e74\u7684\u6691\u5047\uff0c\u8fd9\u4e00\u6b21\u6211\u6218\u6218\u5162\u5162\u5730\u6765\u53c2\u52a0\u6d59\u6c5f\u5927\u5b66\u7684\u590f\u4ee4\u8425\uff0c\u751f\u6015\u8fd9\u6765\u4e4b\u4e0d\u6613\u7684\u673a\u4f1a\u6e9c\u8d70\u3002\u8fd9\u4e00\u6b21\uff0c2018\u5e743\u67083\u65e5\uff0c\u6211\u4eca\u665a\u4ece\u54c8\u5c14\u6ee8\u51fa\u53d1\uff0c\u53bb\u6d59\u6c5f\u5927\u5b66\u5b8c\u6210\u6211\u7684\u6bd5\u4e1a\u8bbe\u8ba1\u3002 \u51fa\u8d70\uff0c\u662f\u70d9\u5728\u6211\u8eab\u4e0a\u7684\u4e00\u751f\u7684\u6325\u4e4b\u4e0d\u53bb\u7684\u5370\u8bb0\u3002 \u54c8\u897f\u706b\u8f66\u7ad9\u6211\u5df2\u7ecf\u6765\u4e86\u8bb8\u591a\u6b21\u4e86\uff0c\u8fd9\u6b21\u8d76\u4e0a\u4e86\u7279\u6b8a\u7684\u54c8\u897f\u2014\u2014\u4ece\u672a\u4f53\u9a8c\u8fc7\u7684\u5165\u7ad9\u4e24\u68c0\uff0c\u4ee5\u53ca\u5bf9\u4e58\u5750\u5f00\u5f80\u5317\u4eac\u7684\u5217\u8f66\u7684\u4e58\u5ba2\u7684\u5dee\u522b\u5bf9\u5f85\u3002\u4e00\u5207\u5200\u5177\u3001\u706b\u6e90\u3001\u52a9\u71c3\u5242\u90fd\u8981\u4e3b\u52a8\u4ea4\u51fa\u6765\u3002\u5019\u8f66\u533a\u57df\u88ab\u56f4\u4e86\u8d77\u6765\uff0c\u6211\u4eec\u5728\u5916\u9762\u6392\u4e86\u4e24\u6761\u957f\u961f\uff0c\u53c8\u9047\u5230\u4e86\u518d\u4e00\u6b21\u7684\u91d1\u5c5e\u63a2\u6d4b\u548c\u968f\u673a\u5f00\u5305\u68c0\u67e5\u3002\u6211\u548cS\u541b\u987a\u5229\u7684\u901a\u8fc7\u4e86\u91d1\u5c5e\u63a2\u6d4b\uff0c\u6b63\u5c0f\u6b65\u8d76\u4e0a\u5df2\u8fdb\u7ad9\u7684\u4e58\u5ba2\uff0cY\u541b\u5374\u88ab\u53eb\u4f4f\uff0c\u5b89\u68c0\u4eba\u5458\u5f00\u59cb\u4e00\u70b9\u4e00\u70b9\u5730\u67e5\u770b\u5979\u7684\u65c5\u884c\u7bb1\u548c\u80cc\u5305\u4e86\u3002\u67e5\u51fa\u6765\u7684\u4e0d\u8fc7\u662f\u4fee\u7709\u5200\u4e4b\u7c7b\u7684\uff0c\u6211\u5e76\u4e0d\u8bb0\u5f97\u5f88\u6e05\u695a\u3002\u6211\u8bb0\u5f97\u6700\u6e05\u695a\u7684\u662f\u5979\u4e0e\u7537\u670b\u53cb\u95f4\u7684\u60dc\u522b\uff0c\u4e00\u53bb\u5343\u91cc\uff0c\u7adf\u6709\u4e9b\u6df1\u60c5\u4e0e\u51dd\u564e\u4e86\u3002\u8d70\u4e86\uff01 \u6211\u6709\u4e9b\u559c\u6b22\u54c8\u5c14\u6ee8\u8fd9\u4e2a\u57ce\u5e02\u4e86\u3002\u8fd9\u4e00\u6b21\uff0c\u6211\u5728\u8fd9\u5df2\u7ecf\u5f85\u4e8610\u5929\uff0c\u662f\u6700\u4e45\u7684\u4e00\u6b21\u3002\u4e0a\u4e16\u7eaa\u521d\u7684\u56fd\u9645\u5927\u90fd\u5e02\u4ecd\u7136\u5728\u8f7b\u76c8\u7684\u767d\u8863\u4e0b\u6563\u53d1\u7740\u5f02\u56fd\u98ce\u60c5\uff1b\u51b0\u57ce\u54c8\u5c14\u6ee8\uff0c\u4ecd\u7136\u5728\u7199\u7199\u6518\u6518\u7684\u4eba\u7fa4\u4e2d\u751f\u6d3b\u7740\u3002\u8fd9\u91cc\u7684\u5efa\u7b51\u7ba1\u4ed6\u662f\u4fdd\u7559\u7684\u8fd8\u662f\u91cd\u5efa\u7684\uff0c\u90fd\u786c\u751f\u751f\u7684\u628a\u54c8\u5c14\u6ee8\u8fd9\u5ea7\u57ce\u5e02\u7684\u5386\u53f2\u5ba3\u8bb2\u7740\uff0c\u5728\u4e2d\u592e\u5927\u8857\u7684\u671b\u4e0d\u5c3d\u7684\u5a5a\u7eb1\u62d6\u5c3e\u91cc\uff0c\u5fc3\u52a8\u548c\u60cb\u60dc\u5e76\u5b58\u3002 \u8d70\u4e86\uff01 \u706b\u8f66\u5df2\u7ecf\u5f00\u51fa\u54c8\u5c14\u6ee8\uff0c\u5165\u5173\u4fbf\u7531\u5510\u5c71\u6298\u5411\u5317\u4eac\u57ce\u3002\u8f66\u4e0a\u4eba\u4e0d\u662f\u6700\u591a\u7684\u60c5\u5f62\uff0c\u5eca\u9053\u4e0a\u6709\u4eba\u5750\u7740\u5c0f\u51f3\u7761\u89c9\u3001\u6709\u4eba\u65e0\u5ea7\u53c8\u6ca1\u51f3\u5b50\u4fbf\u7ad9\u7740\u3002\u5217\u8f66\u5458\u63a8\u7740\u7684\u98df\u54c1\u548c\u996e\u6c34\u8f66\u8fc7\u6765\u4e86\uff0c\u5927\u5bb6\u5c31\u90fd\u772f\u7740\u773c\u775b\u8d77\u6765\u8ba9\u3002\u6ca1\u6709\u4eba\u89c9\u5f97\u90a3\u5217\u8f66\u5458\u7684\u55d3\u95e8\u5927\uff0c\u4e5f\u6ca1\u6709\u4eba\u89c9\u5f97\u5217\u8f66\u4e0a\u7684\u8d27\u54c1\u8d35\uff0c\u4e5f\u6ca1\u6709\u4eba\u89c9\u5f97\u5728\u5217\u8f66\u4e0a\u7684\u8c08\u8bdd\u8981\u907f\u7740\u4eba\u3002\u706b\u8f66\u4e0a\uff0c\u4e0d\u8fc7\u662f\u4f60\u89c1\u4e86\u6211\uff0c\u6211\u89c1\u4e86\u4f60\uff0c\u6211\u8bf4\u4e86\u4ec0\u4e48\uff0c\u4f60\u53c8\u8bf4\u4e86\u4ec0\u4e48\uff0c\u4e0b\u4e86\u8f66\uff0c\u5c31\u90fd\u7559\u5728\u8f66\u53a2\u91cc\u968f\u5b83\u53bb\u4e86\u3002 S\u541b\u5728\u7761\u89c9\uff0c\u6211\u4e0eY\u541b\u804a\u5230\u540e\u534a\u591c\u4fbf\u90fd\u6df7\u6df7\u7761\u53bb\u3002\u8c08\u5230\u6700\u540e\uff0c\u58f0\u97f3\u4e5f\u542c\u4e0d\u89c1\u4e86\uff0c\u773c\u775b\u4e5f\u7741\u4e0d\u5f00\u4e86\uff0c\u5934\u8037\u62c9\u7740\u3002\u624b\u652f\u6491\u8d77\u81ea\u5df1\u4ee5\u4fbf\u627e\u5230\u4e00\u4e2a\u597d\u7684\u59ff\u52bf\u4f11\u606f\uff0c\u5373\u4fbf\u662f\u786c\u5ea7\uff0c\u4e5f\u8981\u627e\u4e00\u4e2a\u597d\u7684\u59ff\u52bf\u4f11\u606f\u3002Y\u541b\u6216\u8981\u8d74\u897f\u5317\u53bb\uff0c\u6709\u4e86\u7231\u4eba\u4fbf\u6709\u4e86\u4e00\u5207\u3002 \u4e4b\u524d\uff0c\u4e0e\u51e0\u4f4d\u670b\u53cb\u505a\u4e86\u6700\u540e\u7684\u9053\u522b\u3002\u4eba\u548c\u4eba\u4e4b\u95f4\u7684\u60c5\u611f\u53ea\u5269\u4e0b\u53ea\u8a00\u7247\u8bed\u7684\u65f6\u5019\uff0c\u4fbf\u8981\u7528\u773c\u795e\u4ea4\u6d41\uff0c\u4fbf\u8981\u7528\u80a2\u4f53\u4ea4\u6d41\u3002\u62e5\u62b1\u4f60\u7231\u7684\u4eba\uff0c\u76ee\u9001\u4f60\u5ba0\u7684\u4eba\uff0c\u4fbf\u6bd4\u4ec0\u4e48\u6d77\u8a93\u5c71\u76df\u66f4\u6709\u522b\u6837\u7684\u6ecb\u5473\u4e86\u3002\u6216\u8bb8\u518d\u89c1\uff0c\u6216\u8bb8\u518d\u4e5f\u4e0d\u89c1\uff0c\u8d70\u4e86\uff01 \u6668\u81f3\u5317\u4eac\u7ad9\uff0c\u6211\u4eec\u4e09\u4eba\u8f97\u8f6c\u5230\u5317\u4eac\u5357\uff0c\u5403\u4e86\u65e9\u996d\uff0c\u7ec8\u8e0f\u4e0a\u5f00\u5f80\u676d\u5dde\u7684\u706b\u8f66\u3002","title":"\u7b2c\u4e00\u5929"},{"location":"posts/2018-03-08-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%BA%8C%E5%A4%A9/","text":"\u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u4e8c\u5929 \u7b2c\u4e8c\u5929 \u4eca\u5929\u624d\u771f\u6b63\u7684\u53c8\u56de\u5230\u4e86\u676d\u5dde\uff0c\u4eca\u5929\u624d\u662f\u7b2c\u4e00\u5929\u54e9\uff01 \u4ece\u5317\u4eac\u5230\u676d\u5dde\u7684\u9ad8\u94c1\u4e5f\u4e0d\u8fc76\u4e2a\u534a\u5c0f\u65f6\u7f62\u4e86\u3002\u4e00\u8def\u4e0a\uff0c\u6d41\u6c34\u6c60\u5858\u8d8a\u6765\u8d8a\u591a\uff0c\u51b0\u96ea\u4e4b\u4e8b\u65e9\u5c31\u5df2\u7ecf\u4e0d\u89c1\u4e86\u3002\u4e00\u65e5\u8fc7\u4e24\u5b63\uff0c\u4e00\u8def\u7779\u4e24\u666f\u3002\u73b0\u4ee3\u4eba\u5f97\u76ca\u4e8e\u5feb\u901f\u4ea4\u901a\uff0c\u5df2\u7ecf\u6709\u4e86\u8bb8\u591a\u524d\u4eba\u6240\u6ca1\u6709\u7684\u4f53\u9a8c\u3002\u54ea\u5412\u65e5\u884c\u4e09\u5343\u91cc\uff0c\u8fc7\u53bb\u90a3\u53ea\u662f\u795e\u8bdd\u4e2d\u7684\u60f3\u8c61\uff0c\u73b0\u5728\u65e5\u884c\u4e09\u4e07\u91cc\u4e5f\u4e0d\u662f\u6ca1\u6709\u53ef\u80fd\u3002\u4eba\u4eec\u7684\u8db3\u8ff9\u53ef\u4ee5\u904d\u5e03\u5927\u6c5f\u5357\u5317\uff0c\u4eba\u4eec\u7684\u80f8\u895f\u4ea6\u53ef\u4ee5\u6781\u5ea6\u7684\u8212\u5c55\u3002\u770b\u8fc7\u4e86\u7956\u56fd\u7684\u5927\u597d\u6cb3\u5c71\uff0c\u624d\u77e5\u9053\u98ce\u666f\u8fd9\u8fb9\u66f4\u597d\uff1b\u4e2d\u56fd\u6c38\u8fdc\u9002\u5408\u4e2d\u56fd\u4eba\u751f\u5b58\u3002 Y\u541b\u548cS\u541b\u7761\u5f97\u6c89\uff0c\u6211\u4e5f\u6709\u4e9b\u778c\u7761\u4e86\u3002\u8def\u8fc7\u6cf0\u5b89\uff0c\u4e0b\u8d77\u4e86\u5c0f\u96e8\u3002\u6709\u8da3\u7684\u662f\uff0c\u75be\u9a70\u7684\u5217\u8f66\u4f3c\u4e4e\u4e0e\u9f99\u738b\u505a\u4e86\u534f\u8bae\uff0c\u8981\u8001\u9f99\u738b\u4e13\u95e8\u6d17\u5237\u81ea\u5df1\u4e00\u4fa7\u7684\u7a97\u6237\u5462\uff0c\u53e6\u4e00\u4fa7\u5219\u5e72\u5e72\u7684\uff0c\u4e00\u5c18\u4e0d\u67d3\u7684\u3002 \u957f\u6c5f\u3002 \u592a\u6e56\u3002 \u676d\u5dde\u3002\u4e0b\u8f66\uff0c\u6b63\u8d76\u4e0a3\u6708\u6c14\u6e29\u56de\u6696\uff0c\u4eca\u5929\u53ef\u771f\u662f\u6625\u98ce\u548c\u7166\u4e86\u3002\u8fd9\u91cc\u6ca1\u6709\u7e41\u590d\u7684\u5b89\u68c0\uff0c\u4ece\u7ad9\u53f0\u51fa\u53bb\u4fbf\u76f4\u63a5\u53ef\u4ee5\u9009\u62e9\u516c\u5171\u4ea4\u901a\u6216\u8005\u6253\u7684\u3002Y\u541b\u7684\u670b\u53cb\u6765\u63a5\uff0c\u5174\u81f4\u52c3\u52c3\u7684\u8d70\u4e86\uff0cS\u541b\u8fd8\u8981\u8d76\u5230\u53e6\u4e00\u4e2a\u7ad9\u53f0\u4e0a\u8f66\u3002\u4e92\u76f8\u544a\u522b\u4e4b\u540e\uff0c\u6211\u81ea\u5df1\u4e5f\u5728\u676d\u5dde\u4e1c\u7ad9\u897f\u5e7f\u573a\u4e5828\u8def\u8f66\u8d70\u4e86\u3002 \u70ed\u7684\u51fa\u6c57\uff01 \u5230\u4e00\u4e2a\u4e2d\u5b66\u4e0b\u8f66\uff0c\u6cbf\u7740\u6d59\u5927\u8def\u5411\u897f\u884c\uff0c\u4fbf\u5230\u6d59\u5927\u7389\u6cc9\u6821\u533a\u3002\u6211\u5feb\u6b65\u4ece\u4e1c\u95e8\u8fdb\u5165\uff0c\u6298\u5411\u5357\uff0c\u53d6\u4e86\u5bbf\u820d\u7533\u8bf7\u6761\u540e\uff0c\u5411\u7740\u8001\u548c\u5c71\u8d70\u53bb\u3002\u90a3\u8fb9\u6211\u8fd8\u4e0d\u662f\u5f88\u719f\u6089\uff0c\u591c\u5e55\u5df2\u964d\uff0c\u5f88\u96be\u8fa8\u8ba4\u697c\u7684\u989c\u8272\u548c\u5916\u89c2\uff0c\u697c\u53f7\u4e5f\u662f\u5f88\u96be\u5bfb\u627e\u3002\u8d70\u8d70\u505c\u505c\uff0c\u5bfb\u5bfb\u89c5\u89c5\uff0c\u7ec8\u4e8e\u5b89\u987f\u4e86\u4e0b\u6765\u3002\u6211\u4f4f\u5728\u6821\u56ed\u7684\u897f\u5317\uff0c\u9876\u697c\uff0c\u6700\u8fb9\u4e0a\u7684\u4e00\u4e2a\u623f\u95f4\u3002\u6536\u62fe\u4e86\u8bb8\u4e45\uff0c\u7ec8\u4e8e\u5230\u4e86\u4f11\u606f\u7684\u65f6\u5019\uff0c\u6574\u4e2a\u4eba\u5f00\u59cb\u653e\u677e\uff0c\u56f0\u610f\u5341\u8db3\u3002\u53bb\u8981\u4e86\u4e00\u5e8a\u65e7\u88ab\u5b50\uff0c\u94fa\u4e0a\uff0c\u4fbf\u660f\u660f\u7761\u53bb\u3002","title":"\u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u4e8c\u5929"},{"location":"posts/2018-03-08-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%BA%8C%E5%A4%A9/#100-","text":"","title":"\u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u4e8c\u5929"},{"location":"posts/2018-03-08-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%BA%8C%E5%A4%A9/#_1","text":"\u4eca\u5929\u624d\u771f\u6b63\u7684\u53c8\u56de\u5230\u4e86\u676d\u5dde\uff0c\u4eca\u5929\u624d\u662f\u7b2c\u4e00\u5929\u54e9\uff01 \u4ece\u5317\u4eac\u5230\u676d\u5dde\u7684\u9ad8\u94c1\u4e5f\u4e0d\u8fc76\u4e2a\u534a\u5c0f\u65f6\u7f62\u4e86\u3002\u4e00\u8def\u4e0a\uff0c\u6d41\u6c34\u6c60\u5858\u8d8a\u6765\u8d8a\u591a\uff0c\u51b0\u96ea\u4e4b\u4e8b\u65e9\u5c31\u5df2\u7ecf\u4e0d\u89c1\u4e86\u3002\u4e00\u65e5\u8fc7\u4e24\u5b63\uff0c\u4e00\u8def\u7779\u4e24\u666f\u3002\u73b0\u4ee3\u4eba\u5f97\u76ca\u4e8e\u5feb\u901f\u4ea4\u901a\uff0c\u5df2\u7ecf\u6709\u4e86\u8bb8\u591a\u524d\u4eba\u6240\u6ca1\u6709\u7684\u4f53\u9a8c\u3002\u54ea\u5412\u65e5\u884c\u4e09\u5343\u91cc\uff0c\u8fc7\u53bb\u90a3\u53ea\u662f\u795e\u8bdd\u4e2d\u7684\u60f3\u8c61\uff0c\u73b0\u5728\u65e5\u884c\u4e09\u4e07\u91cc\u4e5f\u4e0d\u662f\u6ca1\u6709\u53ef\u80fd\u3002\u4eba\u4eec\u7684\u8db3\u8ff9\u53ef\u4ee5\u904d\u5e03\u5927\u6c5f\u5357\u5317\uff0c\u4eba\u4eec\u7684\u80f8\u895f\u4ea6\u53ef\u4ee5\u6781\u5ea6\u7684\u8212\u5c55\u3002\u770b\u8fc7\u4e86\u7956\u56fd\u7684\u5927\u597d\u6cb3\u5c71\uff0c\u624d\u77e5\u9053\u98ce\u666f\u8fd9\u8fb9\u66f4\u597d\uff1b\u4e2d\u56fd\u6c38\u8fdc\u9002\u5408\u4e2d\u56fd\u4eba\u751f\u5b58\u3002 Y\u541b\u548cS\u541b\u7761\u5f97\u6c89\uff0c\u6211\u4e5f\u6709\u4e9b\u778c\u7761\u4e86\u3002\u8def\u8fc7\u6cf0\u5b89\uff0c\u4e0b\u8d77\u4e86\u5c0f\u96e8\u3002\u6709\u8da3\u7684\u662f\uff0c\u75be\u9a70\u7684\u5217\u8f66\u4f3c\u4e4e\u4e0e\u9f99\u738b\u505a\u4e86\u534f\u8bae\uff0c\u8981\u8001\u9f99\u738b\u4e13\u95e8\u6d17\u5237\u81ea\u5df1\u4e00\u4fa7\u7684\u7a97\u6237\u5462\uff0c\u53e6\u4e00\u4fa7\u5219\u5e72\u5e72\u7684\uff0c\u4e00\u5c18\u4e0d\u67d3\u7684\u3002 \u957f\u6c5f\u3002 \u592a\u6e56\u3002 \u676d\u5dde\u3002\u4e0b\u8f66\uff0c\u6b63\u8d76\u4e0a3\u6708\u6c14\u6e29\u56de\u6696\uff0c\u4eca\u5929\u53ef\u771f\u662f\u6625\u98ce\u548c\u7166\u4e86\u3002\u8fd9\u91cc\u6ca1\u6709\u7e41\u590d\u7684\u5b89\u68c0\uff0c\u4ece\u7ad9\u53f0\u51fa\u53bb\u4fbf\u76f4\u63a5\u53ef\u4ee5\u9009\u62e9\u516c\u5171\u4ea4\u901a\u6216\u8005\u6253\u7684\u3002Y\u541b\u7684\u670b\u53cb\u6765\u63a5\uff0c\u5174\u81f4\u52c3\u52c3\u7684\u8d70\u4e86\uff0cS\u541b\u8fd8\u8981\u8d76\u5230\u53e6\u4e00\u4e2a\u7ad9\u53f0\u4e0a\u8f66\u3002\u4e92\u76f8\u544a\u522b\u4e4b\u540e\uff0c\u6211\u81ea\u5df1\u4e5f\u5728\u676d\u5dde\u4e1c\u7ad9\u897f\u5e7f\u573a\u4e5828\u8def\u8f66\u8d70\u4e86\u3002 \u70ed\u7684\u51fa\u6c57\uff01 \u5230\u4e00\u4e2a\u4e2d\u5b66\u4e0b\u8f66\uff0c\u6cbf\u7740\u6d59\u5927\u8def\u5411\u897f\u884c\uff0c\u4fbf\u5230\u6d59\u5927\u7389\u6cc9\u6821\u533a\u3002\u6211\u5feb\u6b65\u4ece\u4e1c\u95e8\u8fdb\u5165\uff0c\u6298\u5411\u5357\uff0c\u53d6\u4e86\u5bbf\u820d\u7533\u8bf7\u6761\u540e\uff0c\u5411\u7740\u8001\u548c\u5c71\u8d70\u53bb\u3002\u90a3\u8fb9\u6211\u8fd8\u4e0d\u662f\u5f88\u719f\u6089\uff0c\u591c\u5e55\u5df2\u964d\uff0c\u5f88\u96be\u8fa8\u8ba4\u697c\u7684\u989c\u8272\u548c\u5916\u89c2\uff0c\u697c\u53f7\u4e5f\u662f\u5f88\u96be\u5bfb\u627e\u3002\u8d70\u8d70\u505c\u505c\uff0c\u5bfb\u5bfb\u89c5\u89c5\uff0c\u7ec8\u4e8e\u5b89\u987f\u4e86\u4e0b\u6765\u3002\u6211\u4f4f\u5728\u6821\u56ed\u7684\u897f\u5317\uff0c\u9876\u697c\uff0c\u6700\u8fb9\u4e0a\u7684\u4e00\u4e2a\u623f\u95f4\u3002\u6536\u62fe\u4e86\u8bb8\u4e45\uff0c\u7ec8\u4e8e\u5230\u4e86\u4f11\u606f\u7684\u65f6\u5019\uff0c\u6574\u4e2a\u4eba\u5f00\u59cb\u653e\u677e\uff0c\u56f0\u610f\u5341\u8db3\u3002\u53bb\u8981\u4e86\u4e00\u5e8a\u65e7\u88ab\u5b50\uff0c\u94fa\u4e0a\uff0c\u4fbf\u660f\u660f\u7761\u53bb\u3002","title":"\u7b2c\u4e8c\u5929"},{"location":"posts/2018-03-10-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%B8%89%E5%A4%A9/","text":"\u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u4e09\u5929 \u7b2c\u4e09\u5929-\u5468\u4e00 \u8bf4\u5b9e\u8bdd\uff0c\u5199\u4e0b\u8fd9\u6bb5\u6587\u5b57\u7684\u65f6\u5019\u5df2\u8fdc\u8fdc\u5728\u7b2c\u4e09\u5929\u4e4b\u540e\u3002\u90a3\u4eca\u5929\u5c31\u6765\u4e2a\u4e86\u65ad\uff0c\u7701\u5f97\u4e00\u4e9b\u4e8b\u60c5\u5fd8\u4e86\uff0c\u8981\u4e48\u7a7a\u6b22\u559c\u4e00\u573a\uff0c\u8981\u4e48\u7a7a\u60b2\u4f24\u4e00\u573a\u3002 \u4e00\u7741\u773c\u5df2\u7ecf\u63a5\u8fd1\u516b\u70b9\uff0c\u53c8\u987f\u89c9\u51c9\u610f\u88ad\u6765\u3002\u8fd9\u5929\u6c14\u7684\u53d8\u6362\u7adf\u5982\u540c\u5c0f\u5b69\u513f\u7684\u813e\u6c14\u4e00\u822c\u96be\u4ee5\u7422\u78e8\u3002\u987e\u4e0d\u4e86\u90a3\u4e48\u591a\uff0c\u6211\u8d76\u7d27\u8d77\u6765\uff0c\u51c6\u5907\u6d17\u6f31\u3002 \u53bb\u5e74\u529e\u7684\u5b66\u751f\u5361\uff08\u84dd\u5361\uff0c\u53ef\u4ee5\u5728\u9650\u5b9a\u7684\u98df\u5802\u5403\u996d\uff0c\u53ef\u4ee5\u5237\u95e8\u7981\uff09\u4eca\u5929\u53ef\u4ee5\u6d3e\u4e0a\u7528\u573a\u4e86\uff0c\u8fd9\u5b66\u751f\u5361\u4e5f\u662f\u53ef\u4ee5\u5237\u70ed\u6c34\u7684\uff08\u6628\u665a\u6210\u529f\u8bd5\u8fc7\uff09\u3002\u6211\u6025\u5306\u5306\u5730\u8dd1\u53bb\u6d17\u6f31\u95f4\uff0c\u51c6\u5907\u6253\u4e9b\u70ed\u6c34\uff0c\u6bcf\u6210\u60f3\uff0c\u8fd9\u70ed\u6c34\u9f99\u5934\u53ea\u662f\u56a3\u53eb\uff0c\u6ca1\u6709\u4e00\u70b9\u653e\u51fa\u4e00\u70b9\u6c34\u6765\u7684\u610f\u601d\uff0c\u597d\u5389\u5bb3\u7684\u9b54\u738b\uff01\u6211\u53c8\u56de\u5230\u5bbf\u820d\u95ee\u5ba4\u53cb\uff08\u8001\u751f\uff09\uff0c\u4ed6\u544a\u8bc9\u6211\u65e9\u4e0a\u662f\u6ca1\u6709\u70ed\u6c34\u7684\uff0c\u9700\u8981\u5934\u4e00\u5929\u665a\u4e0a\u7528\u6696\u74f6\u63a5\u597d\u3002\u6211\u6014\u4f4f\uff0c\u60f3\u4e86\u60f3\uff0c\u56de\u4e86\u6d17\u6f31\u95f4\uff0c\u6df1\u5438\u4e86\u4e00\u53e3\u6c14\uff0c\u4fbf\u63a5\u8d77\u51c9\u6c34\u6765\u3002 \u6211\u5feb\u6b65\u8d70\u5230\u5b9e\u9a8c\u5ba4\uff0c\u89c1\u4e86S\u8001\u5e08\uff0c\u5f00\u59cb\u4e86\u4e00\u5929\u7684\u5de5\u4f5c\u3002\u5de5\u4f5c\u5185\u5bb9\u4e0d\u63d0\u3002\u4eca\u5929\u7a81\u7136\u901a\u77e5\u8981\u4ea4\u5f00\u9898\u62a5\u544a\u548c\u6587\u732e\u7ffb\u8bd1\uff0c\u771f\u662f\u706b\u4e0a\u6d47\u6cb9\uff01 \u665a\u4e0a\uff0c\u6211\u65e9\u65e9\u5c31\u56de\u4e86\u5bbf\u820d\u3002\u5916\u9762\u53c8\u4e0b\u8d77\u96e8\u6765\uff0c\u5929\u6c14\u8d8a\u6765\u8d8a\u51c9\u4e86\u3002\u8981\u518d\u4e70\u4e00\u5e8a\u88ab\u5b50\uff01\u8981\u518d\u4e70\u4e00\u53cc\u68c9\u62d6\u978b\uff01 \u7b2c\u56db\u5929-\u5468\u4e8c \u4e0a\u5348\u5f00\u4f1a\u3002 \u4e0b\u5348\u5f00\u59cb\u5199\u6587\u732e\u7ffb\u8bd1\u548c\u5f00\u9898\u62a5\u544a\u3002google\u7ffb\u8bd1\u5728\u524d\u4e00\u6bb5\u65f6\u95f4\u6709\u4e86\u8f83\u5927\u7684\u7a81\u7834\uff0c\u5176\u5bf9\u6574\u53e5\u7684\u7406\u89e3\u80fd\u529b\u5927\u5927\u52a0\u5f3a1\u3002\u8fd9\u662f\u4e00\u4e2a\u975e\u5e38\u597d\u7684\u6d88\u606f\uff0c\u6211\u7684\u6587\u732e\u7ffb\u8bd1\u5f88\u5feb\u5c31\u501f\u52a9\u5b83\u5b8c\u6210\u4e86\u3002\u82e5\u662f\u80fd\u6839\u636e\u4e0d\u540c\u671f\u520a\u3001\u4f1a\u8bae\u7684\u8bba\u6587\u683c\u5f0f\u505a\u4e00\u4e2a\u81ea\u52a8\u89e3\u6790\uff0c\u90a3\u5c31\u518d\u597d\u4e0d\u8fc7\u4e86\u3002\u8fd9\u5f00\u9898\u62a5\u544a\u53ef\u96be\u4f4f\u4e86\u6211\uff0c\u6211\u6700\u7ec8\u91c7\u53d6\u4e86\u4e00\u7bc7tutorial2\u7684\u5efa\u8bae\uff0c\u5199\u4e86\u5927\u69823000\u5b57\u3002\u4e00\u76f4\u5199\u5230\u540e\u534a\u591c1\u70b9\u3002\u771f\u662f\u50cf\u6324\u7259\u818f\u3002\u4e00\u822c\u5199\u4f5c\uff0c\u8981\u60f3\u51993000\u5b57\uff0c\u82e5\u662f\u6ca1\u6709\u51e0\u4e07\u5b57\u7684\u77e5\u8bc6\u91cf\u6015\u662f\u4ec0\u4e48\u4e5f\u5199\u4e0d\u51fa\u6765\u7684\u3002\u771f\u662f\u96be\u4f4f\u6211\u4e86\u3002 \u7b2c\u4e94\u5929-\u5468\u4e09 \u4e0a\u5348\u5f00\u4f1a\u3002 \u4e0b\u5348\u5f00\u59cb\u5c1d\u8bd5\u7f16\u5199CNN\u6a21\u578b\u5e76\u8c03\u8bd5\u3002\u8fd9\u4e5f\u662f\u6211\u5934\u4e00\u6b21\u505a\u7c7b\u4f3c\u7684\u5de5\u4f5c\uff0c\u8fc7\u53bb\u4e00\u6bb5\u65f6\u95f4\u4e5f\u53ea\u662f\u201c\u8d70\u9a6c\u89c2\u82b1\u201d\uff0c\u7b2c\u4e00\u6b21\u771f\u6b63\u7684\u53bb\u5b9e\u73b0\u8fd9\u6837\u4e00\u4e2a\u6a21\u578b\uff0c\u5728\u7ec6\u8282\u4e0a\u96be\u514d\u4f1a\u6709\u4e0d\u8db3\u3002\u4ee3\u7801\u7f16\u5199\u662f\u4e00\u90e8\u5206\u5de5\u4f5c\uff0c\u66f4\u591a\u7684\u65f6\u95f4\u88ab\u6211\u82b1\u5728tuning\u4e0a\uff0c\u8fd9\u66f4\u662f\u96be\u4e0a\u52a0\u96be\u3002 \u665a\u4e0a\u4e0eJ\u541b\u8ba8\u8bba\u5b66\u4e60\u5185\u6838\u77e5\u8bc6\u7684\u4e8b\u5b9c\uff0c\u5546\u5b9a\u5468\u5468\u5b9a\u91cf\u5b66\u4e60\uff0c\u5468\u5468\u5b9a\u65f6\u8ba8\u8bba\u3002 \u7b2c\u516d\u5929-\u5468\u56db \u88ab\u5b50\u5230\u4e86\u3002\u771f\u662f\u4e00\u4ef6\u5927\u559c\u4e8b\u3002\u94fa\u5e8a\u94fa\u4e86\u5f88\u4e45\u5f88\u4e45\uff0c\u751f\u6015\u94fa\u5f97\u4e0d\u5e73\u6574\uff0c\u665a\u4e0a\u4f1a\u51b7\u3002 \u7b2c\u4e03\u5929-\u5468\u4e94 \u51bb\u9192\uff01 \u4e8b\u5b9e\u8bc1\u660e \u5c4b\u5b50\u91cc\u662f\u771f\u7684 \u51b7\uff01 \u88ab\u5b50\u5b58\u4e0d\u4f4f\u6e29\u5ea6\uff01 \u95e8\u7a97\u6f0f\u98ce\uff01 \u545c\u547c\u54c0\u54c9\uff01 \u4fc4\u9877\u98ce\u5b9a\u4e91\u58a8\u8272\uff0c\u79cb\u5929\u6f20\u6f20\u5411\u660f\u9ed1 \u5e03\u887e\u591a\u5e74\u51b7\u4f3c\u94c1\uff0c\u5a07\u513f\u6076\u5367\u8e0f\u91cc\u88c2 \u5e8a\u5934\u5c4b\u6f0f\u65e0\u5e72\u5904\uff0c\u96e8\u811a\u5982\u9ebb\u672a\u65ad\u7edd \u81ea\u7ecf\u4e27\u4e71\u5c11\u7761\u7720\uff0c\u957f\u591c\u6cbe\u6e7f\u4f55\u7531\u5f7b\uff01 \u4e0b\u5348 \u68c9\u62d6\u978b \u5230\u4e86\uff0c\u624b\u673a \u5230\u4e86\uff0cRNN\u6a21\u578b \u5b9e\u73b0\u4e86\uff0ctuning \u4f9d\u65e7\u5931\u8d25 \u96be\uff01 \u56de\u53bb \u804a\u5929 C\u541b\uff0c\u5979\uff0cshe\uff0cher\uff0celle \u6625\u98ce\u5341\u91cc\u626c\u5dde\u8def \u5377\u4e0a\u73e0\u83b2\u603b\u4e0d\u5982 \u76f8\u601d\u4e0d\u7528\u5bbd\u91d1\u948f \u4e5f\u4e0d\u7528\u3001\u591a\u60c5\u4f3c\u7389\u71d5 \u95ee\u53d6\u5a75\u5a1f\u5b66\u957f\u8fdc \u4e0d\u5fc5\u6e05\u5149\u591c\u591c\u89c1 \u4f46\u83ab\u8d1f\u3001\u56e2\u5706\u613f","title":"\u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u4e09\u5929"},{"location":"posts/2018-03-10-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%B8%89%E5%A4%A9/#100-","text":"","title":"\u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u4e09\u5929"},{"location":"posts/2018-03-10-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%B8%89%E5%A4%A9/#-","text":"\u8bf4\u5b9e\u8bdd\uff0c\u5199\u4e0b\u8fd9\u6bb5\u6587\u5b57\u7684\u65f6\u5019\u5df2\u8fdc\u8fdc\u5728\u7b2c\u4e09\u5929\u4e4b\u540e\u3002\u90a3\u4eca\u5929\u5c31\u6765\u4e2a\u4e86\u65ad\uff0c\u7701\u5f97\u4e00\u4e9b\u4e8b\u60c5\u5fd8\u4e86\uff0c\u8981\u4e48\u7a7a\u6b22\u559c\u4e00\u573a\uff0c\u8981\u4e48\u7a7a\u60b2\u4f24\u4e00\u573a\u3002 \u4e00\u7741\u773c\u5df2\u7ecf\u63a5\u8fd1\u516b\u70b9\uff0c\u53c8\u987f\u89c9\u51c9\u610f\u88ad\u6765\u3002\u8fd9\u5929\u6c14\u7684\u53d8\u6362\u7adf\u5982\u540c\u5c0f\u5b69\u513f\u7684\u813e\u6c14\u4e00\u822c\u96be\u4ee5\u7422\u78e8\u3002\u987e\u4e0d\u4e86\u90a3\u4e48\u591a\uff0c\u6211\u8d76\u7d27\u8d77\u6765\uff0c\u51c6\u5907\u6d17\u6f31\u3002 \u53bb\u5e74\u529e\u7684\u5b66\u751f\u5361\uff08\u84dd\u5361\uff0c\u53ef\u4ee5\u5728\u9650\u5b9a\u7684\u98df\u5802\u5403\u996d\uff0c\u53ef\u4ee5\u5237\u95e8\u7981\uff09\u4eca\u5929\u53ef\u4ee5\u6d3e\u4e0a\u7528\u573a\u4e86\uff0c\u8fd9\u5b66\u751f\u5361\u4e5f\u662f\u53ef\u4ee5\u5237\u70ed\u6c34\u7684\uff08\u6628\u665a\u6210\u529f\u8bd5\u8fc7\uff09\u3002\u6211\u6025\u5306\u5306\u5730\u8dd1\u53bb\u6d17\u6f31\u95f4\uff0c\u51c6\u5907\u6253\u4e9b\u70ed\u6c34\uff0c\u6bcf\u6210\u60f3\uff0c\u8fd9\u70ed\u6c34\u9f99\u5934\u53ea\u662f\u56a3\u53eb\uff0c\u6ca1\u6709\u4e00\u70b9\u653e\u51fa\u4e00\u70b9\u6c34\u6765\u7684\u610f\u601d\uff0c\u597d\u5389\u5bb3\u7684\u9b54\u738b\uff01\u6211\u53c8\u56de\u5230\u5bbf\u820d\u95ee\u5ba4\u53cb\uff08\u8001\u751f\uff09\uff0c\u4ed6\u544a\u8bc9\u6211\u65e9\u4e0a\u662f\u6ca1\u6709\u70ed\u6c34\u7684\uff0c\u9700\u8981\u5934\u4e00\u5929\u665a\u4e0a\u7528\u6696\u74f6\u63a5\u597d\u3002\u6211\u6014\u4f4f\uff0c\u60f3\u4e86\u60f3\uff0c\u56de\u4e86\u6d17\u6f31\u95f4\uff0c\u6df1\u5438\u4e86\u4e00\u53e3\u6c14\uff0c\u4fbf\u63a5\u8d77\u51c9\u6c34\u6765\u3002 \u6211\u5feb\u6b65\u8d70\u5230\u5b9e\u9a8c\u5ba4\uff0c\u89c1\u4e86S\u8001\u5e08\uff0c\u5f00\u59cb\u4e86\u4e00\u5929\u7684\u5de5\u4f5c\u3002\u5de5\u4f5c\u5185\u5bb9\u4e0d\u63d0\u3002\u4eca\u5929\u7a81\u7136\u901a\u77e5\u8981\u4ea4\u5f00\u9898\u62a5\u544a\u548c\u6587\u732e\u7ffb\u8bd1\uff0c\u771f\u662f\u706b\u4e0a\u6d47\u6cb9\uff01 \u665a\u4e0a\uff0c\u6211\u65e9\u65e9\u5c31\u56de\u4e86\u5bbf\u820d\u3002\u5916\u9762\u53c8\u4e0b\u8d77\u96e8\u6765\uff0c\u5929\u6c14\u8d8a\u6765\u8d8a\u51c9\u4e86\u3002\u8981\u518d\u4e70\u4e00\u5e8a\u88ab\u5b50\uff01\u8981\u518d\u4e70\u4e00\u53cc\u68c9\u62d6\u978b\uff01","title":"\u7b2c\u4e09\u5929-\u5468\u4e00"},{"location":"posts/2018-03-10-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%B8%89%E5%A4%A9/#-_1","text":"\u4e0a\u5348\u5f00\u4f1a\u3002 \u4e0b\u5348\u5f00\u59cb\u5199\u6587\u732e\u7ffb\u8bd1\u548c\u5f00\u9898\u62a5\u544a\u3002google\u7ffb\u8bd1\u5728\u524d\u4e00\u6bb5\u65f6\u95f4\u6709\u4e86\u8f83\u5927\u7684\u7a81\u7834\uff0c\u5176\u5bf9\u6574\u53e5\u7684\u7406\u89e3\u80fd\u529b\u5927\u5927\u52a0\u5f3a1\u3002\u8fd9\u662f\u4e00\u4e2a\u975e\u5e38\u597d\u7684\u6d88\u606f\uff0c\u6211\u7684\u6587\u732e\u7ffb\u8bd1\u5f88\u5feb\u5c31\u501f\u52a9\u5b83\u5b8c\u6210\u4e86\u3002\u82e5\u662f\u80fd\u6839\u636e\u4e0d\u540c\u671f\u520a\u3001\u4f1a\u8bae\u7684\u8bba\u6587\u683c\u5f0f\u505a\u4e00\u4e2a\u81ea\u52a8\u89e3\u6790\uff0c\u90a3\u5c31\u518d\u597d\u4e0d\u8fc7\u4e86\u3002\u8fd9\u5f00\u9898\u62a5\u544a\u53ef\u96be\u4f4f\u4e86\u6211\uff0c\u6211\u6700\u7ec8\u91c7\u53d6\u4e86\u4e00\u7bc7tutorial2\u7684\u5efa\u8bae\uff0c\u5199\u4e86\u5927\u69823000\u5b57\u3002\u4e00\u76f4\u5199\u5230\u540e\u534a\u591c1\u70b9\u3002\u771f\u662f\u50cf\u6324\u7259\u818f\u3002\u4e00\u822c\u5199\u4f5c\uff0c\u8981\u60f3\u51993000\u5b57\uff0c\u82e5\u662f\u6ca1\u6709\u51e0\u4e07\u5b57\u7684\u77e5\u8bc6\u91cf\u6015\u662f\u4ec0\u4e48\u4e5f\u5199\u4e0d\u51fa\u6765\u7684\u3002\u771f\u662f\u96be\u4f4f\u6211\u4e86\u3002","title":"\u7b2c\u56db\u5929-\u5468\u4e8c"},{"location":"posts/2018-03-10-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%B8%89%E5%A4%A9/#-_2","text":"\u4e0a\u5348\u5f00\u4f1a\u3002 \u4e0b\u5348\u5f00\u59cb\u5c1d\u8bd5\u7f16\u5199CNN\u6a21\u578b\u5e76\u8c03\u8bd5\u3002\u8fd9\u4e5f\u662f\u6211\u5934\u4e00\u6b21\u505a\u7c7b\u4f3c\u7684\u5de5\u4f5c\uff0c\u8fc7\u53bb\u4e00\u6bb5\u65f6\u95f4\u4e5f\u53ea\u662f\u201c\u8d70\u9a6c\u89c2\u82b1\u201d\uff0c\u7b2c\u4e00\u6b21\u771f\u6b63\u7684\u53bb\u5b9e\u73b0\u8fd9\u6837\u4e00\u4e2a\u6a21\u578b\uff0c\u5728\u7ec6\u8282\u4e0a\u96be\u514d\u4f1a\u6709\u4e0d\u8db3\u3002\u4ee3\u7801\u7f16\u5199\u662f\u4e00\u90e8\u5206\u5de5\u4f5c\uff0c\u66f4\u591a\u7684\u65f6\u95f4\u88ab\u6211\u82b1\u5728tuning\u4e0a\uff0c\u8fd9\u66f4\u662f\u96be\u4e0a\u52a0\u96be\u3002 \u665a\u4e0a\u4e0eJ\u541b\u8ba8\u8bba\u5b66\u4e60\u5185\u6838\u77e5\u8bc6\u7684\u4e8b\u5b9c\uff0c\u5546\u5b9a\u5468\u5468\u5b9a\u91cf\u5b66\u4e60\uff0c\u5468\u5468\u5b9a\u65f6\u8ba8\u8bba\u3002","title":"\u7b2c\u4e94\u5929-\u5468\u4e09"},{"location":"posts/2018-03-10-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%B8%89%E5%A4%A9/#-_3","text":"\u88ab\u5b50\u5230\u4e86\u3002\u771f\u662f\u4e00\u4ef6\u5927\u559c\u4e8b\u3002\u94fa\u5e8a\u94fa\u4e86\u5f88\u4e45\u5f88\u4e45\uff0c\u751f\u6015\u94fa\u5f97\u4e0d\u5e73\u6574\uff0c\u665a\u4e0a\u4f1a\u51b7\u3002","title":"\u7b2c\u516d\u5929-\u5468\u56db"},{"location":"posts/2018-03-10-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%B8%89%E5%A4%A9/#-_4","text":"\u51bb\u9192\uff01 \u4e8b\u5b9e\u8bc1\u660e \u5c4b\u5b50\u91cc\u662f\u771f\u7684 \u51b7\uff01 \u88ab\u5b50\u5b58\u4e0d\u4f4f\u6e29\u5ea6\uff01 \u95e8\u7a97\u6f0f\u98ce\uff01 \u545c\u547c\u54c0\u54c9\uff01 \u4fc4\u9877\u98ce\u5b9a\u4e91\u58a8\u8272\uff0c\u79cb\u5929\u6f20\u6f20\u5411\u660f\u9ed1 \u5e03\u887e\u591a\u5e74\u51b7\u4f3c\u94c1\uff0c\u5a07\u513f\u6076\u5367\u8e0f\u91cc\u88c2 \u5e8a\u5934\u5c4b\u6f0f\u65e0\u5e72\u5904\uff0c\u96e8\u811a\u5982\u9ebb\u672a\u65ad\u7edd \u81ea\u7ecf\u4e27\u4e71\u5c11\u7761\u7720\uff0c\u957f\u591c\u6cbe\u6e7f\u4f55\u7531\u5f7b\uff01 \u4e0b\u5348 \u68c9\u62d6\u978b \u5230\u4e86\uff0c\u624b\u673a \u5230\u4e86\uff0cRNN\u6a21\u578b \u5b9e\u73b0\u4e86\uff0ctuning \u4f9d\u65e7\u5931\u8d25 \u96be\uff01 \u56de\u53bb \u804a\u5929 C\u541b\uff0c\u5979\uff0cshe\uff0cher\uff0celle \u6625\u98ce\u5341\u91cc\u626c\u5dde\u8def \u5377\u4e0a\u73e0\u83b2\u603b\u4e0d\u5982 \u76f8\u601d\u4e0d\u7528\u5bbd\u91d1\u948f \u4e5f\u4e0d\u7528\u3001\u591a\u60c5\u4f3c\u7389\u71d5 \u95ee\u53d6\u5a75\u5a1f\u5b66\u957f\u8fdc \u4e0d\u5fc5\u6e05\u5149\u591c\u591c\u89c1 \u4f46\u83ab\u8d1f\u3001\u56e2\u5706\u613f","title":"\u7b2c\u4e03\u5929-\u5468\u4e94"},{"location":"posts/2018-03-11-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%B9%9D%E5%A4%A9/","text":"\u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u4e5d\u5929 \u7b2c\u4e5d\u5929-\u5468\u516d-3-10 \u6628\u665a\u7761\u89c9\u7684\u65f6\u5019\uff0c\u7279\u610f\u5728\u5e8a\u5c3e\u4e00\u4fa7\u653e\u4e86\u5757\u513f\u6bef\u5b50\uff0c\u4eca\u65e9\u8d77\u6765\u4fbf\u6ca1\u6709\u90a3\u4e48\u51b7\u3002 \u8bf4\u8d77\u5bbf\u820d\u6765\uff0c\u96be\u514d\u4e0e\u6bcd\u6821\u6709\u4e00\u4e9b\u5bf9\u6bd4\u3002\u8fd9\u623f\u95f4\u95e8\u3001\u7a97\u6f0f\u98ce\u662f\u4e2a\u5927\u95ee\u9898\uff0c12\u53f7\u697c\uff08\u6bcd\u6821\u5bbf\u820d\uff09\u5728\u6211\u4eec\u4f4f\u8fdb\u53bb\u4e4b\u524d\u5c31\u505a\u4e86\u4fdd\u6e29\uff0c\u5df2\u7ecf\u628a\u8fd9\u4e9b\u95ee\u9898\u89e3\u51b3\u4e86\uff0c\u5916\u52a0\u4e0a\u5317\u4eac\u7684\u5bbf\u820d\u90fd\u88c5\u6709\u6696\u6c14\uff0c\u6625\u5929\u7684\u65f6\u5019\u6211\u4ece\u672a\u611f\u5230\u5982\u6b64\u4e0d\u9002\uff08\u51b7\uff09\u3002\u5176\u4ed6\u65b9\u9762\uff0c\u8fd9\u623f\u95f4\u6574\u6574\u6bd412\u53f7\u697c\u7684\u5bbf\u820d\u5927\u4e00\u5708\uff0c\u6211\u53ef\u4ee5\u8f7b\u677e\u5730\u5728\u5e8a\u4e0a\u7ad9\u7740\u76f4\u8d77\u8170\u6765\uff0c\u524d\u540e\u8ddd\u79bb\u6709\u63a5\u8fd13\u5f20\u5e8a\uff1b\u5bf9\u4e8e\u5bbd\u5ea6\uff0c\u6211\u8ba4\u4e3a\u5e76\u6392\u4e5f\u53ef\u4ee5\u6446\u4e0b3\u5f20\u5e8a\u3002\u4e0e\u8717\u5c45\u5317\u4eac\u76f8\u6bd4\uff0c\u6211\u8fd9\u91cc\u771f\u7b97\u662f\u201c\u8c6a\u5b85\u201d\u4e86\u3002\u8fd9\u5e76\u4e0d\u662f\u4e2a\u72ec\u7279\u73b0\u8c61\uff0c\u6d59\u5927\u7684\u4efb\u4f55\u5efa\u7b51\u5728\u7a7a\u95f4\u8003\u91cf\u4e0a\u90fd\u662f\u201c\u4e0d\u8282\u7ea6\u201d\u7684\uff0c\u98df\u5802\u5de5\u4f5c\u95f4\u8db3\u8db3\u662f\u4e2a\u5c0f\u5c4b\u5b50\uff0c\u91cc\u9762\u53ea\u6709\u4e00\u4e24\u4e2a\u5de5\u4f5c\u4eba\u5458\uff0c\u4eba\u5747\u9762\u79ef\u6211\u4f30\u8ba1\u57287\u30018\u5e73\u7c73\u4ee5\u4e0a\u3002\u5b9e\u9a8c\u5ba4\u7684\u7a7a\u95f4\u66f4\u662f\u201c\u5962\u4f88\u201d\uff0c\u5de5\u4f5c\u53f0\u7684\u9762\u79ef\u4e00\u822c\uff0c\u4f46\u662f\u8f83\u5206\u6563\uff0c\u4eba\u4eec\u6d3b\u52a8\u7684\u9762\u79ef\u662f\u5f88\u5927\uff0c\u8fc7\u5802\u98ce\u53ef\u4ee5\u8f7b\u800c\u6613\u4e3e\u7684\u8fdb\u6765\u53c8\u51fa\u53bb\u3002\u6d59\u5927\u7389\u6cc9\u6821\u533a\u6709\u6781\u5927\u4e00\u90e8\u5206\u4f9b\u4eba\u4eec\u4f11\u606f\u7684\u5730\u65b9\u5929\u6c14\u9002\u5b9c\u7684\u65f6\u5019\u4fbf\u51fa\u6765\u6652\u6652\u592a\u9633\uff0c\u6216\u5e2d\u5730\u800c\u5750\uff0c\u6216\u6c60\u8fb9\u96c5\u5ea7\uff0c\u60ec\u610f\u5f97\u4e0d\u5f97\u4e86\uff0c\u4eba\u4eec\u5728\u8fd9\u91cc\u5f97\u5230\u4e86\u6781\u5927\u7684\u5c0a\u91cd\u4e86\u3002 \u4e0e\u535c\u8001\u5e08\u804a\u5929\u4e0d\u63d0\u3002 \u8fd9\u91cc\u7684\u751f\u6d3b\u6709\u4e9b\u5b89\u9038\uff0c\u8fd9\u6837\u53ef\u4e0d\u597d\u3002 \u672c\u6765\u8ba1\u5212\u6e38\u897f\u6e56\uff0c\u6216\u8005\u53bb\u8868\u54e5\u5bb6\uff0c\u5948\u4f55\u7d27\u5f20\uff0c\u53ea\u5f97\u7559\u4e0b\u5de5\u4f5c\u3002\u5de5\u7a0b\u7684\u95ee\u9898\u662f\u4e00\u5b9a\u80fd\u89e3\u51b3\u7684\uff0cS\u8001\u5e08\u5982\u662f\u8bf4\u3002\u5f53\u4e00\u4e2aresearch\u7684\u95ee\u9898\u53d8\u6210\u5de5\u7a0b\u7684\u95ee\u9898\u7684\u65f6\u5019\uff0c\u89e3\u51b3\u8d77\u6765\u5c31\u662f\u770b\u65f6\u95f4\u3002\u6211\u4eec\u6709\u5f88\u591a\u7406\u7531\u7ec8\u6b62\u81ea\u5df1\u7684\u5de5\u4f5c\uff0c\u6bd4\u5982\u5728\u6709\u9650\u7684\u65f6\u95f4\u4e0d\u80fd\u89e3\u51b3\u4e00\u4e2a\u5de5\u7a0b\u95ee\u9898\uff0c\u8fd9\u8bf4\u660e\u6211\u4eec\u7684\u80fd\u529b\u4e0d\u8db3\uff0c\u751a\u81f3\u95ee\u9898\u662f\u4e0d\u53ef\u89e3\u7684\u3002\u8fd9\u4e24\u79cd\u60c5\u51b5\u90fd\u4e0d\u662f\u6211\u4eec\u60f3\u8981\u7684\uff0c\u662f\u9700\u8981\u5728research\u7684\u9636\u6bb5\u89e3\u51b3\u597d\u7684\u95ee\u9898\u3002\u4e5f\u5c31\u80fd\u7406\u89e3\uff0c\u4e3a\u4ec0\u4e48\u4e00\u4e9b\u5f00\u9898\u62a5\u544a\u4e0a\uff0c\u90a3\u4e48\u5f3a\u8c03\u201c\u53ef\u884c\u6027\u201d\u548c\u201c\u5b9e\u65bd\u65b9\u6848\u201d\u4e86\u3002 \u5373\u4fbf\u662f\u52a0\u73ed\uff0c\u4e5f\u89c9\u5f97\u751f\u6d3b\u5b89\u9038\u3002 \u6709\u51e0\u4e2a\u73b0\u8c61\uff0c\u8d77\u5e8a\u8d77\u4e0d\u6765\uff0c\u8d70\u8def\u6162\u60a0\u60a0\uff0c\u7ecf\u5e38\u73a9\u624b\u673a\uff0c\u4e4b\u95f4\u4e00\u76f4\u575a\u6301\u7684\u82f1\u8bed\u548c\u6cd5\u8bed\u7684\u5b66\u4e60\u4e00\u76f4\u62d6\u5ef6\u3002\u800c\u4e14\uff0c\u81ea\u5df1\u8fd8\u6709\u5f88\u591a\u4e8b\u60c5\u8981\u505a\uff0c\u953b\u70bc\u3001\u6e38\u73a9\u3001\u517c\u804c\u2026\u2026 \u90a3\u5c31\u884c\u52a8\u8d77\u6765\u5427\uff01","title":"\u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u4e5d\u5929"},{"location":"posts/2018-03-11-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%B9%9D%E5%A4%A9/#100-","text":"","title":"\u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u4e5d\u5929"},{"location":"posts/2018-03-11-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%B9%9D%E5%A4%A9/#-3-10","text":"\u6628\u665a\u7761\u89c9\u7684\u65f6\u5019\uff0c\u7279\u610f\u5728\u5e8a\u5c3e\u4e00\u4fa7\u653e\u4e86\u5757\u513f\u6bef\u5b50\uff0c\u4eca\u65e9\u8d77\u6765\u4fbf\u6ca1\u6709\u90a3\u4e48\u51b7\u3002 \u8bf4\u8d77\u5bbf\u820d\u6765\uff0c\u96be\u514d\u4e0e\u6bcd\u6821\u6709\u4e00\u4e9b\u5bf9\u6bd4\u3002\u8fd9\u623f\u95f4\u95e8\u3001\u7a97\u6f0f\u98ce\u662f\u4e2a\u5927\u95ee\u9898\uff0c12\u53f7\u697c\uff08\u6bcd\u6821\u5bbf\u820d\uff09\u5728\u6211\u4eec\u4f4f\u8fdb\u53bb\u4e4b\u524d\u5c31\u505a\u4e86\u4fdd\u6e29\uff0c\u5df2\u7ecf\u628a\u8fd9\u4e9b\u95ee\u9898\u89e3\u51b3\u4e86\uff0c\u5916\u52a0\u4e0a\u5317\u4eac\u7684\u5bbf\u820d\u90fd\u88c5\u6709\u6696\u6c14\uff0c\u6625\u5929\u7684\u65f6\u5019\u6211\u4ece\u672a\u611f\u5230\u5982\u6b64\u4e0d\u9002\uff08\u51b7\uff09\u3002\u5176\u4ed6\u65b9\u9762\uff0c\u8fd9\u623f\u95f4\u6574\u6574\u6bd412\u53f7\u697c\u7684\u5bbf\u820d\u5927\u4e00\u5708\uff0c\u6211\u53ef\u4ee5\u8f7b\u677e\u5730\u5728\u5e8a\u4e0a\u7ad9\u7740\u76f4\u8d77\u8170\u6765\uff0c\u524d\u540e\u8ddd\u79bb\u6709\u63a5\u8fd13\u5f20\u5e8a\uff1b\u5bf9\u4e8e\u5bbd\u5ea6\uff0c\u6211\u8ba4\u4e3a\u5e76\u6392\u4e5f\u53ef\u4ee5\u6446\u4e0b3\u5f20\u5e8a\u3002\u4e0e\u8717\u5c45\u5317\u4eac\u76f8\u6bd4\uff0c\u6211\u8fd9\u91cc\u771f\u7b97\u662f\u201c\u8c6a\u5b85\u201d\u4e86\u3002\u8fd9\u5e76\u4e0d\u662f\u4e2a\u72ec\u7279\u73b0\u8c61\uff0c\u6d59\u5927\u7684\u4efb\u4f55\u5efa\u7b51\u5728\u7a7a\u95f4\u8003\u91cf\u4e0a\u90fd\u662f\u201c\u4e0d\u8282\u7ea6\u201d\u7684\uff0c\u98df\u5802\u5de5\u4f5c\u95f4\u8db3\u8db3\u662f\u4e2a\u5c0f\u5c4b\u5b50\uff0c\u91cc\u9762\u53ea\u6709\u4e00\u4e24\u4e2a\u5de5\u4f5c\u4eba\u5458\uff0c\u4eba\u5747\u9762\u79ef\u6211\u4f30\u8ba1\u57287\u30018\u5e73\u7c73\u4ee5\u4e0a\u3002\u5b9e\u9a8c\u5ba4\u7684\u7a7a\u95f4\u66f4\u662f\u201c\u5962\u4f88\u201d\uff0c\u5de5\u4f5c\u53f0\u7684\u9762\u79ef\u4e00\u822c\uff0c\u4f46\u662f\u8f83\u5206\u6563\uff0c\u4eba\u4eec\u6d3b\u52a8\u7684\u9762\u79ef\u662f\u5f88\u5927\uff0c\u8fc7\u5802\u98ce\u53ef\u4ee5\u8f7b\u800c\u6613\u4e3e\u7684\u8fdb\u6765\u53c8\u51fa\u53bb\u3002\u6d59\u5927\u7389\u6cc9\u6821\u533a\u6709\u6781\u5927\u4e00\u90e8\u5206\u4f9b\u4eba\u4eec\u4f11\u606f\u7684\u5730\u65b9\u5929\u6c14\u9002\u5b9c\u7684\u65f6\u5019\u4fbf\u51fa\u6765\u6652\u6652\u592a\u9633\uff0c\u6216\u5e2d\u5730\u800c\u5750\uff0c\u6216\u6c60\u8fb9\u96c5\u5ea7\uff0c\u60ec\u610f\u5f97\u4e0d\u5f97\u4e86\uff0c\u4eba\u4eec\u5728\u8fd9\u91cc\u5f97\u5230\u4e86\u6781\u5927\u7684\u5c0a\u91cd\u4e86\u3002 \u4e0e\u535c\u8001\u5e08\u804a\u5929\u4e0d\u63d0\u3002 \u8fd9\u91cc\u7684\u751f\u6d3b\u6709\u4e9b\u5b89\u9038\uff0c\u8fd9\u6837\u53ef\u4e0d\u597d\u3002 \u672c\u6765\u8ba1\u5212\u6e38\u897f\u6e56\uff0c\u6216\u8005\u53bb\u8868\u54e5\u5bb6\uff0c\u5948\u4f55\u7d27\u5f20\uff0c\u53ea\u5f97\u7559\u4e0b\u5de5\u4f5c\u3002\u5de5\u7a0b\u7684\u95ee\u9898\u662f\u4e00\u5b9a\u80fd\u89e3\u51b3\u7684\uff0cS\u8001\u5e08\u5982\u662f\u8bf4\u3002\u5f53\u4e00\u4e2aresearch\u7684\u95ee\u9898\u53d8\u6210\u5de5\u7a0b\u7684\u95ee\u9898\u7684\u65f6\u5019\uff0c\u89e3\u51b3\u8d77\u6765\u5c31\u662f\u770b\u65f6\u95f4\u3002\u6211\u4eec\u6709\u5f88\u591a\u7406\u7531\u7ec8\u6b62\u81ea\u5df1\u7684\u5de5\u4f5c\uff0c\u6bd4\u5982\u5728\u6709\u9650\u7684\u65f6\u95f4\u4e0d\u80fd\u89e3\u51b3\u4e00\u4e2a\u5de5\u7a0b\u95ee\u9898\uff0c\u8fd9\u8bf4\u660e\u6211\u4eec\u7684\u80fd\u529b\u4e0d\u8db3\uff0c\u751a\u81f3\u95ee\u9898\u662f\u4e0d\u53ef\u89e3\u7684\u3002\u8fd9\u4e24\u79cd\u60c5\u51b5\u90fd\u4e0d\u662f\u6211\u4eec\u60f3\u8981\u7684\uff0c\u662f\u9700\u8981\u5728research\u7684\u9636\u6bb5\u89e3\u51b3\u597d\u7684\u95ee\u9898\u3002\u4e5f\u5c31\u80fd\u7406\u89e3\uff0c\u4e3a\u4ec0\u4e48\u4e00\u4e9b\u5f00\u9898\u62a5\u544a\u4e0a\uff0c\u90a3\u4e48\u5f3a\u8c03\u201c\u53ef\u884c\u6027\u201d\u548c\u201c\u5b9e\u65bd\u65b9\u6848\u201d\u4e86\u3002 \u5373\u4fbf\u662f\u52a0\u73ed\uff0c\u4e5f\u89c9\u5f97\u751f\u6d3b\u5b89\u9038\u3002 \u6709\u51e0\u4e2a\u73b0\u8c61\uff0c\u8d77\u5e8a\u8d77\u4e0d\u6765\uff0c\u8d70\u8def\u6162\u60a0\u60a0\uff0c\u7ecf\u5e38\u73a9\u624b\u673a\uff0c\u4e4b\u95f4\u4e00\u76f4\u575a\u6301\u7684\u82f1\u8bed\u548c\u6cd5\u8bed\u7684\u5b66\u4e60\u4e00\u76f4\u62d6\u5ef6\u3002\u800c\u4e14\uff0c\u81ea\u5df1\u8fd8\u6709\u5f88\u591a\u4e8b\u60c5\u8981\u505a\uff0c\u953b\u70bc\u3001\u6e38\u73a9\u3001\u517c\u804c\u2026\u2026 \u90a3\u5c31\u884c\u52a8\u8d77\u6765\u5427\uff01","title":"\u7b2c\u4e5d\u5929-\u5468\u516d-3-10"},{"location":"posts/2018-03-28-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E5%8D%81%E5%A4%A9/","text":"\u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u5341\u5929 \u7b2c\u5341\u5929-\u5468\u65e5-3-11 \u8fd9\u7bc7\u65e5\u8bb0\u81f3\u672c\u7bc7\u6587\u7ae0\u6b62\uff0c\u90fd\u662f\u56de\u5fc6\u6027\u8d28\u7684\u3002\u65e5\u8bb0\u65e5\u8bb0\uff0c\u603b\u8981\u575a\u6301\u8bb0\u5f55\u624d\u597d\u3002\u5929\u5929\u8bb0\u5f55\uff0c\u5c31\u8981\u5bf9\u7ec6\u8282\u4e4b\u4e8b\u591a\u8d39\u7b14\u58a8\uff1b\u9694\u5929\u8bb0\u5f55\uff0c\u5374\u53c8\u4e22\u5931\u4e86\u60c5\u666f\u3002\u5475\uff0c\u4e0d\u77e5\u8be5\u5982\u4f55\u6743\u8861\u3002\u6700\u8fd1\u65e5\u8bb0\u6ca1\u8ddf\u4e0a\u7684\u539f\u56e0\u5230\u4e0d\u662f\u524d\u9762\u8fd9\u4e2a\u77db\u76fe\uff0c\u800c\u662f\uff0c\u61d2\u5f97\u8bb0\u3002\u6211\u4e4b\u6240\u4ee5\u80fd\u56de\u5fc6\u8d7717\u5929\u524d\u7684\u4e8b\u60c5\uff0c\u5168\u9760\u81ea\u5df1\u65e5\u5e38\u6d82\u6d82\u753b\u753b\u7684\u7b14\u8bb0\u672c\u4e0a\u7684\u53ea\u8a00\u7247\u8bed\u3002 \u5199\u5230\uff1a\u7814\u7a76\u4e00\u4e0b\u7a7f\u8863\u670d\u3002 \u4eca\u5929\u4e70\u4e86\u4e00\u5957\u6625\u5bd2\u7a7f\u7684\u8863\u670d\uff0c\u8fd9\u4e9b\u5929\u51b7\u5f97\u5389\u5bb3\u3002\u672c\u60f3\u7740\u6765\u5230\u676d\u5dde\u5c31\u76f4\u63a5\u8fc7\u590f\u5929\u4e86\uff0c\u6ca1\u60f3\u5230\u6625\u5bd2\u6599\u5ced\uff0c\u6c14\u6e29\u7adf\u4f4e\u5f97\u53ef\u6015\u3002\u5317\u4eac\u8fd8\u5728\u4f9b\u6696\u671f\uff0c\u6211\u5b9e\u5728\u53d7\u4e0d\u4e86\u8fd9\u822c\u6ca1\u6709\u6696\u6c14\u7684\u6e7f\u51b7\u7684\u65e5\u5b50\u3002 \u7b2c\u5341\u4e00\u5929-\u5468\u4e00-3-12 \u5199\u5230\uff1a\u4eca\u5929\u5565\u4e5f\u6ca1\u5e72 \u4eca\u5929\u4e5f\u4e0d\u662f\u4ec0\u4e48\u4e5f\u6ca1\u505a\uff0c\u53ea\u662f\u53c8\u63a5\u89e6\u4e86\u4e00\u4e2a\u65b0\u7684\u9886\u57df\u2014\u2014\u6570\u636e\u53ef\u89c6\u5316\uff0c\u81ea\u5df1\u6709\u4e9b\u675f\u624b\u65e0\u7b56\u7f62\u4e86\u3002\u5927\u6570\u636e\u3001\u6570\u636e\u6316\u6398\u3001data scientist\u4e4b\u7c7b\u7684\u540d\u5b57\uff0c\u6211\u8fd8\u662f\u5f88\u6a21\u7cca\u3002\u53bb\u5e74\u5e74\u4e2d\u521a\u521a\u53c2\u52a0\u9879\u76ee\u7ec4\u7684\u65f6\u5019\uff0c\u4fbf\u767e\u822c\u7684\u4e0d\u9002\u5e94\u2014\u2014AI\u3001\u673a\u5668\u5b66\u4e60\uff0c\u6df1\u5ea6\u5b66\u4e60\uff0c\u54ea\u4e00\u4e2a\u6211\u53c8\u719f\u6089\u5462\uff1f9\u4e2a\u6708\u8fc7\u53bb\u4e86\uff0c\u4f3c\u4e4e\u624d\u6709\u4e9b\u611f\u89c9\u3002\u6570\u636e\u4e91\u4e91\uff0c\u8fd8\u8fdc\u7740\u54e9\u3002\u9664\u4e86\u4e13\u4e1a\u65b9\u9762\u7684\u77e5\u8bc6\u4e4b\u5916\uff0c\u6211\u4e00\u76f4\u8ba4\u4e3a\u81ea\u5df1\u5e94\u8be5\u5728\u6570\u5b66\uff08\u73b0\u4ee3\u6570\u5b66\uff09\u3001\u7b97\u6cd5\uff08\u4f20\u7edf\u7b97\u6cd5\uff09\u548c\u82f1\u8bed\uff08\u8bf4\u3001\u5199\uff09\u4e0a\u591a\u82b1\u529f\u592b\u3002 \u7b2c\u5341\u4e8c\u5929-\u5468\u4e8c-3-13 \u5199\u5230\uff1a\u5f00\u4f1a\u3001\u770bandroid\u7684code\u3001\u665a\u4e0a\u804a\u6cd5\u8bed \u5b66\u4e60\u6cd5\u8bed\u7684\u52a8\u673a\u662f\u8fd9\u6837\u7684\u3002\u9ad8\u4e2d\u7684\u65f6\u5019\u6709\u5317\u5927\u7684\u8001\u5e08\u8fc7\u6765\u4ea4\u6d41\uff0c\u4ed6\u7740\u91cd\u8bb2\u4e86\u4ed6\u6c42\u5b66\u7684\u90a3\u4e00\u6bb5\u7ecf\u5386\u3002\u5728\u6e05\u534e\u7684\u65f6\u5019\uff0c\u4ed6\u53bb\u8e6d\u6cd5\u8bed\u8bfe\uff0c\u4e5f\u8ddf\u7740\u5927\u5bb6\u4ea4\u4f5c\u4e1a\uff0c\u4e00\u5802\u8bfe\u4e5f\u4e0d\u5dee\uff0c\u8001\u5e08\u4fbf\u8ba4\u8bc6\u4e86\u4ed6\u3002\u518d\u52a0\u4e0a\u4e86\uff0c\u81ea\u5df1\u673a\u654f\u597d\u5b66\uff0c\u7a0b\u5ea6\u8fd8\u597d\u3002\u7d27\u63a5\u7740\u6e05\u534e\u6709\u4e00\u4e2a\u53bb\u6cd5\u56fd\u7559\u5b66\u7684\u540d\u989d\uff0c\u9009\u62d4\u7684\u662f\u7406\u5de5\u79d1\u7684\u5b66\u751f\uff0c\u4ed6\u4fbf\u5f97\u4e86\u4e2a\u4fbf\u5b9c\uff0c\u8d74\u6cd5\u7559\u5b66\u53bb\u4e86\u3002\u6211\u5bf9\u6cd5\u8bed\u7684\u7b2c\u4e00\u5370\u8c61\u4fbf\u662f\u5982\u6b64\u3002\u6211\u81ea\u5df1\u5728\u5927\u4e8c\u7684\u65f6\u5019\uff0c\u5b66\u6821\u6709\u53bb\u6cd5\u8bfb\u5de5\u7a0b\u5e08\u7684\u9879\u76ee\u3002\u90a3\u65f6\u5019\u76d8\u7b97\u4e86\u5f88\u4e45\uff0c\u7701\u5403\u4fed\u75283\u5e7420\u4e07\u3002\u867d\u7136\u8fd9\u5bf9\u6211\u5bb6\u6765\u8bf4\u4e5f\u662f\u5f88\u5927\u4e00\u7b14\u5f00\u9500\uff0c\u4f46\u662f\u6211\u80fd\u65e9\u65e9\u6bd5\u4e1a\uff083+1+2\uff09\u8fd8\u6709\u53ef\u80fd\u4e89\u53d6\u5230\u5956\u5b66\u91d1\uff0c\u524d\u666f\u4e5f\u662f\u4e0d\u9519\u3002\u5948\u4f55\u5b66\u9662\u91cc\u6839\u672c\u4e0dcare\u8fd9\u4e2a\u9879\u76ee\uff0c\u4e5f\u6ca1\u6709\u8d44\u52a9\u7684\u610f\u5411\uff0c\u518d\u52a0\u4e0a\u5144\u957f\u4e70\u4e86\u623f\u5b50\uff0c\u5bb6\u91cc\u7ecf\u6d4e\u7d27\u5f20\uff0c\u6211\u8fd9\u51fa\u56fd\u7684\u6253\u7b97\u4fbf\u6210\u4e86\u6ce1\u5f71\u3002\u4e0d\u8fc7\uff0c\u8fd9\u6b21\u8ba9\u6211\u5bf9\u6cd5\u8bed\u672c\u8eab\u4ea7\u751f\u4e86\u5174\u8da3\u3002\u65e2\u7136\u53bb\u4e0d\u4e86\u6cd5\u56fd\uff0c\u90a3\u5c31\u5b66\u5b83\u4e00\u4e0b\uff01\u5927\u56db\u65f6\u5019\uff0c\u7ec8\u4e8e\u5f97\u51fa\u70b9\u65f6\u95f4\uff0c\u53c8\u627e\u5230\u8fd9\u4e2a\u9879\u76ee\u7684\u8d1f\u8d23\u8001\u5e08\uff0c\u7533\u8bf7\u53ea\u4e0a\u8bfe\u4e0d\u51fa\u56fd\u3002\u8fd9\u4e9b\u90fd\u53d1\u751f\u57282017\u5e746\u6708\uff0c\u90a3\u65f6\u5019\u4fdd\u7814\u590f\u4ee4\u8425\u5f55\u53d6\u5728\u5373\uff0c\u6211\u9700\u8981\u6743\u8861\u65f6\u95f4\uff0c\u590f\u4ee4\u8425\u5728\u6691\u5047\uff0c\u6cd5\u8bed\u8bfe\u4e5f\u5728\u6691\u5047\u3002\u90a3\u65f6\u5019\u56e0\u590f\u4ee4\u8425\u7533\u8bf7\u88ab\u62d2\uff0c\u5174\u5473\u7d22\u7136\u3002\u6211\u4fbf\u6beb\u4e0d\u72b9\u8c6b\u7684\u53bb\u62a5\u4e86\u540d\uff0c\u8d1f\u8d23\u7684\u8001\u5e08\u4eec\u4e5f\u540c\u610f\u6211\u8fd9\u6837\u53c2\u4e0e\u4ed6\u4eec\u7684\u9879\u76ee\u3002\u7d27\u63a5\u7740\u4fbf\u4e00\u76f4\u5b66\u4e60\u52302018\u5e741\u6708\u4efd\uff0c\u56e0\u81ea\u5df1\u7684\u539f\u56e0\u800c\u4e2d\u65ad\u4e86\u5b66\u4e60\u3002\u76ee\u524d\uff0c\u82f1\u8bed\u662f\u6211\u66f4\u8981\u5b66\u597d\u7684\u4e8b\u60c5\uff0c\u6211\u53ea\u80fd\u6bcf\u5929\u65e9\u4e0a\u542c\u7740\u6cd5\u8bed\u8bfe\u672c\u542c\u529b\uff0c\u4ece\u5bbf\u820d\u8d70\u5230\u98df\u5802\uff0c\u518d\u8d70\u5230\u5b9e\u9a8c\u5ba4\uff0c\u7ec3\u7740\u8033\u6735\uff0c\u751f\u6015\u505c\u4e0b\u4e00\u6bb5\u65f6\u95f4\u7684\u5b66\u4e60\uff0c\u5c31\u4f1a\u628a\u4ee5\u524d\u7684\u77e5\u8bc6\u90fd\u5fd8\u6389\u3002\u6211\u60f3\u57282020\u5e74\u4e4b\u524d\u53bb\u4e00\u8d9f\u6cd5\u56fd\u3002 \u7b2c\u5341\u4e09\u5929-\u5468\u4e09-3-14 \u5199\u5230\uff1a\u5b66\u82f1\u8bed\uff0c\u5e7f\u64ad \u6bcf\u5929\u508d\u665a5\u70b9\u5de6\u53f3\u7684\u65f6\u5019\uff0c\u6d59\u5927\u7389\u6cc9\u7684\u6821\u56ed\u91cc\u5c31\u4f1a\u54cd\u8d77\u5982\u82b1\u9999\u822c\u5f25\u6f2b\u4e8e\u7a7a\u6c14\u4e2d\u7684\u6e29\u99a8\u7684\u5e7f\u64ad\u3002\u7389\u6cc9\u8fd9\u91cc\u6811\u6797\u9634\u7ff3\u7684\u5730\u65b9\uff0c\u5e7f\u64ad\u4fbf\u5728\u5929\u4e0a\uff0c\u8fd9\u91cc\u6728\u77ee\u8349\u4e1b\u7684\u5730\u65b9\uff0c\u5e7f\u64ad\u4fbf\u5728\u5730\u4e0a\u3002\u5929\u4e0a\u5730\u4e0a\u90fd\u6709\u4e86\uff0c\u4e5f\u662f\u548c\u5408\u4e4b\u5883\u4e86\u2014\u2014\u4e0d\u540c\u7684\u89d2\u5ea6\u7684\u58f0\u97f3\u2014\u2014\u7a7a\u95f4\u7684\u8f6e\u8f6c\u3001\u5c42\u6b21\u7684\u5206\u660e\uff0c\u5728\u504c\u5927\u7684\u6821\u56ed\u91cc\u5f62\u6210\u4e86\u4e00\u79cd\u72ec\u7279\u7684\u4f53\u9a8c\u3002 \u7b2c\u5341\u56db\u5929-\u5468\u56db-3-15 \u5199\u5230\uff1a\u8ba8\u8bba\uff0c\u770b\u6587\u732e\uff0c\u8ba8\u8bba\uff0c\u6539android\uff0c\u901b\u8d85\u5e02\uff0c\u53bb\u7403\u573a\uff0c\u5496\u5561 \u6211\u4e4b\u6240\u4ee5\u559c\u6b22\u6253\u7fbd\u6bdb\u7403\u662f\u56e0\u4e3a\u8fd9\u662f\u4e00\u9879\u6ca1\u6709\u8eab\u4f53\u63a5\u89e6\u7684\u3001\u6bd4\u8f83\u6587\u660e\u7684\u8fd0\u52a8\u3002\u4e0d\u8fc7\u51e1\u662f\u8fd0\u52a8\u5c31\u4f1a\u6709\u7ade\u6280\u6027\uff0c\u6211\u52a0\u5165\u4e86\u8fd9\u8fb9\u7684\u7fbd\u534f\uff0c\u5e0c\u671b\u53ef\u4ee5\u4e92\u76f8\u5b66\u4e60\u3001\u5207\u78cb\u3002 \u6211\u4e4b\u6240\u4ee5\u559c\u6b22\u559d\u5496\u5561\u662f\u56e0\u4e3a\uff0c\u6211\u559d\u5496\u5561\u7626\u4e86\u3002\u7626\u4e86\uff0c\u6ca1\u9519\u3002\u53e6\u5916\u5c31\u662f\uff0c\u53ef\u4ee5\u8ddf\u670b\u53cb\u53bb\u5496\u5561\u9986\u804a\u5929\u3002\u6211\u6700\u957f\u7684\u8bb0\u5f55\u662f\u804a\u4e865\u4e2a\u5c0f\u65f6\uff08\u6216\u8005\u66f4\u957f\uff09\uff0c\u6211\u60f3\u53ef\u4ee5\u518d\u957f\u4e00\u4e9b\uff0c\u53ea\u662f\u5f53\u65f6\u592a\u665a\uff0c\u6015\u6ca1\u6709\u8f66\u3002\u804a\u5929\u603b\u662f\u4e00\u4ef6\u653e\u677e\u7684\u4e8b\u60c5\uff0c\u5c31\u8981\u53bb\u4e00\u4e2a\u653e\u677e\u7684\u5730\u65b9\u3002 \u7b2c\u5341\u4e94\u5929-\u5468\u4e94-3-16 \u5199\u5230\uff1a\u4eca\u65e9\u8d77\u665a\uff0c\u6ca1\u5403\u65e9\u996d\u3002\u6253\u7403\uff0csoul\uff0cQ\u541b \u8fd9\u8fb9\u98df\u5802\u662f\u5f88\u4fbf\u5b9c\u7684\uff0c\u53ef\u4ee5\u5403\u7684\u5f88\u6e05\u5355\u3002\u53c8\u5065\u5eb7\u53c8\u5b9e\u60e0\u3002\u4e0eQ\u541b\u5403\u996d\uff0c\u4ed6\u9a6c\u4e0a\u6bd5\u4e1a\u8d70\u4e86\u3002\u6211\u4e45\u4ef0Q\u541b\u5927\u540d\u5df2\u4e45\uff0c\u5982\u4eca\u89c1\u5230\u5e90\u5c71\u771f\u9762\u76ee\u7adf\u6709\u4e9b\u4e0d\u77e5\u8bf4\u4ec0\u4e48\u597d\u3002\u4ed6\u4ece\u5bb6\u91cc\u8003\u5165\u540d\u6821\uff0c\u521b\u9020\u4e86\u4e00\u4e9b\u201c\u8bb0\u5f55\u201d\u3002\u8bb0\u5f55\u603b\u662f\u8981\u88ab\u4eba\u6253\u7834\u7684\uff0c\u5e0c\u671b\u6211\u4e4b\u540e\u7684\u4eba\u80fd\u5728\u5b66\u4e1a\u4e0a\u518d\u63a5\u518d\u5389\u3002 \u7b2c\u5341\u516d\u5929-\u5468\u516d-3-17 \u5199\u5230\uff1a\u5e0c\u671b\u81ea\u5df1\u505a\u7684\u6bcf\u4e00\u4ef6\u4e8b\u90fd\u6709\u4e9b\u8fdb\u6b65\u610f\u4e49 \u8fd9\u5f53\u7136\u662f\u9650\u4e8e\u5de5\u4f5c\u4e2d\u3002\u6700\u8fd1\u505a\u4e8b\u60c5\u4f1a\u8003\u8651\u628a\u4e00\u4ef6\u4e8b\u505a\u597d\uff0c\u800c\u4e0d\u662f\u8d70\u9a6c\u89c2\u82b1\u3002\u5c24\u5176\u662f\u7b2c\u4e8c\u6b21\u505a\u8fd9\u4ef6\u4e8b\u6216\u7b2c\u4e09\u6b21\u505a\u8fd9\u4ef6\u4e8b\u7684\u65f6\u5019\u3002\u6311\u9009\u4e3b\u6d41\u7684\u5de5\u5177\u5f80\u5f80\u4e0d\u4f1a\u6709\u8fc7\u9519\uff0c\u8981\u628aword\u5b66\u597d\u3002\u5199\u6587\u6863\u6700\u91cd\u8981\u7684\u8fd8\u662f\u6e05\u6670\u8868\u8fbe\uff0c\u8fd9\u5f80\u5f80\u53ef\u4ee5\u901a\u8fc7\u4e00\u5b9a\u7684\u5f62\u5f0f\u6765\u8868\u73b0\u3002\u5f62\u5f0f\u8981\u4e3a\u5185\u5bb9\u670d\u52a1\uff0c\u5e0c\u671b\u5728\u4eca\u540e\u5199\u6587\u6863\u7684\u6e05\u6670\u8868\u8fbe\u4e0a\u80fd\u591a\u4e0b\u529f\u592b\u3002 \u4e0b\u5348\u901b\u897f\u6e56\uff0c\u508d\u665a\u53bb\u8868\u54e5\u5bb6 \u7b2c\u5341\u516d\u5929-\u5468\u65e5-3-18 \u4ece\u8868\u54e5\u5bb6\u56de\u6765\uff0c\u91cd\u65b0\u7ed9\u7535\u8111\u5b89\u88c5\u4e86\u7cfb\u7edf \u7b2c\u5341\u4e03\u5929-\u5468\u4e00-3-19 \u4ec0\u4e48\u4e5f\u6ca1\u5199\uff0c\u51c6\u5907\u7b2c\u4e8c\u5929\u5f00\u4f1a \u7b2c\u5341\u516b\u5929-\u5468\u4e8c-3-20 \u4ec0\u4e48\u4e5f\u6ca1\u5199\uff0c\u8fd9\u4e00\u5929\u5f00\u4f1a \u7b2c\u5341\u4e5d\u5929-\u5468\u4e09-3-21 \u5199\u5230\uff1a\u4e70\u4e86\u7535\u70ed\u6bef \u5bd2\u6f6e\u6765\u88ad\uff0c\u6c14\u6e29\u9aa4\u964d\u3002\u7ec8\u4e8e\u4e0b\u4e86\u51b3\u5fc3\u4e70\u4e86\u7535\u70ed\u6bef\u3002\u8fd9\u4e2a\u6708\u5b9e\u5728\u6709\u4e9b\u7834\u8d39\uff0c\u6bcf\u4e00\u5e74\u603b\u6709\u51e0\u4e2a\u6708\u662f\u7834\u8d39\u7684\u3002\u6ca1\u6709\u6536\u5165\uff0c\u53ea\u6709\u652f\u51fa\uff0c\u545c\u547c\uff01\u665a\u4e0a\u7761\u4e86\u4e2a\u6696\u548c\u89c9\u3002 \u7b2c\u4e8c\u5341\u5929-\u5468\u56db-3-22 \u5199\u5230\uff1a\u67b6\u6784 \u8fd9\u8f6f\u5de5\u7684\u80fd\u529b\u662f\u4e00\u5b9a\u8981\u57f9\u517b\u7684\u3002\u5177\u4f53\u600e\u4e48\u57f9\u517b\uff0c\u518d\u8bae\u3002 \u7b2c\u4e8c\u5341\u4e00\u5929-\u5468\u4e94-3-23 \u5199\u5230\uff1a\u6587\u732e\u68c0\u7d22 \u53c8\u5f00\u59cb\u505a\u4e86\u4e00\u4ef6\u964c\u751f\u7684\u4e8b\u60c5\uff0c\u5e0c\u671b\u80fd\u6709\u70b9\u6210\u679c\u3002 \u7b2c\u4e8c\u5341\u4e8c\u5929-\u5468\u516d-3-24 \u4e0eW\u541b\u901b\u5357\u5b8b\u5fa1\u8857\u548c\u6cb3\u574a\u8857\uff0c\u7545\u804a\u3002 \u7b2c\u4e8c\u5341\u4e09\u5929-\u5468\u65e5-3-25 \u4ec0\u4e48\u4e5f\u6ca1\u5199 \u7b2c\u4e8c\u5341\u56db\u5929-\u5468\u4e00-3-26 \u6d88\u5931\u7684\u4e00\u5929 \u7b2c\u4e8c\u5341\u4e94\u5929-\u5468\u4e8c-3-27 \u5199\u5230\uff1a\u6700\u8fd1\u7684\u65e5\u5b50\u8fc7\u5f97\u592a\u5b89\u9038\uff0c\u53c8\u6709\u4e9b\u6625\u56f0\u3002\u7761\u89c9\u4e0d\u89e3\u4e4f\uff1b\u5e0c\u671b\u65e9\u70b9\u8d77\u5e8a\uff0c\u65e9\u70b9\u56de\u53bb\u3002 \u4eca\u5929\u5f00\u4f1a\u3002 \u7b2c\u4e8c\u5341\u516d\u5929-\u5468\u4e09-3-28 \u4ec0\u4e48\u4e5f\u6ca1\u5199","title":"\u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u5341\u5929"},{"location":"posts/2018-03-28-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E5%8D%81%E5%A4%A9/#100-","text":"","title":"\u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u5341\u5929"},{"location":"posts/2018-03-28-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E5%8D%81%E5%A4%A9/#-3-11","text":"\u8fd9\u7bc7\u65e5\u8bb0\u81f3\u672c\u7bc7\u6587\u7ae0\u6b62\uff0c\u90fd\u662f\u56de\u5fc6\u6027\u8d28\u7684\u3002\u65e5\u8bb0\u65e5\u8bb0\uff0c\u603b\u8981\u575a\u6301\u8bb0\u5f55\u624d\u597d\u3002\u5929\u5929\u8bb0\u5f55\uff0c\u5c31\u8981\u5bf9\u7ec6\u8282\u4e4b\u4e8b\u591a\u8d39\u7b14\u58a8\uff1b\u9694\u5929\u8bb0\u5f55\uff0c\u5374\u53c8\u4e22\u5931\u4e86\u60c5\u666f\u3002\u5475\uff0c\u4e0d\u77e5\u8be5\u5982\u4f55\u6743\u8861\u3002\u6700\u8fd1\u65e5\u8bb0\u6ca1\u8ddf\u4e0a\u7684\u539f\u56e0\u5230\u4e0d\u662f\u524d\u9762\u8fd9\u4e2a\u77db\u76fe\uff0c\u800c\u662f\uff0c\u61d2\u5f97\u8bb0\u3002\u6211\u4e4b\u6240\u4ee5\u80fd\u56de\u5fc6\u8d7717\u5929\u524d\u7684\u4e8b\u60c5\uff0c\u5168\u9760\u81ea\u5df1\u65e5\u5e38\u6d82\u6d82\u753b\u753b\u7684\u7b14\u8bb0\u672c\u4e0a\u7684\u53ea\u8a00\u7247\u8bed\u3002 \u5199\u5230\uff1a\u7814\u7a76\u4e00\u4e0b\u7a7f\u8863\u670d\u3002 \u4eca\u5929\u4e70\u4e86\u4e00\u5957\u6625\u5bd2\u7a7f\u7684\u8863\u670d\uff0c\u8fd9\u4e9b\u5929\u51b7\u5f97\u5389\u5bb3\u3002\u672c\u60f3\u7740\u6765\u5230\u676d\u5dde\u5c31\u76f4\u63a5\u8fc7\u590f\u5929\u4e86\uff0c\u6ca1\u60f3\u5230\u6625\u5bd2\u6599\u5ced\uff0c\u6c14\u6e29\u7adf\u4f4e\u5f97\u53ef\u6015\u3002\u5317\u4eac\u8fd8\u5728\u4f9b\u6696\u671f\uff0c\u6211\u5b9e\u5728\u53d7\u4e0d\u4e86\u8fd9\u822c\u6ca1\u6709\u6696\u6c14\u7684\u6e7f\u51b7\u7684\u65e5\u5b50\u3002","title":"\u7b2c\u5341\u5929-\u5468\u65e5-3-11"},{"location":"posts/2018-03-28-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E5%8D%81%E5%A4%A9/#-3-12","text":"\u5199\u5230\uff1a\u4eca\u5929\u5565\u4e5f\u6ca1\u5e72 \u4eca\u5929\u4e5f\u4e0d\u662f\u4ec0\u4e48\u4e5f\u6ca1\u505a\uff0c\u53ea\u662f\u53c8\u63a5\u89e6\u4e86\u4e00\u4e2a\u65b0\u7684\u9886\u57df\u2014\u2014\u6570\u636e\u53ef\u89c6\u5316\uff0c\u81ea\u5df1\u6709\u4e9b\u675f\u624b\u65e0\u7b56\u7f62\u4e86\u3002\u5927\u6570\u636e\u3001\u6570\u636e\u6316\u6398\u3001data scientist\u4e4b\u7c7b\u7684\u540d\u5b57\uff0c\u6211\u8fd8\u662f\u5f88\u6a21\u7cca\u3002\u53bb\u5e74\u5e74\u4e2d\u521a\u521a\u53c2\u52a0\u9879\u76ee\u7ec4\u7684\u65f6\u5019\uff0c\u4fbf\u767e\u822c\u7684\u4e0d\u9002\u5e94\u2014\u2014AI\u3001\u673a\u5668\u5b66\u4e60\uff0c\u6df1\u5ea6\u5b66\u4e60\uff0c\u54ea\u4e00\u4e2a\u6211\u53c8\u719f\u6089\u5462\uff1f9\u4e2a\u6708\u8fc7\u53bb\u4e86\uff0c\u4f3c\u4e4e\u624d\u6709\u4e9b\u611f\u89c9\u3002\u6570\u636e\u4e91\u4e91\uff0c\u8fd8\u8fdc\u7740\u54e9\u3002\u9664\u4e86\u4e13\u4e1a\u65b9\u9762\u7684\u77e5\u8bc6\u4e4b\u5916\uff0c\u6211\u4e00\u76f4\u8ba4\u4e3a\u81ea\u5df1\u5e94\u8be5\u5728\u6570\u5b66\uff08\u73b0\u4ee3\u6570\u5b66\uff09\u3001\u7b97\u6cd5\uff08\u4f20\u7edf\u7b97\u6cd5\uff09\u548c\u82f1\u8bed\uff08\u8bf4\u3001\u5199\uff09\u4e0a\u591a\u82b1\u529f\u592b\u3002","title":"\u7b2c\u5341\u4e00\u5929-\u5468\u4e00-3-12"},{"location":"posts/2018-03-28-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E5%8D%81%E5%A4%A9/#-3-13","text":"\u5199\u5230\uff1a\u5f00\u4f1a\u3001\u770bandroid\u7684code\u3001\u665a\u4e0a\u804a\u6cd5\u8bed \u5b66\u4e60\u6cd5\u8bed\u7684\u52a8\u673a\u662f\u8fd9\u6837\u7684\u3002\u9ad8\u4e2d\u7684\u65f6\u5019\u6709\u5317\u5927\u7684\u8001\u5e08\u8fc7\u6765\u4ea4\u6d41\uff0c\u4ed6\u7740\u91cd\u8bb2\u4e86\u4ed6\u6c42\u5b66\u7684\u90a3\u4e00\u6bb5\u7ecf\u5386\u3002\u5728\u6e05\u534e\u7684\u65f6\u5019\uff0c\u4ed6\u53bb\u8e6d\u6cd5\u8bed\u8bfe\uff0c\u4e5f\u8ddf\u7740\u5927\u5bb6\u4ea4\u4f5c\u4e1a\uff0c\u4e00\u5802\u8bfe\u4e5f\u4e0d\u5dee\uff0c\u8001\u5e08\u4fbf\u8ba4\u8bc6\u4e86\u4ed6\u3002\u518d\u52a0\u4e0a\u4e86\uff0c\u81ea\u5df1\u673a\u654f\u597d\u5b66\uff0c\u7a0b\u5ea6\u8fd8\u597d\u3002\u7d27\u63a5\u7740\u6e05\u534e\u6709\u4e00\u4e2a\u53bb\u6cd5\u56fd\u7559\u5b66\u7684\u540d\u989d\uff0c\u9009\u62d4\u7684\u662f\u7406\u5de5\u79d1\u7684\u5b66\u751f\uff0c\u4ed6\u4fbf\u5f97\u4e86\u4e2a\u4fbf\u5b9c\uff0c\u8d74\u6cd5\u7559\u5b66\u53bb\u4e86\u3002\u6211\u5bf9\u6cd5\u8bed\u7684\u7b2c\u4e00\u5370\u8c61\u4fbf\u662f\u5982\u6b64\u3002\u6211\u81ea\u5df1\u5728\u5927\u4e8c\u7684\u65f6\u5019\uff0c\u5b66\u6821\u6709\u53bb\u6cd5\u8bfb\u5de5\u7a0b\u5e08\u7684\u9879\u76ee\u3002\u90a3\u65f6\u5019\u76d8\u7b97\u4e86\u5f88\u4e45\uff0c\u7701\u5403\u4fed\u75283\u5e7420\u4e07\u3002\u867d\u7136\u8fd9\u5bf9\u6211\u5bb6\u6765\u8bf4\u4e5f\u662f\u5f88\u5927\u4e00\u7b14\u5f00\u9500\uff0c\u4f46\u662f\u6211\u80fd\u65e9\u65e9\u6bd5\u4e1a\uff083+1+2\uff09\u8fd8\u6709\u53ef\u80fd\u4e89\u53d6\u5230\u5956\u5b66\u91d1\uff0c\u524d\u666f\u4e5f\u662f\u4e0d\u9519\u3002\u5948\u4f55\u5b66\u9662\u91cc\u6839\u672c\u4e0dcare\u8fd9\u4e2a\u9879\u76ee\uff0c\u4e5f\u6ca1\u6709\u8d44\u52a9\u7684\u610f\u5411\uff0c\u518d\u52a0\u4e0a\u5144\u957f\u4e70\u4e86\u623f\u5b50\uff0c\u5bb6\u91cc\u7ecf\u6d4e\u7d27\u5f20\uff0c\u6211\u8fd9\u51fa\u56fd\u7684\u6253\u7b97\u4fbf\u6210\u4e86\u6ce1\u5f71\u3002\u4e0d\u8fc7\uff0c\u8fd9\u6b21\u8ba9\u6211\u5bf9\u6cd5\u8bed\u672c\u8eab\u4ea7\u751f\u4e86\u5174\u8da3\u3002\u65e2\u7136\u53bb\u4e0d\u4e86\u6cd5\u56fd\uff0c\u90a3\u5c31\u5b66\u5b83\u4e00\u4e0b\uff01\u5927\u56db\u65f6\u5019\uff0c\u7ec8\u4e8e\u5f97\u51fa\u70b9\u65f6\u95f4\uff0c\u53c8\u627e\u5230\u8fd9\u4e2a\u9879\u76ee\u7684\u8d1f\u8d23\u8001\u5e08\uff0c\u7533\u8bf7\u53ea\u4e0a\u8bfe\u4e0d\u51fa\u56fd\u3002\u8fd9\u4e9b\u90fd\u53d1\u751f\u57282017\u5e746\u6708\uff0c\u90a3\u65f6\u5019\u4fdd\u7814\u590f\u4ee4\u8425\u5f55\u53d6\u5728\u5373\uff0c\u6211\u9700\u8981\u6743\u8861\u65f6\u95f4\uff0c\u590f\u4ee4\u8425\u5728\u6691\u5047\uff0c\u6cd5\u8bed\u8bfe\u4e5f\u5728\u6691\u5047\u3002\u90a3\u65f6\u5019\u56e0\u590f\u4ee4\u8425\u7533\u8bf7\u88ab\u62d2\uff0c\u5174\u5473\u7d22\u7136\u3002\u6211\u4fbf\u6beb\u4e0d\u72b9\u8c6b\u7684\u53bb\u62a5\u4e86\u540d\uff0c\u8d1f\u8d23\u7684\u8001\u5e08\u4eec\u4e5f\u540c\u610f\u6211\u8fd9\u6837\u53c2\u4e0e\u4ed6\u4eec\u7684\u9879\u76ee\u3002\u7d27\u63a5\u7740\u4fbf\u4e00\u76f4\u5b66\u4e60\u52302018\u5e741\u6708\u4efd\uff0c\u56e0\u81ea\u5df1\u7684\u539f\u56e0\u800c\u4e2d\u65ad\u4e86\u5b66\u4e60\u3002\u76ee\u524d\uff0c\u82f1\u8bed\u662f\u6211\u66f4\u8981\u5b66\u597d\u7684\u4e8b\u60c5\uff0c\u6211\u53ea\u80fd\u6bcf\u5929\u65e9\u4e0a\u542c\u7740\u6cd5\u8bed\u8bfe\u672c\u542c\u529b\uff0c\u4ece\u5bbf\u820d\u8d70\u5230\u98df\u5802\uff0c\u518d\u8d70\u5230\u5b9e\u9a8c\u5ba4\uff0c\u7ec3\u7740\u8033\u6735\uff0c\u751f\u6015\u505c\u4e0b\u4e00\u6bb5\u65f6\u95f4\u7684\u5b66\u4e60\uff0c\u5c31\u4f1a\u628a\u4ee5\u524d\u7684\u77e5\u8bc6\u90fd\u5fd8\u6389\u3002\u6211\u60f3\u57282020\u5e74\u4e4b\u524d\u53bb\u4e00\u8d9f\u6cd5\u56fd\u3002","title":"\u7b2c\u5341\u4e8c\u5929-\u5468\u4e8c-3-13"},{"location":"posts/2018-03-28-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E5%8D%81%E5%A4%A9/#-3-14","text":"\u5199\u5230\uff1a\u5b66\u82f1\u8bed\uff0c\u5e7f\u64ad \u6bcf\u5929\u508d\u665a5\u70b9\u5de6\u53f3\u7684\u65f6\u5019\uff0c\u6d59\u5927\u7389\u6cc9\u7684\u6821\u56ed\u91cc\u5c31\u4f1a\u54cd\u8d77\u5982\u82b1\u9999\u822c\u5f25\u6f2b\u4e8e\u7a7a\u6c14\u4e2d\u7684\u6e29\u99a8\u7684\u5e7f\u64ad\u3002\u7389\u6cc9\u8fd9\u91cc\u6811\u6797\u9634\u7ff3\u7684\u5730\u65b9\uff0c\u5e7f\u64ad\u4fbf\u5728\u5929\u4e0a\uff0c\u8fd9\u91cc\u6728\u77ee\u8349\u4e1b\u7684\u5730\u65b9\uff0c\u5e7f\u64ad\u4fbf\u5728\u5730\u4e0a\u3002\u5929\u4e0a\u5730\u4e0a\u90fd\u6709\u4e86\uff0c\u4e5f\u662f\u548c\u5408\u4e4b\u5883\u4e86\u2014\u2014\u4e0d\u540c\u7684\u89d2\u5ea6\u7684\u58f0\u97f3\u2014\u2014\u7a7a\u95f4\u7684\u8f6e\u8f6c\u3001\u5c42\u6b21\u7684\u5206\u660e\uff0c\u5728\u504c\u5927\u7684\u6821\u56ed\u91cc\u5f62\u6210\u4e86\u4e00\u79cd\u72ec\u7279\u7684\u4f53\u9a8c\u3002","title":"\u7b2c\u5341\u4e09\u5929-\u5468\u4e09-3-14"},{"location":"posts/2018-03-28-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E5%8D%81%E5%A4%A9/#-3-15","text":"\u5199\u5230\uff1a\u8ba8\u8bba\uff0c\u770b\u6587\u732e\uff0c\u8ba8\u8bba\uff0c\u6539android\uff0c\u901b\u8d85\u5e02\uff0c\u53bb\u7403\u573a\uff0c\u5496\u5561 \u6211\u4e4b\u6240\u4ee5\u559c\u6b22\u6253\u7fbd\u6bdb\u7403\u662f\u56e0\u4e3a\u8fd9\u662f\u4e00\u9879\u6ca1\u6709\u8eab\u4f53\u63a5\u89e6\u7684\u3001\u6bd4\u8f83\u6587\u660e\u7684\u8fd0\u52a8\u3002\u4e0d\u8fc7\u51e1\u662f\u8fd0\u52a8\u5c31\u4f1a\u6709\u7ade\u6280\u6027\uff0c\u6211\u52a0\u5165\u4e86\u8fd9\u8fb9\u7684\u7fbd\u534f\uff0c\u5e0c\u671b\u53ef\u4ee5\u4e92\u76f8\u5b66\u4e60\u3001\u5207\u78cb\u3002 \u6211\u4e4b\u6240\u4ee5\u559c\u6b22\u559d\u5496\u5561\u662f\u56e0\u4e3a\uff0c\u6211\u559d\u5496\u5561\u7626\u4e86\u3002\u7626\u4e86\uff0c\u6ca1\u9519\u3002\u53e6\u5916\u5c31\u662f\uff0c\u53ef\u4ee5\u8ddf\u670b\u53cb\u53bb\u5496\u5561\u9986\u804a\u5929\u3002\u6211\u6700\u957f\u7684\u8bb0\u5f55\u662f\u804a\u4e865\u4e2a\u5c0f\u65f6\uff08\u6216\u8005\u66f4\u957f\uff09\uff0c\u6211\u60f3\u53ef\u4ee5\u518d\u957f\u4e00\u4e9b\uff0c\u53ea\u662f\u5f53\u65f6\u592a\u665a\uff0c\u6015\u6ca1\u6709\u8f66\u3002\u804a\u5929\u603b\u662f\u4e00\u4ef6\u653e\u677e\u7684\u4e8b\u60c5\uff0c\u5c31\u8981\u53bb\u4e00\u4e2a\u653e\u677e\u7684\u5730\u65b9\u3002","title":"\u7b2c\u5341\u56db\u5929-\u5468\u56db-3-15"},{"location":"posts/2018-03-28-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E5%8D%81%E5%A4%A9/#-3-16","text":"\u5199\u5230\uff1a\u4eca\u65e9\u8d77\u665a\uff0c\u6ca1\u5403\u65e9\u996d\u3002\u6253\u7403\uff0csoul\uff0cQ\u541b \u8fd9\u8fb9\u98df\u5802\u662f\u5f88\u4fbf\u5b9c\u7684\uff0c\u53ef\u4ee5\u5403\u7684\u5f88\u6e05\u5355\u3002\u53c8\u5065\u5eb7\u53c8\u5b9e\u60e0\u3002\u4e0eQ\u541b\u5403\u996d\uff0c\u4ed6\u9a6c\u4e0a\u6bd5\u4e1a\u8d70\u4e86\u3002\u6211\u4e45\u4ef0Q\u541b\u5927\u540d\u5df2\u4e45\uff0c\u5982\u4eca\u89c1\u5230\u5e90\u5c71\u771f\u9762\u76ee\u7adf\u6709\u4e9b\u4e0d\u77e5\u8bf4\u4ec0\u4e48\u597d\u3002\u4ed6\u4ece\u5bb6\u91cc\u8003\u5165\u540d\u6821\uff0c\u521b\u9020\u4e86\u4e00\u4e9b\u201c\u8bb0\u5f55\u201d\u3002\u8bb0\u5f55\u603b\u662f\u8981\u88ab\u4eba\u6253\u7834\u7684\uff0c\u5e0c\u671b\u6211\u4e4b\u540e\u7684\u4eba\u80fd\u5728\u5b66\u4e1a\u4e0a\u518d\u63a5\u518d\u5389\u3002","title":"\u7b2c\u5341\u4e94\u5929-\u5468\u4e94-3-16"},{"location":"posts/2018-03-28-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E5%8D%81%E5%A4%A9/#-3-17","text":"\u5199\u5230\uff1a\u5e0c\u671b\u81ea\u5df1\u505a\u7684\u6bcf\u4e00\u4ef6\u4e8b\u90fd\u6709\u4e9b\u8fdb\u6b65\u610f\u4e49 \u8fd9\u5f53\u7136\u662f\u9650\u4e8e\u5de5\u4f5c\u4e2d\u3002\u6700\u8fd1\u505a\u4e8b\u60c5\u4f1a\u8003\u8651\u628a\u4e00\u4ef6\u4e8b\u505a\u597d\uff0c\u800c\u4e0d\u662f\u8d70\u9a6c\u89c2\u82b1\u3002\u5c24\u5176\u662f\u7b2c\u4e8c\u6b21\u505a\u8fd9\u4ef6\u4e8b\u6216\u7b2c\u4e09\u6b21\u505a\u8fd9\u4ef6\u4e8b\u7684\u65f6\u5019\u3002\u6311\u9009\u4e3b\u6d41\u7684\u5de5\u5177\u5f80\u5f80\u4e0d\u4f1a\u6709\u8fc7\u9519\uff0c\u8981\u628aword\u5b66\u597d\u3002\u5199\u6587\u6863\u6700\u91cd\u8981\u7684\u8fd8\u662f\u6e05\u6670\u8868\u8fbe\uff0c\u8fd9\u5f80\u5f80\u53ef\u4ee5\u901a\u8fc7\u4e00\u5b9a\u7684\u5f62\u5f0f\u6765\u8868\u73b0\u3002\u5f62\u5f0f\u8981\u4e3a\u5185\u5bb9\u670d\u52a1\uff0c\u5e0c\u671b\u5728\u4eca\u540e\u5199\u6587\u6863\u7684\u6e05\u6670\u8868\u8fbe\u4e0a\u80fd\u591a\u4e0b\u529f\u592b\u3002 \u4e0b\u5348\u901b\u897f\u6e56\uff0c\u508d\u665a\u53bb\u8868\u54e5\u5bb6","title":"\u7b2c\u5341\u516d\u5929-\u5468\u516d-3-17"},{"location":"posts/2018-03-28-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E5%8D%81%E5%A4%A9/#-3-18","text":"\u4ece\u8868\u54e5\u5bb6\u56de\u6765\uff0c\u91cd\u65b0\u7ed9\u7535\u8111\u5b89\u88c5\u4e86\u7cfb\u7edf","title":"\u7b2c\u5341\u516d\u5929-\u5468\u65e5-3-18"},{"location":"posts/2018-03-28-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E5%8D%81%E5%A4%A9/#-3-19","text":"\u4ec0\u4e48\u4e5f\u6ca1\u5199\uff0c\u51c6\u5907\u7b2c\u4e8c\u5929\u5f00\u4f1a","title":"\u7b2c\u5341\u4e03\u5929-\u5468\u4e00-3-19"},{"location":"posts/2018-03-28-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E5%8D%81%E5%A4%A9/#-3-20","text":"\u4ec0\u4e48\u4e5f\u6ca1\u5199\uff0c\u8fd9\u4e00\u5929\u5f00\u4f1a","title":"\u7b2c\u5341\u516b\u5929-\u5468\u4e8c-3-20"},{"location":"posts/2018-03-28-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E5%8D%81%E5%A4%A9/#-3-21","text":"\u5199\u5230\uff1a\u4e70\u4e86\u7535\u70ed\u6bef \u5bd2\u6f6e\u6765\u88ad\uff0c\u6c14\u6e29\u9aa4\u964d\u3002\u7ec8\u4e8e\u4e0b\u4e86\u51b3\u5fc3\u4e70\u4e86\u7535\u70ed\u6bef\u3002\u8fd9\u4e2a\u6708\u5b9e\u5728\u6709\u4e9b\u7834\u8d39\uff0c\u6bcf\u4e00\u5e74\u603b\u6709\u51e0\u4e2a\u6708\u662f\u7834\u8d39\u7684\u3002\u6ca1\u6709\u6536\u5165\uff0c\u53ea\u6709\u652f\u51fa\uff0c\u545c\u547c\uff01\u665a\u4e0a\u7761\u4e86\u4e2a\u6696\u548c\u89c9\u3002","title":"\u7b2c\u5341\u4e5d\u5929-\u5468\u4e09-3-21"},{"location":"posts/2018-03-28-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E5%8D%81%E5%A4%A9/#-3-22","text":"\u5199\u5230\uff1a\u67b6\u6784 \u8fd9\u8f6f\u5de5\u7684\u80fd\u529b\u662f\u4e00\u5b9a\u8981\u57f9\u517b\u7684\u3002\u5177\u4f53\u600e\u4e48\u57f9\u517b\uff0c\u518d\u8bae\u3002","title":"\u7b2c\u4e8c\u5341\u5929-\u5468\u56db-3-22"},{"location":"posts/2018-03-28-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E5%8D%81%E5%A4%A9/#-3-23","text":"\u5199\u5230\uff1a\u6587\u732e\u68c0\u7d22 \u53c8\u5f00\u59cb\u505a\u4e86\u4e00\u4ef6\u964c\u751f\u7684\u4e8b\u60c5\uff0c\u5e0c\u671b\u80fd\u6709\u70b9\u6210\u679c\u3002","title":"\u7b2c\u4e8c\u5341\u4e00\u5929-\u5468\u4e94-3-23"},{"location":"posts/2018-03-28-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E5%8D%81%E5%A4%A9/#-3-24","text":"\u4e0eW\u541b\u901b\u5357\u5b8b\u5fa1\u8857\u548c\u6cb3\u574a\u8857\uff0c\u7545\u804a\u3002","title":"\u7b2c\u4e8c\u5341\u4e8c\u5929-\u5468\u516d-3-24"},{"location":"posts/2018-03-28-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E5%8D%81%E5%A4%A9/#-3-25","text":"\u4ec0\u4e48\u4e5f\u6ca1\u5199","title":"\u7b2c\u4e8c\u5341\u4e09\u5929-\u5468\u65e5-3-25"},{"location":"posts/2018-03-28-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E5%8D%81%E5%A4%A9/#-3-26","text":"\u6d88\u5931\u7684\u4e00\u5929","title":"\u7b2c\u4e8c\u5341\u56db\u5929-\u5468\u4e00-3-26"},{"location":"posts/2018-03-28-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E5%8D%81%E5%A4%A9/#-3-27","text":"\u5199\u5230\uff1a\u6700\u8fd1\u7684\u65e5\u5b50\u8fc7\u5f97\u592a\u5b89\u9038\uff0c\u53c8\u6709\u4e9b\u6625\u56f0\u3002\u7761\u89c9\u4e0d\u89e3\u4e4f\uff1b\u5e0c\u671b\u65e9\u70b9\u8d77\u5e8a\uff0c\u65e9\u70b9\u56de\u53bb\u3002 \u4eca\u5929\u5f00\u4f1a\u3002","title":"\u7b2c\u4e8c\u5341\u4e94\u5929-\u5468\u4e8c-3-27"},{"location":"posts/2018-03-28-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E5%8D%81%E5%A4%A9/#-3-28","text":"\u4ec0\u4e48\u4e5f\u6ca1\u5199","title":"\u7b2c\u4e8c\u5341\u516d\u5929-\u5468\u4e09-3-28"},{"location":"posts/2018-04-07-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E5%A4%A9/","text":"\u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u4e8c\u5341\u4e03\u5929 \u8fd9\u7bc7\u65e5\u8bb0\u81f3\u672c\u7bc7\u6587\u7ae0\u6b62\uff0c\u53c8\u90fd\u662f\u56de\u5fc6\u6027\u8d28\u7684\u3002\u8fd9\u8bf4\u660e\u8fd9\u4e00\u6bb5\u65f6\u95f4\u5de5\u4f5c\u5916\u7684\u601d\u7eea\u4fbf\u5c11\u4e86\uff0c\u6bd4\u8f83\u6295\u5165\u3002\u867d\u7136\u65e5\u8bb0\u6ca1\u6709\u5929\u5929\u8bb0\uff0c\u4f46\u662f\u8fd9\u5374\u5f88\u771f\u5b9e\u5730\u53cd\u6620\u6211\u7684\u751f\u6d3b\u72b6\u6001\uff0c\u8fd9\u6bb5\u65f6\u95f4\u751f\u6d3b\u5145\u5b9e\uff0c\u5fc3\u7eea\u4ea6\u5e73\u9759\u3002\u8fc7\u53bb\u90fd\u662f\u5199\u672a\u516c\u5f00\u7684\u65e5\u8bb0\uff0c\u5f00\u5fc3\u4e5f\u8bb0\uff0c\u4f24\u5fc3\u4e5f\u8bb0\uff0c\u8fd9\u6b21\u516c\u5f00\u65e5\u8bb0\u4e5f\u662f\u4e00\u6837\u7684\uff0c\u65e2\u7136\u65e0\u5927\u559c\u5927\u60b2\uff0c\u5c31\u4e5f\u6ca1\u4ec0\u4e48\u53ef\u8bb0\u5f55\u7684\u4e86\u3002 \u4e09\u6708\u672b\u56db\u6708\u521d\uff0c\u751f\u6d3b\u5728\u676d\u5dde\u8212\u670d\u5f97\u5f88\uff0c\u9633\u5149\u660e\u5a9a\u65f6\uff0c\u72b9\u5982\u5929\u964d\u6c90\u6d74\uff0c\u65e5\u8f89\u6d78\u5165\u808c\u80a4\uff0c\u50cf\u662f\u725b\u5976\u822c\u67d4\u6ed1\uff1b\u6216\u6709\u9634\u96e8\uff0c\u6c14\u6e29\u7565\u964d\uff0c\u665a\u4e0a\u5374\u4e5f\u51c9\u5f97\u60ec\u610f\uff0c\u547c\u5438\u6e05\u65b0\u5f97\u4f3c\u82b1\u9999\u822c\u6c81\u4eba\u5fc3\u813e\uff0c\u4e5f\u5fae\u51c9\u2014\u2014\u8212\u7545\u5f97\u50cf\u5904\u4e8e\u5c71\u91ce\u8349\u6797\u4e4b\u95f4\uff1b\u518d\u52a0\u4e0a\u5404\u5904\u5f00\u653e\u7684\u8349\u5730\u548c\u5b09\u7b11\u7684\u4eba\u7fa4\uff0c\u5fc3\u60c5\u597d\u6bd4\u5feb\u6d3b\u795e\u4ed9\u4e86\u3002 \u7b2c\u4e8c\u5341\u4e03\u5929-\u5468\u56db-3-29 \u4eca\u5929\u53c8\u662f\u6d88\u5931\u7684\u4e00\u5929\uff0c\u4e0d\u77e5\u9053\u5728\u5e72\u4ec0\u4e48\uff0c\u7b14\u8bb0\u672c\u4e0a\u65e0\u4efb\u4f55\u75d5\u8ff9 \u7b2c\u4e8c\u5341\u516b\u5929-\u5468\u4e94-3-30 \u770b\u7b14\u8bb0\u4eca\u5929\u8ddf\u5e08\u5144\u8ba8\u8bba\u4e86\u4e00\u4e0b\u8bfe\u9898 \u7b2c\u4e8c\u5341\u4e5d\u5929-\u5468\u516d-3-31 \u5b9e\u9a8c\u5ba4\u7ec4\u7ec7\u722c\u8001\u548c\u5c71\u3002\u7531\u6d59\u5927\u6821\u533a\u897f\u4fa7\u8001\u548c\u5c71\u4e1c\u9e93\u800c\u4e0a\uff0c\u8fc7\u7f8e\u5973\u5c71\u3001\u5317\u9ad8\u5cf0\uff0c\u6cbf\u5c0f\u8def\u4e0b\u5c71\u5230\u6cd5\u559c\u5bfa\u3002\u540e\u5728\u7075\u9690\u516c\u4ea4\u7ad9\u9644\u8fd1\u5403\u996d\u3002\u4eca\u5929\u8d70\u4e862\u4e07\u591a\u6b65\uff0c\u4e0d\u8fc7\u8fd8\u662f\u6ca1\u6709\u62ff\u5230\u7b2c\u4e00\u540d\u3002 \u7b2c\u4e09\u5341\u5929-\u5468\u65e5-4-1 \u8fd9\u8ba1\u7b97\u80fd\u529b\u56f0\u6270\u6211\u5f88\u4e45\uff0c\u4e3a\u4ec0\u4e48\u81ea\u5df1\u8fde\u4e00\u4e2a\u62d6\u5f0f\u90fd\u7b97\u4e0d\u660e\u767d\uff1f\u60f3\u60f3\u5927\u6982\u662f\u601d\u7ef4\u7684\u95ee\u9898\uff0c\u4e0d\u77e5\u9053\u4ec0\u4e48\u65f6\u5019\u81ea\u5df1\u5c31\u6709\u4e9b\u4e0d\u9002\u5408\u8003\u8651\u7ec6\u8282\uff0c\u800c\u662f\u559c\u6b22\u7ffb\u7ffb\u5730\u6982\u62ec\uff0c\u60f3\u5feb\u901f\u5b66\u4e60\u3002\u516c\u5f0f\u4e0d\u8981\u7528\u9519\u662f\u9996\u8981\u7684\uff0c\u5176\u6b21\u5c31\u662f\u6284\u5199\u548c\u8ba1\u7b97\u8981\u5206\u5f00\uff0c\u5426\u5219\u5f88\u96be\u987e\u53ca\u6240\u6709\u65b9\u9762\u3002\u4eca\u5929\u53c8\u91cd\u65b0\u5f00\u59cb\u5ba1\u89c6\u81ea\u5df1\u7684\u65e5\u7a0b\u8868\uff0c\u5e0c\u671b\u6bcf\u5929\u53ef\u4ee5\u770b\u4e00\u4e9b\u7b97\u6cd5\u548c\u6570\u5b66\u5efa\u6a21\uff1b\u4e5f\u5e0c\u671b\u6bcf\u5468\u6709\u4e00\u5b9a\u7684\u8fd0\u52a8\u548c\u4f11\u606f\u3002 \u7b2c\u4e09\u5341\u4e00\u5929-\u5468\u4e00-4-2 \u5199\u62a5\u544a \u7b2c\u4e09\u5341\u4e8c\u5929-\u5468\u4e8c-4-3 \u5f00\u4f1a\uff0c\u8ba4\u4e3a\u591a\u4eba\u534f\u4f5c\u5185\u5bb9\u5206\u6563\u4e0d\u96c6\u4e2d\uff0c\u8001\u5e08\u63d0\u4e86\u65b0\u7684\u8bfe\u9898\u3002 \u53bb\u9752\u4e4b\u575e\u5403\u9ebb\u8fa3\u70eb\uff0c\u4e0d\u591f\u8fa3\uff01\u4e0d\u8fc7\u5929\u6c14\u591f\u70ed\uff0c\u6c57\u6d41\u5939\u80cc\uff01 \u7b2c\u4e09\u5341\u4e09\u5929-\u5468\u4e09-4-4 \u770b\u8bba\u6587\uff0c\u8ba8\u8bba \u7b2c\u4e09\u5341\u56db\u5929-\u5468\u56db-4-5 \u770b\u8bba\u6587\uff0c\u8ba8\u8bba \u7b2c\u4e09\u5341\u4e94\u5929-\u5468\u4e94-4-6 \u5b9e\u9a8c\u5ba4\u7ec4\u7ec7\u53bb\u897f\u6eaa\u6e7f\u5730\u82b1\u671d\u8282\uff0c\u6211\u4eec\u4fbf\u7528\u652f\u4ed8\u5b9d\u8bc6\u82b1\u7684\u529f\u80fd\u201c\u8d4f\u73a9\u201d\u4e86\u4e00\u8def\uff0c\u54c8\u54c8\uff0c\u4e0d\u4ea6\u4e50\u4e4e\u3002\u540e\u53bb\u897f\u6eaa\u535a\u7269\u9986\uff0c\u6bd5\uff0c\u51fa\u6765\u5403\u996d\u3002\u56de\uff0c\u547c\u547c\u5927\u776114\u5c0f\u65f6\uff0c\u79ef\u4e4f\u96be\u89e3\uff0c\u552f\u6709\u7761\u89c9\uff01 \u8bf4\u8d77\u8d4f\u82b1\uff0c\u81ea\u5df1\u8fd8\u662f\u4f24\u611f\u5f97\u591a\uff0c\u5c24\u5176\u662f\u6843\u82b1\u6597\u8273\u4e4b\u65f6\uff0c\u5f80\u4e8b\u4fbf\u6d8c\u4e0a\u5fc3\u5934 \u53bb\u5e74\u4eca\u65e5\u6b64\u95e8\u4e2d\uff0c\u4eba\u9762\u6843\u82b1\u76f8\u5e94\u7ea2 \u4eba\u9762\u4e0d\u77e5\u4f55\u5904\u53bb\uff0c\u6843\u82b1\u4f9d\u65e7\u7b11\u6625\u98ce \u5c31\u8ba9\u5f80\u4e8b\u968f\u98ce\u90fd\u53bb\u4e86\u5427\uff01 \u7b2c\u4e09\u5341\u516d\u5929-\u5468\u516d-4-7 \u7b2c\u4e00\u6b21\u53c2\u52a0\u5b66\u672f\u4f1a\u8bae\uff01\u5168\u7a0b\u90fd\u8ddf\u4e86\u4e0b\u6765\uff0c\u867d\u7136\u6709\u9694\u884c\u5982\u9694\u5c71\u611f\u89c9\uff0c\u4f46\u662f\u4e5f\u662f\u5927\u5f00\u773c\u754c\uff01","title":"\u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u4e8c\u5341\u4e03\u5929"},{"location":"posts/2018-04-07-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E5%A4%A9/#100-","text":"\u8fd9\u7bc7\u65e5\u8bb0\u81f3\u672c\u7bc7\u6587\u7ae0\u6b62\uff0c\u53c8\u90fd\u662f\u56de\u5fc6\u6027\u8d28\u7684\u3002\u8fd9\u8bf4\u660e\u8fd9\u4e00\u6bb5\u65f6\u95f4\u5de5\u4f5c\u5916\u7684\u601d\u7eea\u4fbf\u5c11\u4e86\uff0c\u6bd4\u8f83\u6295\u5165\u3002\u867d\u7136\u65e5\u8bb0\u6ca1\u6709\u5929\u5929\u8bb0\uff0c\u4f46\u662f\u8fd9\u5374\u5f88\u771f\u5b9e\u5730\u53cd\u6620\u6211\u7684\u751f\u6d3b\u72b6\u6001\uff0c\u8fd9\u6bb5\u65f6\u95f4\u751f\u6d3b\u5145\u5b9e\uff0c\u5fc3\u7eea\u4ea6\u5e73\u9759\u3002\u8fc7\u53bb\u90fd\u662f\u5199\u672a\u516c\u5f00\u7684\u65e5\u8bb0\uff0c\u5f00\u5fc3\u4e5f\u8bb0\uff0c\u4f24\u5fc3\u4e5f\u8bb0\uff0c\u8fd9\u6b21\u516c\u5f00\u65e5\u8bb0\u4e5f\u662f\u4e00\u6837\u7684\uff0c\u65e2\u7136\u65e0\u5927\u559c\u5927\u60b2\uff0c\u5c31\u4e5f\u6ca1\u4ec0\u4e48\u53ef\u8bb0\u5f55\u7684\u4e86\u3002 \u4e09\u6708\u672b\u56db\u6708\u521d\uff0c\u751f\u6d3b\u5728\u676d\u5dde\u8212\u670d\u5f97\u5f88\uff0c\u9633\u5149\u660e\u5a9a\u65f6\uff0c\u72b9\u5982\u5929\u964d\u6c90\u6d74\uff0c\u65e5\u8f89\u6d78\u5165\u808c\u80a4\uff0c\u50cf\u662f\u725b\u5976\u822c\u67d4\u6ed1\uff1b\u6216\u6709\u9634\u96e8\uff0c\u6c14\u6e29\u7565\u964d\uff0c\u665a\u4e0a\u5374\u4e5f\u51c9\u5f97\u60ec\u610f\uff0c\u547c\u5438\u6e05\u65b0\u5f97\u4f3c\u82b1\u9999\u822c\u6c81\u4eba\u5fc3\u813e\uff0c\u4e5f\u5fae\u51c9\u2014\u2014\u8212\u7545\u5f97\u50cf\u5904\u4e8e\u5c71\u91ce\u8349\u6797\u4e4b\u95f4\uff1b\u518d\u52a0\u4e0a\u5404\u5904\u5f00\u653e\u7684\u8349\u5730\u548c\u5b09\u7b11\u7684\u4eba\u7fa4\uff0c\u5fc3\u60c5\u597d\u6bd4\u5feb\u6d3b\u795e\u4ed9\u4e86\u3002","title":"\u5728\u676d\u5dde\u7684100\u5929-\u7b2c\u4e8c\u5341\u4e03\u5929"},{"location":"posts/2018-04-07-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E5%A4%A9/#-3-29","text":"\u4eca\u5929\u53c8\u662f\u6d88\u5931\u7684\u4e00\u5929\uff0c\u4e0d\u77e5\u9053\u5728\u5e72\u4ec0\u4e48\uff0c\u7b14\u8bb0\u672c\u4e0a\u65e0\u4efb\u4f55\u75d5\u8ff9","title":"\u7b2c\u4e8c\u5341\u4e03\u5929-\u5468\u56db-3-29"},{"location":"posts/2018-04-07-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E5%A4%A9/#-3-30","text":"\u770b\u7b14\u8bb0\u4eca\u5929\u8ddf\u5e08\u5144\u8ba8\u8bba\u4e86\u4e00\u4e0b\u8bfe\u9898","title":"\u7b2c\u4e8c\u5341\u516b\u5929-\u5468\u4e94-3-30"},{"location":"posts/2018-04-07-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E5%A4%A9/#-3-31","text":"\u5b9e\u9a8c\u5ba4\u7ec4\u7ec7\u722c\u8001\u548c\u5c71\u3002\u7531\u6d59\u5927\u6821\u533a\u897f\u4fa7\u8001\u548c\u5c71\u4e1c\u9e93\u800c\u4e0a\uff0c\u8fc7\u7f8e\u5973\u5c71\u3001\u5317\u9ad8\u5cf0\uff0c\u6cbf\u5c0f\u8def\u4e0b\u5c71\u5230\u6cd5\u559c\u5bfa\u3002\u540e\u5728\u7075\u9690\u516c\u4ea4\u7ad9\u9644\u8fd1\u5403\u996d\u3002\u4eca\u5929\u8d70\u4e862\u4e07\u591a\u6b65\uff0c\u4e0d\u8fc7\u8fd8\u662f\u6ca1\u6709\u62ff\u5230\u7b2c\u4e00\u540d\u3002","title":"\u7b2c\u4e8c\u5341\u4e5d\u5929-\u5468\u516d-3-31"},{"location":"posts/2018-04-07-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E5%A4%A9/#-4-1","text":"\u8fd9\u8ba1\u7b97\u80fd\u529b\u56f0\u6270\u6211\u5f88\u4e45\uff0c\u4e3a\u4ec0\u4e48\u81ea\u5df1\u8fde\u4e00\u4e2a\u62d6\u5f0f\u90fd\u7b97\u4e0d\u660e\u767d\uff1f\u60f3\u60f3\u5927\u6982\u662f\u601d\u7ef4\u7684\u95ee\u9898\uff0c\u4e0d\u77e5\u9053\u4ec0\u4e48\u65f6\u5019\u81ea\u5df1\u5c31\u6709\u4e9b\u4e0d\u9002\u5408\u8003\u8651\u7ec6\u8282\uff0c\u800c\u662f\u559c\u6b22\u7ffb\u7ffb\u5730\u6982\u62ec\uff0c\u60f3\u5feb\u901f\u5b66\u4e60\u3002\u516c\u5f0f\u4e0d\u8981\u7528\u9519\u662f\u9996\u8981\u7684\uff0c\u5176\u6b21\u5c31\u662f\u6284\u5199\u548c\u8ba1\u7b97\u8981\u5206\u5f00\uff0c\u5426\u5219\u5f88\u96be\u987e\u53ca\u6240\u6709\u65b9\u9762\u3002\u4eca\u5929\u53c8\u91cd\u65b0\u5f00\u59cb\u5ba1\u89c6\u81ea\u5df1\u7684\u65e5\u7a0b\u8868\uff0c\u5e0c\u671b\u6bcf\u5929\u53ef\u4ee5\u770b\u4e00\u4e9b\u7b97\u6cd5\u548c\u6570\u5b66\u5efa\u6a21\uff1b\u4e5f\u5e0c\u671b\u6bcf\u5468\u6709\u4e00\u5b9a\u7684\u8fd0\u52a8\u548c\u4f11\u606f\u3002","title":"\u7b2c\u4e09\u5341\u5929-\u5468\u65e5-4-1"},{"location":"posts/2018-04-07-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E5%A4%A9/#-4-2","text":"\u5199\u62a5\u544a","title":"\u7b2c\u4e09\u5341\u4e00\u5929-\u5468\u4e00-4-2"},{"location":"posts/2018-04-07-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E5%A4%A9/#-4-3","text":"\u5f00\u4f1a\uff0c\u8ba4\u4e3a\u591a\u4eba\u534f\u4f5c\u5185\u5bb9\u5206\u6563\u4e0d\u96c6\u4e2d\uff0c\u8001\u5e08\u63d0\u4e86\u65b0\u7684\u8bfe\u9898\u3002 \u53bb\u9752\u4e4b\u575e\u5403\u9ebb\u8fa3\u70eb\uff0c\u4e0d\u591f\u8fa3\uff01\u4e0d\u8fc7\u5929\u6c14\u591f\u70ed\uff0c\u6c57\u6d41\u5939\u80cc\uff01","title":"\u7b2c\u4e09\u5341\u4e8c\u5929-\u5468\u4e8c-4-3"},{"location":"posts/2018-04-07-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E5%A4%A9/#-4-4","text":"\u770b\u8bba\u6587\uff0c\u8ba8\u8bba","title":"\u7b2c\u4e09\u5341\u4e09\u5929-\u5468\u4e09-4-4"},{"location":"posts/2018-04-07-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E5%A4%A9/#-4-5","text":"\u770b\u8bba\u6587\uff0c\u8ba8\u8bba","title":"\u7b2c\u4e09\u5341\u56db\u5929-\u5468\u56db-4-5"},{"location":"posts/2018-04-07-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E5%A4%A9/#-4-6","text":"\u5b9e\u9a8c\u5ba4\u7ec4\u7ec7\u53bb\u897f\u6eaa\u6e7f\u5730\u82b1\u671d\u8282\uff0c\u6211\u4eec\u4fbf\u7528\u652f\u4ed8\u5b9d\u8bc6\u82b1\u7684\u529f\u80fd\u201c\u8d4f\u73a9\u201d\u4e86\u4e00\u8def\uff0c\u54c8\u54c8\uff0c\u4e0d\u4ea6\u4e50\u4e4e\u3002\u540e\u53bb\u897f\u6eaa\u535a\u7269\u9986\uff0c\u6bd5\uff0c\u51fa\u6765\u5403\u996d\u3002\u56de\uff0c\u547c\u547c\u5927\u776114\u5c0f\u65f6\uff0c\u79ef\u4e4f\u96be\u89e3\uff0c\u552f\u6709\u7761\u89c9\uff01 \u8bf4\u8d77\u8d4f\u82b1\uff0c\u81ea\u5df1\u8fd8\u662f\u4f24\u611f\u5f97\u591a\uff0c\u5c24\u5176\u662f\u6843\u82b1\u6597\u8273\u4e4b\u65f6\uff0c\u5f80\u4e8b\u4fbf\u6d8c\u4e0a\u5fc3\u5934 \u53bb\u5e74\u4eca\u65e5\u6b64\u95e8\u4e2d\uff0c\u4eba\u9762\u6843\u82b1\u76f8\u5e94\u7ea2 \u4eba\u9762\u4e0d\u77e5\u4f55\u5904\u53bb\uff0c\u6843\u82b1\u4f9d\u65e7\u7b11\u6625\u98ce \u5c31\u8ba9\u5f80\u4e8b\u968f\u98ce\u90fd\u53bb\u4e86\u5427\uff01","title":"\u7b2c\u4e09\u5341\u4e94\u5929-\u5468\u4e94-4-6"},{"location":"posts/2018-04-07-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E5%A4%A9/#-4-7","text":"\u7b2c\u4e00\u6b21\u53c2\u52a0\u5b66\u672f\u4f1a\u8bae\uff01\u5168\u7a0b\u90fd\u8ddf\u4e86\u4e0b\u6765\uff0c\u867d\u7136\u6709\u9694\u884c\u5982\u9694\u5c71\u611f\u89c9\uff0c\u4f46\u662f\u4e5f\u662f\u5927\u5f00\u773c\u754c\uff01","title":"\u7b2c\u4e09\u5341\u516d\u5929-\u5468\u516d-4-7"},{"location":"posts/2019-11-23-CCS-London-Summary/","text":"Summary of CCS'19 (London) \u8ba1\u7b97\u673a\u548c\u901a\u4fe1\u5b89\u5168\u4f1a\u8bae (ACM Conference on Computer and Communications Security, CCS) \u662f\u5b89\u5168\u9886\u57df\u7684\u8001\u724c\u9876\u7ea7\u56fd\u9645\u4f1a\u8bae\uff0c\u5b83\u4e0eS&P\u3001Usenix Security\u548cNDSS\u5e76\u79f0\u4e3a\u5b89\u5168\u56db\u5927\u4f1a\u3002CCS\u662fSIGSAC\u548c\u7f8e\u56fd\u901a\u4fe1\u534f\u4f1a\u7ec4\u7ec7ACM\u4e3e\u529e\u7684\u5e74\u5ea6\u65d7\u8230\u4f1a\u8bae\uff0c\u5b83\u6c47\u96c6\u4e86\u6765\u81ea\u4e16\u754c\u5404\u5730\u7684\u4fe1\u606f\u5b89\u5168\u7814\u7a76\u4eba\u5458\u3001\u4ece\u4e1a\u4eba\u5458\u3001\u5f00\u53d1\u4eba\u5458\u548c\u7528\u6237, \u63a2\u7d22\u524d\u6cbf\u7684\u60f3\u6cd5\u548c\u7ed3\u679c\u3002CCS 2019\u6765\u5230\u4e86\u6cf0\u6664\u58eb\u6cb3\u7554\u53e4\u8001\u53c8\u73b0\u4ee3\u7684\u4f26\u6566\uff0c\u672c\u6b21CCS\u4f1a\u8bae\u5171\u63a5\u6536\u8bba\u6587149\u7bc7\uff0c\u6db5\u76d6\u4e86\u9690\u79c1\u6570\u636e\u5b89\u5168\u3001\u79fb\u52a8\u5b89\u5168\u3001\u4e91\u5b89\u5168\u3001\u673a\u5668\u5b66\u4e60\u5b89\u5168\u3001\u5bc6\u7801\u5b66\u3001\u53ef\u4fe1\u8ba1\u7b97\u548c\u533a\u5757\u94fe\u5b89\u5168\u7b49\u4e3b\u9898\u3002\u4e09\u5929\u7684main conference\u5171\u5b89\u6392\u4e8650\u4e2asession\u3002\u5176\u4e2d\u5b89\u5168\u8ba1\u7b97\uff08Secure Computation\uff09\u5b89\u6392\u4e865\u4e2asession\uff0c\u533a\u5757\u94fe\u5b89\u5168\uff08Blockchain\uff09\u5b89\u6392\u4e864\u4e2a\uff0c\u673a\u5668\u5b66\u4e60\u5b89\u5168\uff08ML Security\uff09\u548c\u5f62\u5f0f\u5316\u5206\u6790\uff08Formal Analysis\uff09\u5404\u5b89\u6392\u4e863\u4e2a\uff0c\u8fd9\u4e9bsession\u7684\u6570\u91cf\u80fd\u591f\u53cd\u6620\u51fa\u5f53\u4e0b\u8f83\u4e3a\u70ed\u95e8\u7684\u7814\u7a76\u65b9\u5411\u3002\u9664\u4e86main conference\u4e4b\u5916\uff0c\u4f1a\u8bae\u8fd8\u5b89\u6392\u4e86\u76f8\u5173workshop\u3001poster\u548cpanel discussion\u7b49\u73af\u8282\u4f9b\u7814\u7a76\u8005\u4ea4\u6d41\u5176\u4ed6\u7684\u524d\u6cbf\u7814\u7a76\u3002 \u53c2\u52a0\u9876\u4f1a\u8ba9\u6211\u53d7\u76ca\u826f\u591a\u3002\u6211\u7684\u6536\u83b7\u548c\u4f53\u4f1a\u4e3b\u8981\u5f52\u7ed3\u4e3a\u4e24\u4e2a\u95ee\u9898\uff0c\u7b2c\u4e00\u662f\u8bed\u8a00\u95ee\u9898\uff1b\u7b2c\u4e8c\u662f\u201c\u9876\u4f1a\u201d\u3001\u201c\u9876\u7ea7\u7814\u7a76\u201d\u3001\u201c\u9876\u7ea7\u7814\u7a76\u8005\u201d\u548c\u201c\u9876\u7ea7\u7814\u7a76\u673a\u6784\u201d\u771f\u5207\u5730\u51fa\u73b0\u5728\u6211\u9762\u524d\u65f6\u81ea\u5df1\u7684\u601d\u8003\u3002 \u4e2d\u56fd\u5b66\u751f\u7684\u82f1\u8bed\u5b66\u4e60\u5927\u81f4\u5206\u4e3a\u51e0\u4e2a\u9636\u6bb5\uff0c\u5e7c\u513f\u65f6\u7684\u6559\u80b2\u3001\u5c0f\u521d\u65f6\u7684\u6559\u80b2\u3001\u9ad8\u4e2d\u65f6\u7684\u6559\u80b2\u3001\u5927\u5b66\u65f6\u7684\u6559\u80b2\u4ee5\u53ca\u5de5\u4f5c\u4e2d\u7684\u81ea\u6211\u6559\u80b2\u3002\u8bed\u8a00\u5f53\u7136\u662f\u8d8a\u65e9\u5b66\u4e60\u8d8a\u597d\uff0c\u6709\u51e0\u4e2a\u5173\u952e\u7684\u8282\u70b9\u80fd\u8ba9\u4eba\u6709\u663e\u8457\u7684\u63d0\u9ad8\uff0c\u7b2c\u4e00\u662f\u9ad8\u8003\uff0c\u5176\u5bf9\u8bed\u6cd5\u7684\u8bad\u7ec3\u662f\u5173\u952e\u7684\uff0c\u9605\u8bfb\u80fd\u529b\u5df2\u7ecf\u5177\u5907\u3002\u7b2c\u4e8c\u662f\u5927\u5b66\uff0c\u5176\u5bf9\u8bcd\u6c47\u91cf\u7684\u63d0\u9ad8\u662f\u91cd\u8981\u7684\u3002\u5982\u679c\u5728\u5927\u5b66\u671f\u95f4\uff0c\u6709\u65f6\u95f4\u548c\u91d1\u94b1\u62a5\u8003\u96c5\u601d\u3001\u6258\u798f\u548cGRE\uff0c\u90a3\u5bf9\u82f1\u8bed\u7684\u542c\u8bf4\u8bfb\u5199\u4f1a\u6709\u4e00\u4e2a\u8d28\u7684\u63d0\u9ad8\u3002\u7b2c\u4e09\u662f\u5de5\u4f5c\u671f\u95f4\uff0c\u5728\u542c\u529b\u3001\u53e3\u8bed\u4ee5\u53ca\u5199\u4f5c\u4f1a\u6709\u8f83\u5927\u7684\u63d0\u5347\u3002\u4ee5\u4e0a\u7684\u8ba8\u8bba\u9650\u4e8e\u6b63\u5e38\u7684\u8303\u56f4\uff0c\u4e0d\u8003\u8651\u5b66\u751f\u53c2\u52a0\u8865\u4e60\u73ed\u3001\u5bb6\u957f\u662f\u53cc\u8bed\u8005\u6216\u8005\u5b66\u751f\u5728\u56fd\u9645\u5b66\u6821\u4e0a\u5b66\u3002\u5c31\u5b9e\u9645\u7ecf\u9a8c\u800c\u8a00\uff0c\u5728\u53c2\u52a0\u4f1a\u8bae\u8fc7\u7a0b\u4e2d\uff0c\u4e2d\u56fd\u4eba\u8bb2\u7684\u82f1\u8bed\u53ef\u4ee5\u542c\u61c2\uff0c\u82f1\u8bed\u6bcd\u8bed\u8005\u8bb2\u7684\u82f1\u8bed\u53ef\u4ee5\u5927\u81f4\u542c\u660e\u767d\uff0c\u82e5\u662f\u4e00\u4e9b\u53e3\u97f3\u4e25\u91cd\u5730\u533a\u7684\u4eba\u8bb2\u8bdd\uff0c\u6211\u53ef\u5c31\u4e0d\u77e5\u9053\u4ed6\u4eec\u5728\u8bf4\u4e9b\u4ec0\u4e48\u4e86\u3002\u7ed3\u5408\u8fc7\u53bb\u7684\u82f1\u8bed\u5b66\u4e60\u7ecf\u9a8c\uff0c\u548c\u672a\u6765\u7684\u82f1\u8bed\u5199\u4f5c\u9700\u6c42\uff0c\u5728\u7814\u7a76\u751f\u671f\u95f4\uff0c\u81ea\u5df1\u5bf9\u81ea\u5df1\u7684\u82f1\u8bed\u5b66\u4e60\u8fd8\u9700\u4e0a\u5fc3\u3002\u6211\u4eca\u540e\uff0c\u77ed\u671f\u7684\u8ba1\u5212\u4e0a\uff0c\u5e94\u8be5\u5bf9\u542c\u529b\u548c\u8bed\u6cd5\u5f3a\u52a0\u7ec3\u4e60\uff0c\u4ee5\u6ee1\u8db3\u542c\u529b\u548c\u5199\u4f5c\u7684\u9700\u6c42\u3002 \u4ec0\u4e48\u6837\u7684\u7814\u7a76\u673a\u6784\u79f0\u5f97\u4e0a\u9876\u7ea7\u7814\u7a76\u673a\u6784\uff1fCSRanking\u91c7\u7528\u8be5\u7814\u7a76\u673a\u6784\u5728\u8ba1\u7b97\u673a\u79d1\u5b66\u5404\u4e2a\u9886\u57df\u4e2d\u9876\u7ea7\u4f1a\u8bae\u4e0a\u51fa\u73b0\u7684\u6b63\u5f0f\u8bba\u6587\u62166\u9875\u4ee5\u4e0a\u77ed\u6587\u7684\u6570\u91cf\u6765\u786e\u5b9a\u8be5\u7814\u7a76\u673a\u6784\u7684\u6d3b\u8dc3\u6027\uff0c\u6392\u540d\u9760\u524d\u7684\u5219\u88ab\u6210\u4e3a\u9876\u7ea7\u7814\u7a76\u673a\u6784\u3002 \u6b64\u8ba1\u7b97\u9690\u5f0f\u5730\u5f52\u4e00\u5316\u4e86\u5f15\u7528\u6570\u91cf\u548c\u9886\u57df\u5927\u5c0f\uff0c\u89c4\u907f\u4e86\u4eba\u4e3a\u5f15\u7528\u4f5c\u5f0a\u7684\u98ce\u9669\u3002 \u6839\u636e2019\u5e74\u672b\u7684\u6700\u65b0\u7edf\u8ba1\u7ed3\u679c\uff0c\u6d59\u5927\u5728\u8ba1\u7b97\u673a\u5b89\u5168\u9886\u57df\u4e9a\u6d32\u7b2c\u4e8c\uff0c\u4e16\u754c\u7b2c40\u3002CSRanking\u4ee3\u7801\u5f00\u653e\uff0c\u6240\u6709\u4eba\u90fd\u53ef\u4ee5\u68c0\u9a8c\u5176\u7ed3\u679c\uff0c\u8f83\u4e3a\u516c\u5e73\u516c\u6b63\u3002 \u4ec0\u4e48\u6837\u7684\u7814\u7a76\u8005\u79f0\u5f97\u4e0a\u9876\u7ea7\u7814\u7a76\u8005\uff1f\u8fd9\u4e2a\u8981\u770b\u4e00\u4e2a\u7814\u7a76\u8005\u6b63\u5904\u4e8e\u4ec0\u4e48\u9636\u6bb5\u3002\u5982\u679c\u4ed6\u662f\u4e00\u4e2a\u535a\u58eb\u751f\uff0c\u5728\u535a\u58eb\u4e34\u8fd1\u6bd5\u4e1a\u7684\u65f6\u5019\uff0c\u8003\u5bdf\u4ed6\u7684\u7814\u7a76\u662f\u5426\u5177\u6709\u5f00\u521b\u65b0\u3001\u5176\u7814\u7a76\u6210\u679c\u662f\u5426\u4ee3\u8868\u4e86\u8fd9\u4e2a\u7814\u7a76\u9886\u57df\u7684\u6700\u65b0\u8fdb\u5c55\uff0c\u5982\u679c\u7b54\u6848\u90fd\u662f\u80af\u5b9a\u7684\uff0c\u5219\u5176\u79f0\u5f97\u4e0a\u662f\u9876\u7ea7\u7814\u7a76\u8005\u3002\u5728\u5de5\u4f5c\u4e2d\uff0c\u7ba1\u7406\u3001\u670d\u52a1\u548c\u6559\u5b66\u7684\u5de5\u4f5c\u589e\u591a\uff0c\u5982\u679c\u4ed6\u8fd8\u80fd\u4fdd\u8bc1\u5176\u56e2\u961f\u7684\u79d1\u7814\u8d28\u91cf\uff0c\u90a3\u4e48\u4ed6\u4ecd\u7136\u79f0\u5f97\u4e0a\u662f\u9876\u7ea7\u7684\u7814\u7a76\u8005\uff0c\u5426\u5219\u8981\u8003\u8651\u5176\u4ed6\u7684\u56e0\u7d20\u5e26\u6765\u7684\u5f71\u54cd\uff0c\u6216\u4e3a\u9876\u7ea7\u7684\u7ba1\u7406\u8005\u3001\u9876\u7ea7\u7684\u6559\u5e08\u7b49\uff0c\u4e0d\u80fd\u4e00\u76f4\u79f0\u4e4b\u4e3a\u9876\u7ea7\u7684\u7814\u7a76\u8005\u3002 \u4ec0\u4e48\u6837\u7684\u7814\u7a76\u79f0\u5f97\u4e0a\u4e3a\u9876\u7ea7\u7814\u7a76\uff1f\u4ece\u64cd\u4f5c\u4e0a\u770b\uff0c\u53d1\u5230\u9876\u4f1a\u4e0a\u7684\u7814\u7a76\u8ba4\u4e3a\u662f\u9876\u7ea7\u7814\u7a76\u3002\u53c2\u52a0\u8fc7\u9876\u4f1a\u4e4b\u540e\uff0c\u5c24\u5176\u662f\u73b0\u5728\uff0c\u9876\u4f1a\u4e0a\u8bba\u6587\u8d8a\u6765\u8d8a\u591a\uff0c\u95e8\u7c7b\u8d8a\u6765\u8d8a\u591a\uff0c\u90a3\u4e48\u9876\u7ea7\u7684\u7814\u7a76\u8981\u4ece\u201c\u5c0f\u540c\u884c\u201d\u7684\u89d2\u5ea6\u8003\u8651\u3002\u6709\u4e00\u4e9b\u504f\u95e8\u7684\u7814\u7a76\uff0c\u9876\u4f1a\u6536\u4e86\uff0c\u4f46\u662f\u770b\u4e0d\u5230\u5176\u5bf9\u540e\u6765\u7684\u8bba\u6587\u7684\u5f71\u54cd\uff0c\u6216\u8bb8\u5c31\u4e0d\u597d\u8bc4\u4ef7\u5b83\uff0c\u518d\u6216\u8005\u5982\u679c\u5b66\u672f\u59d4\u5458\u4f1a\u4e13\u95e8\u5bf9\u5176\u8fdb\u884c\u8ba8\u8bba\uff0c\u5e76\u58f0\u660e\u5176\u4ef7\u503c\uff0c\u5012\u4e5f\u53ef\u4ee5\u8bf4\u5b83\u662f\u4e00\u4e2a\u9876\u7ea7\u7814\u7a76\u3002\u603b\u4e4b\uff0c\u5982\u679c\u8be5\u7814\u7a76\u5728\u9876\u4f1a\u4e0a\u53d1\u8868\uff0c\u5f00\u521b\u4e86\u65b0\u7684\u7814\u7a76\u65b9\u5411\uff0c\u6216\u5728\u65e2\u6709\u7684\u7814\u7a76\u65b9\u5411\u4e0a\u6709\u7406\u8bba\u3001\u65b9\u6cd5\u7684\u8d21\u732e\uff0c\u6216\u6709\u5168\u9762\u6df1\u523b\u7684\u603b\u7ed3\uff0c\u90fd\u53ef\u4ee5\u79f0\u4e4b\u4e3a\u9876\u7ea7\u7814\u7a76\u3002 \u4ec0\u4e48\u6837\u7684\u7814\u7a76\u79f0\u5f97\u4e0a\u4e3a\u9876\u7ea7\u4f1a\u8bae\uff0c\u8fd9\u4e2a\u95ee\u9898\u5df2\u7ecf\u88ab\u89e3\u51b3\uff0c\u8ba1\u7b97\u673a\u884c\u4e1a\u5df2\u7ecf\u6709\u81ea\u5df1\u7684\u540d\u4e49\u6807\u51c6\uff0c\u800c\u4e14\u653f\u7b56\u4e0a\u5b66\u6821\u4e5f\u4e0d\u4f1a\u963b\u788d\u5404\u4e2a\u5b9e\u9a8c\u5ba4\u7684\u5177\u4f53\u6bd5\u4e1a\u6761\u4ef6\u3002 \u8ba8\u8bba\u4e86\u8fd9\u4e48\u591a\uff0c\u53ef\u7528\u4e00\u53e5\u8bdd\u603b\u7ed3\uff1a\u9769\u547d\u5c1a\u672a\u6210\u529f\uff0c\u540c\u5fd7\u4ecd\u9700\u52aa\u529b\uff01","title":"Summary of CCS'19 (London)"},{"location":"posts/2019-11-23-CCS-London-Summary/#summary-of-ccs19-london","text":"\u8ba1\u7b97\u673a\u548c\u901a\u4fe1\u5b89\u5168\u4f1a\u8bae (ACM Conference on Computer and Communications Security, CCS) \u662f\u5b89\u5168\u9886\u57df\u7684\u8001\u724c\u9876\u7ea7\u56fd\u9645\u4f1a\u8bae\uff0c\u5b83\u4e0eS&P\u3001Usenix Security\u548cNDSS\u5e76\u79f0\u4e3a\u5b89\u5168\u56db\u5927\u4f1a\u3002CCS\u662fSIGSAC\u548c\u7f8e\u56fd\u901a\u4fe1\u534f\u4f1a\u7ec4\u7ec7ACM\u4e3e\u529e\u7684\u5e74\u5ea6\u65d7\u8230\u4f1a\u8bae\uff0c\u5b83\u6c47\u96c6\u4e86\u6765\u81ea\u4e16\u754c\u5404\u5730\u7684\u4fe1\u606f\u5b89\u5168\u7814\u7a76\u4eba\u5458\u3001\u4ece\u4e1a\u4eba\u5458\u3001\u5f00\u53d1\u4eba\u5458\u548c\u7528\u6237, \u63a2\u7d22\u524d\u6cbf\u7684\u60f3\u6cd5\u548c\u7ed3\u679c\u3002CCS 2019\u6765\u5230\u4e86\u6cf0\u6664\u58eb\u6cb3\u7554\u53e4\u8001\u53c8\u73b0\u4ee3\u7684\u4f26\u6566\uff0c\u672c\u6b21CCS\u4f1a\u8bae\u5171\u63a5\u6536\u8bba\u6587149\u7bc7\uff0c\u6db5\u76d6\u4e86\u9690\u79c1\u6570\u636e\u5b89\u5168\u3001\u79fb\u52a8\u5b89\u5168\u3001\u4e91\u5b89\u5168\u3001\u673a\u5668\u5b66\u4e60\u5b89\u5168\u3001\u5bc6\u7801\u5b66\u3001\u53ef\u4fe1\u8ba1\u7b97\u548c\u533a\u5757\u94fe\u5b89\u5168\u7b49\u4e3b\u9898\u3002\u4e09\u5929\u7684main conference\u5171\u5b89\u6392\u4e8650\u4e2asession\u3002\u5176\u4e2d\u5b89\u5168\u8ba1\u7b97\uff08Secure Computation\uff09\u5b89\u6392\u4e865\u4e2asession\uff0c\u533a\u5757\u94fe\u5b89\u5168\uff08Blockchain\uff09\u5b89\u6392\u4e864\u4e2a\uff0c\u673a\u5668\u5b66\u4e60\u5b89\u5168\uff08ML Security\uff09\u548c\u5f62\u5f0f\u5316\u5206\u6790\uff08Formal Analysis\uff09\u5404\u5b89\u6392\u4e863\u4e2a\uff0c\u8fd9\u4e9bsession\u7684\u6570\u91cf\u80fd\u591f\u53cd\u6620\u51fa\u5f53\u4e0b\u8f83\u4e3a\u70ed\u95e8\u7684\u7814\u7a76\u65b9\u5411\u3002\u9664\u4e86main conference\u4e4b\u5916\uff0c\u4f1a\u8bae\u8fd8\u5b89\u6392\u4e86\u76f8\u5173workshop\u3001poster\u548cpanel discussion\u7b49\u73af\u8282\u4f9b\u7814\u7a76\u8005\u4ea4\u6d41\u5176\u4ed6\u7684\u524d\u6cbf\u7814\u7a76\u3002 \u53c2\u52a0\u9876\u4f1a\u8ba9\u6211\u53d7\u76ca\u826f\u591a\u3002\u6211\u7684\u6536\u83b7\u548c\u4f53\u4f1a\u4e3b\u8981\u5f52\u7ed3\u4e3a\u4e24\u4e2a\u95ee\u9898\uff0c\u7b2c\u4e00\u662f\u8bed\u8a00\u95ee\u9898\uff1b\u7b2c\u4e8c\u662f\u201c\u9876\u4f1a\u201d\u3001\u201c\u9876\u7ea7\u7814\u7a76\u201d\u3001\u201c\u9876\u7ea7\u7814\u7a76\u8005\u201d\u548c\u201c\u9876\u7ea7\u7814\u7a76\u673a\u6784\u201d\u771f\u5207\u5730\u51fa\u73b0\u5728\u6211\u9762\u524d\u65f6\u81ea\u5df1\u7684\u601d\u8003\u3002 \u4e2d\u56fd\u5b66\u751f\u7684\u82f1\u8bed\u5b66\u4e60\u5927\u81f4\u5206\u4e3a\u51e0\u4e2a\u9636\u6bb5\uff0c\u5e7c\u513f\u65f6\u7684\u6559\u80b2\u3001\u5c0f\u521d\u65f6\u7684\u6559\u80b2\u3001\u9ad8\u4e2d\u65f6\u7684\u6559\u80b2\u3001\u5927\u5b66\u65f6\u7684\u6559\u80b2\u4ee5\u53ca\u5de5\u4f5c\u4e2d\u7684\u81ea\u6211\u6559\u80b2\u3002\u8bed\u8a00\u5f53\u7136\u662f\u8d8a\u65e9\u5b66\u4e60\u8d8a\u597d\uff0c\u6709\u51e0\u4e2a\u5173\u952e\u7684\u8282\u70b9\u80fd\u8ba9\u4eba\u6709\u663e\u8457\u7684\u63d0\u9ad8\uff0c\u7b2c\u4e00\u662f\u9ad8\u8003\uff0c\u5176\u5bf9\u8bed\u6cd5\u7684\u8bad\u7ec3\u662f\u5173\u952e\u7684\uff0c\u9605\u8bfb\u80fd\u529b\u5df2\u7ecf\u5177\u5907\u3002\u7b2c\u4e8c\u662f\u5927\u5b66\uff0c\u5176\u5bf9\u8bcd\u6c47\u91cf\u7684\u63d0\u9ad8\u662f\u91cd\u8981\u7684\u3002\u5982\u679c\u5728\u5927\u5b66\u671f\u95f4\uff0c\u6709\u65f6\u95f4\u548c\u91d1\u94b1\u62a5\u8003\u96c5\u601d\u3001\u6258\u798f\u548cGRE\uff0c\u90a3\u5bf9\u82f1\u8bed\u7684\u542c\u8bf4\u8bfb\u5199\u4f1a\u6709\u4e00\u4e2a\u8d28\u7684\u63d0\u9ad8\u3002\u7b2c\u4e09\u662f\u5de5\u4f5c\u671f\u95f4\uff0c\u5728\u542c\u529b\u3001\u53e3\u8bed\u4ee5\u53ca\u5199\u4f5c\u4f1a\u6709\u8f83\u5927\u7684\u63d0\u5347\u3002\u4ee5\u4e0a\u7684\u8ba8\u8bba\u9650\u4e8e\u6b63\u5e38\u7684\u8303\u56f4\uff0c\u4e0d\u8003\u8651\u5b66\u751f\u53c2\u52a0\u8865\u4e60\u73ed\u3001\u5bb6\u957f\u662f\u53cc\u8bed\u8005\u6216\u8005\u5b66\u751f\u5728\u56fd\u9645\u5b66\u6821\u4e0a\u5b66\u3002\u5c31\u5b9e\u9645\u7ecf\u9a8c\u800c\u8a00\uff0c\u5728\u53c2\u52a0\u4f1a\u8bae\u8fc7\u7a0b\u4e2d\uff0c\u4e2d\u56fd\u4eba\u8bb2\u7684\u82f1\u8bed\u53ef\u4ee5\u542c\u61c2\uff0c\u82f1\u8bed\u6bcd\u8bed\u8005\u8bb2\u7684\u82f1\u8bed\u53ef\u4ee5\u5927\u81f4\u542c\u660e\u767d\uff0c\u82e5\u662f\u4e00\u4e9b\u53e3\u97f3\u4e25\u91cd\u5730\u533a\u7684\u4eba\u8bb2\u8bdd\uff0c\u6211\u53ef\u5c31\u4e0d\u77e5\u9053\u4ed6\u4eec\u5728\u8bf4\u4e9b\u4ec0\u4e48\u4e86\u3002\u7ed3\u5408\u8fc7\u53bb\u7684\u82f1\u8bed\u5b66\u4e60\u7ecf\u9a8c\uff0c\u548c\u672a\u6765\u7684\u82f1\u8bed\u5199\u4f5c\u9700\u6c42\uff0c\u5728\u7814\u7a76\u751f\u671f\u95f4\uff0c\u81ea\u5df1\u5bf9\u81ea\u5df1\u7684\u82f1\u8bed\u5b66\u4e60\u8fd8\u9700\u4e0a\u5fc3\u3002\u6211\u4eca\u540e\uff0c\u77ed\u671f\u7684\u8ba1\u5212\u4e0a\uff0c\u5e94\u8be5\u5bf9\u542c\u529b\u548c\u8bed\u6cd5\u5f3a\u52a0\u7ec3\u4e60\uff0c\u4ee5\u6ee1\u8db3\u542c\u529b\u548c\u5199\u4f5c\u7684\u9700\u6c42\u3002 \u4ec0\u4e48\u6837\u7684\u7814\u7a76\u673a\u6784\u79f0\u5f97\u4e0a\u9876\u7ea7\u7814\u7a76\u673a\u6784\uff1fCSRanking\u91c7\u7528\u8be5\u7814\u7a76\u673a\u6784\u5728\u8ba1\u7b97\u673a\u79d1\u5b66\u5404\u4e2a\u9886\u57df\u4e2d\u9876\u7ea7\u4f1a\u8bae\u4e0a\u51fa\u73b0\u7684\u6b63\u5f0f\u8bba\u6587\u62166\u9875\u4ee5\u4e0a\u77ed\u6587\u7684\u6570\u91cf\u6765\u786e\u5b9a\u8be5\u7814\u7a76\u673a\u6784\u7684\u6d3b\u8dc3\u6027\uff0c\u6392\u540d\u9760\u524d\u7684\u5219\u88ab\u6210\u4e3a\u9876\u7ea7\u7814\u7a76\u673a\u6784\u3002 \u6b64\u8ba1\u7b97\u9690\u5f0f\u5730\u5f52\u4e00\u5316\u4e86\u5f15\u7528\u6570\u91cf\u548c\u9886\u57df\u5927\u5c0f\uff0c\u89c4\u907f\u4e86\u4eba\u4e3a\u5f15\u7528\u4f5c\u5f0a\u7684\u98ce\u9669\u3002 \u6839\u636e2019\u5e74\u672b\u7684\u6700\u65b0\u7edf\u8ba1\u7ed3\u679c\uff0c\u6d59\u5927\u5728\u8ba1\u7b97\u673a\u5b89\u5168\u9886\u57df\u4e9a\u6d32\u7b2c\u4e8c\uff0c\u4e16\u754c\u7b2c40\u3002CSRanking\u4ee3\u7801\u5f00\u653e\uff0c\u6240\u6709\u4eba\u90fd\u53ef\u4ee5\u68c0\u9a8c\u5176\u7ed3\u679c\uff0c\u8f83\u4e3a\u516c\u5e73\u516c\u6b63\u3002 \u4ec0\u4e48\u6837\u7684\u7814\u7a76\u8005\u79f0\u5f97\u4e0a\u9876\u7ea7\u7814\u7a76\u8005\uff1f\u8fd9\u4e2a\u8981\u770b\u4e00\u4e2a\u7814\u7a76\u8005\u6b63\u5904\u4e8e\u4ec0\u4e48\u9636\u6bb5\u3002\u5982\u679c\u4ed6\u662f\u4e00\u4e2a\u535a\u58eb\u751f\uff0c\u5728\u535a\u58eb\u4e34\u8fd1\u6bd5\u4e1a\u7684\u65f6\u5019\uff0c\u8003\u5bdf\u4ed6\u7684\u7814\u7a76\u662f\u5426\u5177\u6709\u5f00\u521b\u65b0\u3001\u5176\u7814\u7a76\u6210\u679c\u662f\u5426\u4ee3\u8868\u4e86\u8fd9\u4e2a\u7814\u7a76\u9886\u57df\u7684\u6700\u65b0\u8fdb\u5c55\uff0c\u5982\u679c\u7b54\u6848\u90fd\u662f\u80af\u5b9a\u7684\uff0c\u5219\u5176\u79f0\u5f97\u4e0a\u662f\u9876\u7ea7\u7814\u7a76\u8005\u3002\u5728\u5de5\u4f5c\u4e2d\uff0c\u7ba1\u7406\u3001\u670d\u52a1\u548c\u6559\u5b66\u7684\u5de5\u4f5c\u589e\u591a\uff0c\u5982\u679c\u4ed6\u8fd8\u80fd\u4fdd\u8bc1\u5176\u56e2\u961f\u7684\u79d1\u7814\u8d28\u91cf\uff0c\u90a3\u4e48\u4ed6\u4ecd\u7136\u79f0\u5f97\u4e0a\u662f\u9876\u7ea7\u7684\u7814\u7a76\u8005\uff0c\u5426\u5219\u8981\u8003\u8651\u5176\u4ed6\u7684\u56e0\u7d20\u5e26\u6765\u7684\u5f71\u54cd\uff0c\u6216\u4e3a\u9876\u7ea7\u7684\u7ba1\u7406\u8005\u3001\u9876\u7ea7\u7684\u6559\u5e08\u7b49\uff0c\u4e0d\u80fd\u4e00\u76f4\u79f0\u4e4b\u4e3a\u9876\u7ea7\u7684\u7814\u7a76\u8005\u3002 \u4ec0\u4e48\u6837\u7684\u7814\u7a76\u79f0\u5f97\u4e0a\u4e3a\u9876\u7ea7\u7814\u7a76\uff1f\u4ece\u64cd\u4f5c\u4e0a\u770b\uff0c\u53d1\u5230\u9876\u4f1a\u4e0a\u7684\u7814\u7a76\u8ba4\u4e3a\u662f\u9876\u7ea7\u7814\u7a76\u3002\u53c2\u52a0\u8fc7\u9876\u4f1a\u4e4b\u540e\uff0c\u5c24\u5176\u662f\u73b0\u5728\uff0c\u9876\u4f1a\u4e0a\u8bba\u6587\u8d8a\u6765\u8d8a\u591a\uff0c\u95e8\u7c7b\u8d8a\u6765\u8d8a\u591a\uff0c\u90a3\u4e48\u9876\u7ea7\u7684\u7814\u7a76\u8981\u4ece\u201c\u5c0f\u540c\u884c\u201d\u7684\u89d2\u5ea6\u8003\u8651\u3002\u6709\u4e00\u4e9b\u504f\u95e8\u7684\u7814\u7a76\uff0c\u9876\u4f1a\u6536\u4e86\uff0c\u4f46\u662f\u770b\u4e0d\u5230\u5176\u5bf9\u540e\u6765\u7684\u8bba\u6587\u7684\u5f71\u54cd\uff0c\u6216\u8bb8\u5c31\u4e0d\u597d\u8bc4\u4ef7\u5b83\uff0c\u518d\u6216\u8005\u5982\u679c\u5b66\u672f\u59d4\u5458\u4f1a\u4e13\u95e8\u5bf9\u5176\u8fdb\u884c\u8ba8\u8bba\uff0c\u5e76\u58f0\u660e\u5176\u4ef7\u503c\uff0c\u5012\u4e5f\u53ef\u4ee5\u8bf4\u5b83\u662f\u4e00\u4e2a\u9876\u7ea7\u7814\u7a76\u3002\u603b\u4e4b\uff0c\u5982\u679c\u8be5\u7814\u7a76\u5728\u9876\u4f1a\u4e0a\u53d1\u8868\uff0c\u5f00\u521b\u4e86\u65b0\u7684\u7814\u7a76\u65b9\u5411\uff0c\u6216\u5728\u65e2\u6709\u7684\u7814\u7a76\u65b9\u5411\u4e0a\u6709\u7406\u8bba\u3001\u65b9\u6cd5\u7684\u8d21\u732e\uff0c\u6216\u6709\u5168\u9762\u6df1\u523b\u7684\u603b\u7ed3\uff0c\u90fd\u53ef\u4ee5\u79f0\u4e4b\u4e3a\u9876\u7ea7\u7814\u7a76\u3002 \u4ec0\u4e48\u6837\u7684\u7814\u7a76\u79f0\u5f97\u4e0a\u4e3a\u9876\u7ea7\u4f1a\u8bae\uff0c\u8fd9\u4e2a\u95ee\u9898\u5df2\u7ecf\u88ab\u89e3\u51b3\uff0c\u8ba1\u7b97\u673a\u884c\u4e1a\u5df2\u7ecf\u6709\u81ea\u5df1\u7684\u540d\u4e49\u6807\u51c6\uff0c\u800c\u4e14\u653f\u7b56\u4e0a\u5b66\u6821\u4e5f\u4e0d\u4f1a\u963b\u788d\u5404\u4e2a\u5b9e\u9a8c\u5ba4\u7684\u5177\u4f53\u6bd5\u4e1a\u6761\u4ef6\u3002 \u8ba8\u8bba\u4e86\u8fd9\u4e48\u591a\uff0c\u53ef\u7528\u4e00\u53e5\u8bdd\u603b\u7ed3\uff1a\u9769\u547d\u5c1a\u672a\u6210\u529f\uff0c\u540c\u5fd7\u4ecd\u9700\u52aa\u529b\uff01","title":"Summary of CCS'19 (London)"},{"location":"posts/2020-11-18-buildroot-qemu-x86_64/","text":"Buildroot, QEMU and Linux kernel for x86_64 Usually, we need a dynamic analysis platform for a Linux kernel for x86_64. The direct idea is to run a Linux kernel on QEMU. In this post, I will introduce how to quickly build such a platform with Buildroot. Download Buildroot Please go here to download the latest Buildroot package and decompress it. [Optional] Prepare Kernel Module Usually, we write a Linux kernel module to test some features. Leveraging Buildroot, it is quite easy to achieve that. Please refer to this post as the original post. I fixed two typos only. Skip this section if you don't need a kernel module. Create several files like this. ``` txt kernel_module/ \u251c\u2500\u2500 Config.in \u251c\u2500\u2500 Makefile \u251c\u2500\u2500 external.desc \u251c\u2500\u2500 external.mk \u2514\u2500\u2500 hello.c 0 directories, 5 file ``` Config.in Note that each line should start with a tab. txt config BR2_PACKAGE_KERNEL_MODULE bool \"kernel_module\" depends on BR2_LINUX_KERNEL help Linux Kernel Module Cheat. Makefile ``` Makefile obj-m += $(addsuffix .o, $(notdir $(basename $(wildcard $(BR2_EXTERNAL_KERNEL_MODULES_PATH)/*.c)))) ccflags-y := -DDEBUG -g -std=gnu99 -Wno-declaration-after-statement .PHONY: all clean all: $(MAKE) -C '$(LINUX_DIR)' M='$(PWD)' modules clean: $(MAKE) -C '$(LINUX_DIR)' M='$(PWD)' clean ``` external.desc Please look at this for more information. txt name: KERNEL_MODULES external.mk ``` Makefile kernel_module KERNEL_MODULE_VERSION = 1.0 KERNEL_MODULE_SITE = $(BR2_EXTERNAL_KERNEL_MODULES_PATH) KERNEL_MODULE_SITE_METHOD = local KERNEL_MODULE_LINUX_LICENSE = GPL-2.0 KERNEL_MODULE_LINUX_LICENSE_FILES = COPYING $(eval $(kernel-module)) $(eval $(generic-package)) ``` hello.c ``` c include include MODULE_LICENSE(\"GPL\"); static int myinit(void) { printk(KERN_INFO \"hello init\\n\"); return 0; } static void myexit(void) { printk(KERN_INFO \"hello exit\\n\"); } module_init(myinit) module_exit(myexit) ``` The change is from BR2_EXTERNAL_KERNEL_MODULE_PATH to BR2_EXTERNAL_KERNEL_MODULES_PATH . Compile Buildroot The several components are arranged like below. . \u251c\u2500\u2500 buildroot-2020.02.8 \u2514\u2500\u2500 kernel_module Go to buildroot If no kernel module, just make qemu_x86_64_defconfig , otherwise, make BR2_EXTERNAL=\"$(pwd)/../kernel_module\" qemu_x86_64_defconfig Before going on, we should update the C libary and the tty target by make menuconfig . Toolchain -> C library -> glibc System Configuration -> Run a getty (login prompt) after boot -> TTY port -> ttyS0 [Optional] We can enable lspci -v to show more information on PCI devices. Target Packages -> Hardware Handling -> pciutils If any kernel module, echo 'BR2_PACKAGE_KERNEL_MODULE=y' >> .config make with -jN to accelerate your compilation. Launch all of them qemu-system-x86_64 \\ -M pc \\ -kernel ./output/images/bzImage \\ -drive file=./output/images/rootfs.ext2,if=virtio,format=raw \\ -append \"root=/dev/vda console=ttyS0\" \\ -net nic,model=virtio -net user \\ -nographic If there exists a Linux kernel module, please do as follow. $ modprobe hello hello: loading out-of-tree module taints kernel. hello init $ desg ... hello: loading out-of-tree module taints kernel. hello init Reference buildroot\u7f16\u8bd1\u8fd0\u884cQEMU X86_64 How to add a linux kernel driver module as a buildroot package \\ [^cve-2020-14364]: An out-of-bounds read/write access flaw was found in the USB emulator of the QEMU in versions before 5.2.0. This issue occurs while processing USB packets from a guest when USBDevice setup_len exceeds its data_buf[4096] in the do_token_in , do_token_out routines. This flaw allows a guest user to crash the QEMU process, resulting in a denial of service, or the potential execution of arbitrary code with the privileges of the QEMU process on the host .","title":"Buildroot, QEMU and Linux kernel for x86_64"},{"location":"posts/2020-11-18-buildroot-qemu-x86_64/#buildroot-qemu-and-linux-kernel-for-x86_64","text":"Usually, we need a dynamic analysis platform for a Linux kernel for x86_64. The direct idea is to run a Linux kernel on QEMU. In this post, I will introduce how to quickly build such a platform with Buildroot.","title":"Buildroot, QEMU and Linux kernel for x86_64"},{"location":"posts/2020-11-18-buildroot-qemu-x86_64/#download-buildroot","text":"Please go here to download the latest Buildroot package and decompress it.","title":"Download Buildroot"},{"location":"posts/2020-11-18-buildroot-qemu-x86_64/#optional-prepare-kernel-module","text":"Usually, we write a Linux kernel module to test some features. Leveraging Buildroot, it is quite easy to achieve that. Please refer to this post as the original post. I fixed two typos only. Skip this section if you don't need a kernel module. Create several files like this. ``` txt kernel_module/ \u251c\u2500\u2500 Config.in \u251c\u2500\u2500 Makefile \u251c\u2500\u2500 external.desc \u251c\u2500\u2500 external.mk \u2514\u2500\u2500 hello.c 0 directories, 5 file ``` Config.in Note that each line should start with a tab. txt config BR2_PACKAGE_KERNEL_MODULE bool \"kernel_module\" depends on BR2_LINUX_KERNEL help Linux Kernel Module Cheat. Makefile ``` Makefile obj-m += $(addsuffix .o, $(notdir $(basename $(wildcard $(BR2_EXTERNAL_KERNEL_MODULES_PATH)/*.c)))) ccflags-y := -DDEBUG -g -std=gnu99 -Wno-declaration-after-statement .PHONY: all clean all: $(MAKE) -C '$(LINUX_DIR)' M='$(PWD)' modules clean: $(MAKE) -C '$(LINUX_DIR)' M='$(PWD)' clean ``` external.desc Please look at this for more information. txt name: KERNEL_MODULES external.mk ``` Makefile","title":"[Optional] Prepare Kernel Module"},{"location":"posts/2020-11-18-buildroot-qemu-x86_64/#_1","text":"","title":""},{"location":"posts/2020-11-18-buildroot-qemu-x86_64/#_2","text":"","title":""},{"location":"posts/2020-11-18-buildroot-qemu-x86_64/#kernel_module","text":"","title":"kernel_module"},{"location":"posts/2020-11-18-buildroot-qemu-x86_64/#_3","text":"","title":""},{"location":"posts/2020-11-18-buildroot-qemu-x86_64/#_4","text":"KERNEL_MODULE_VERSION = 1.0 KERNEL_MODULE_SITE = $(BR2_EXTERNAL_KERNEL_MODULES_PATH) KERNEL_MODULE_SITE_METHOD = local KERNEL_MODULE_LINUX_LICENSE = GPL-2.0 KERNEL_MODULE_LINUX_LICENSE_FILES = COPYING $(eval $(kernel-module)) $(eval $(generic-package)) ``` hello.c ``` c","title":""},{"location":"posts/2020-11-18-buildroot-qemu-x86_64/#include","text":"","title":"include "},{"location":"posts/2020-11-18-buildroot-qemu-x86_64/#include_1","text":"MODULE_LICENSE(\"GPL\"); static int myinit(void) { printk(KERN_INFO \"hello init\\n\"); return 0; } static void myexit(void) { printk(KERN_INFO \"hello exit\\n\"); } module_init(myinit) module_exit(myexit) ``` The change is from BR2_EXTERNAL_KERNEL_MODULE_PATH to BR2_EXTERNAL_KERNEL_MODULES_PATH .","title":"include "},{"location":"posts/2020-11-18-buildroot-qemu-x86_64/#compile-buildroot","text":"The several components are arranged like below. . \u251c\u2500\u2500 buildroot-2020.02.8 \u2514\u2500\u2500 kernel_module Go to buildroot If no kernel module, just make qemu_x86_64_defconfig , otherwise, make BR2_EXTERNAL=\"$(pwd)/../kernel_module\" qemu_x86_64_defconfig Before going on, we should update the C libary and the tty target by make menuconfig . Toolchain -> C library -> glibc System Configuration -> Run a getty (login prompt) after boot -> TTY port -> ttyS0 [Optional] We can enable lspci -v to show more information on PCI devices. Target Packages -> Hardware Handling -> pciutils If any kernel module, echo 'BR2_PACKAGE_KERNEL_MODULE=y' >> .config make with -jN to accelerate your compilation.","title":"Compile Buildroot"},{"location":"posts/2020-11-18-buildroot-qemu-x86_64/#launch-all-of-them","text":"qemu-system-x86_64 \\ -M pc \\ -kernel ./output/images/bzImage \\ -drive file=./output/images/rootfs.ext2,if=virtio,format=raw \\ -append \"root=/dev/vda console=ttyS0\" \\ -net nic,model=virtio -net user \\ -nographic If there exists a Linux kernel module, please do as follow. $ modprobe hello hello: loading out-of-tree module taints kernel. hello init $ desg ... hello: loading out-of-tree module taints kernel. hello init","title":"Launch all of them"},{"location":"posts/2020-11-18-buildroot-qemu-x86_64/#reference","text":"buildroot\u7f16\u8bd1\u8fd0\u884cQEMU X86_64 How to add a linux kernel driver module as a buildroot package \\ [^cve-2020-14364]: An out-of-bounds read/write access flaw was found in the USB emulator of the QEMU in versions before 5.2.0. This issue occurs while processing USB packets from a guest when USBDevice setup_len exceeds its data_buf[4096] in the do_token_in , do_token_out routines. This flaw allows a guest user to crash the QEMU process, resulting in a denial of service, or the potential execution of arbitrary code with the privileges of the QEMU process on the host .","title":"Reference"},{"location":"posts/2020-11-30-wllvm-clang-qemu-x86_64/","text":"Clang, wllvm, passes, QEMU for x86_64 In order to run LLVM passes on QEMU, I need to build QEMU with Clang. One option is to run the passes during the compilation, the other is to generate an LLVM bitcode file and apply opt . The bitcode file can be extracted by wllvm . Because I'm gonna conduct static analysis for seaking vulnerabilities rather than code optimization, I choose wllvm and apply opt on my extracted bitcode file. Build QEMU with Clang Even though unsmoothy on the internet[^1][^2][^3], I just made it on QEMU 4.0.0 with clang-3.8. $ clang --version clang version 3.8.0-2ubuntu4 (tags/RELEASE_380/final) Target: x86_64-pc-linux-gnu Thread model: posix InstalledDir: /usr/bin $ cd qemu-4.0.0 $ ./configure --target-list=x86_64-softmmu --cc=clang $ make Nothing bad happened. Build QEMU with wllvm [^4] $ pip install wllvm $ export LLVM_COMPILER=clang $ # if no clang/clang++ executables $ # export LLVM_CC_NAME=clang-7 $ # export LLVM_CXX_NAME=clang++-7 $ cd qemu-4.0.0 $ ./configure --target-list=x86_64-softmmu --cc=wllvm $ make $ extract-bc x86_64-softmmu/qemu-system-x86_64 $ # You will find the bitcode file x86_64-softmmu/qemu-system-x86_64.bc I met one kind of warnings WARNING:Did not recognize the compiler flag \"-mcx16\" , but it seemed harmless. I will update more if any flaw caused by this warning. I met another error objcopy: src/xxx: failed to find link section for section xx . Please update your objcopy to 2.31 or upper. Run LLVM passes with opt First trial of a builin pass. $ opt -print-function qemu-system-x86_64.bc -o /dev/null 2>&1 > output.txt What I want is quite simple: print function names and check arguments, which reminds me of the first HelloWorld pass in llvm-tutor . I found llvm-tutor used LLVM 11 , updating so quickly, such that I made a docker image to compile the pass. BTW, it's OK to use opt-11 in the docker image and no need to recompile QEMU. # Dockerfile FROM ubuntu:18.04 # Uncomment this and update the sources list if you have network problems # COPY sources.list /etc/apt/sources.list RUN apt-get update; apt-get install -y build-essential cmake vim WORKDIR /root RUN apt-get install -y sudo wget software-properties-common RUN wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add -; \\ sudo apt-add-repository \"deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-11 main\"; \\ sudo apt-get update; \\ sudo apt-get install -y llvm-11 llvm-11-dev clang-11 llvm-11-tools Then, build the docker. $ docker build . -t qemu-spa:latest Next, compile the HelloWorld pass. $ git clone https://github.com/banach-space/llvm-tutor.git $ ls Dockerfile build llvm-tutor qemu-4.0.0 qemu-4.0.0.tar.xz sources.list $ docker run \\ -v /path/to/llvm-tutor:/root/llvm-tutor \\ -v /path/to/build:/root/build \\ -it qemu-spa:latest /bin/bash # In the docker image $ llvm-config-11 --prefix /usr/lib/llvm-11 $ export LLVM_DIR=/usr/lib/llvm-11 # Change CMAKE requirements to 3.10.2 # in /root/llvm-tutor/HelloWorld/CMakeLists.txt $ cd build $ cmake -DLT_LLVM_INSTALL_DIR=$LLVM_DIR /root/llvm-tutor/HelloWorld/ $ make Finally, run the pass with opt # cp qemu-system-x86_64.bc to build # In the docker image $ cd build && ls CMakeCache.txt CMakeFiles Makefile cmake_install.cmake libHelloWorld.so qemu-system-x86_64.bc $ opt-11 \\ -load-pass-plugin ./libHelloWorld.so -passes=hello-world -disable-output \\ qemu-system-x86_64.bc # Expected output ... too many (llvm-tutor) Hello from: lockcnt_wake (llvm-tutor) number of arguments: 1 (llvm-tutor) Hello from: qemu_lockcnt_dec (llvm-tutor) number of arguments: 1 (llvm-tutor) Hello from: qemu_lockcnt_dec_and_lock (llvm-tutor) number of arguments: 1 (llvm-tutor) Hello from: qemu_lockcnt_dec_if_lock (llvm-tutor) number of arguments: 1 (llvm-tutor) Hello from: qemu_lockcnt_lock (llvm-tutor) number of arguments: 1 (llvm-tutor) Hello from: qemu_lockcnt_inc_and_unlock (llvm-tutor) number of arguments: 1 (llvm-tutor) Hello from: qemu_lockcnt_unlock (llvm-tutor) number of arguments: 1 (llvm-tutor) Hello from: qemu_lockcnt_count (llvm-tutor) number of arguments: 1 Reference [^1]: Red Hat Bugzilla \u2013 Bug 1565766 - qemu failing to build with clang; __atomic_fetch_or_4 \\ [^2]: Building QEMU with clang \\ [^3]: Use Clang to compile Qemu \\ [^4]: SE4VM Detecting Virtualization Bugs in Virtual Machine Platforms: Dev-Harness .","title":"Clang, wllvm, passes, QEMU for x86_64"},{"location":"posts/2020-11-30-wllvm-clang-qemu-x86_64/#clang-wllvm-passes-qemu-for-x86_64","text":"In order to run LLVM passes on QEMU, I need to build QEMU with Clang. One option is to run the passes during the compilation, the other is to generate an LLVM bitcode file and apply opt . The bitcode file can be extracted by wllvm . Because I'm gonna conduct static analysis for seaking vulnerabilities rather than code optimization, I choose wllvm and apply opt on my extracted bitcode file.","title":"Clang, wllvm, passes, QEMU for x86_64"},{"location":"posts/2020-11-30-wllvm-clang-qemu-x86_64/#build-qemu-with-clang","text":"Even though unsmoothy on the internet[^1][^2][^3], I just made it on QEMU 4.0.0 with clang-3.8. $ clang --version clang version 3.8.0-2ubuntu4 (tags/RELEASE_380/final) Target: x86_64-pc-linux-gnu Thread model: posix InstalledDir: /usr/bin $ cd qemu-4.0.0 $ ./configure --target-list=x86_64-softmmu --cc=clang $ make Nothing bad happened.","title":"Build QEMU with Clang"},{"location":"posts/2020-11-30-wllvm-clang-qemu-x86_64/#build-qemu-with-wllvm-4","text":"$ pip install wllvm $ export LLVM_COMPILER=clang $ # if no clang/clang++ executables $ # export LLVM_CC_NAME=clang-7 $ # export LLVM_CXX_NAME=clang++-7 $ cd qemu-4.0.0 $ ./configure --target-list=x86_64-softmmu --cc=wllvm $ make $ extract-bc x86_64-softmmu/qemu-system-x86_64 $ # You will find the bitcode file x86_64-softmmu/qemu-system-x86_64.bc I met one kind of warnings WARNING:Did not recognize the compiler flag \"-mcx16\" , but it seemed harmless. I will update more if any flaw caused by this warning. I met another error objcopy: src/xxx: failed to find link section for section xx . Please update your objcopy to 2.31 or upper.","title":"Build QEMU with wllvm [^4]"},{"location":"posts/2020-11-30-wllvm-clang-qemu-x86_64/#run-llvm-passes-with-opt","text":"First trial of a builin pass. $ opt -print-function qemu-system-x86_64.bc -o /dev/null 2>&1 > output.txt What I want is quite simple: print function names and check arguments, which reminds me of the first HelloWorld pass in llvm-tutor . I found llvm-tutor used LLVM 11 , updating so quickly, such that I made a docker image to compile the pass. BTW, it's OK to use opt-11 in the docker image and no need to recompile QEMU. # Dockerfile FROM ubuntu:18.04 # Uncomment this and update the sources list if you have network problems # COPY sources.list /etc/apt/sources.list RUN apt-get update; apt-get install -y build-essential cmake vim WORKDIR /root RUN apt-get install -y sudo wget software-properties-common RUN wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add -; \\ sudo apt-add-repository \"deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-11 main\"; \\ sudo apt-get update; \\ sudo apt-get install -y llvm-11 llvm-11-dev clang-11 llvm-11-tools Then, build the docker. $ docker build . -t qemu-spa:latest Next, compile the HelloWorld pass. $ git clone https://github.com/banach-space/llvm-tutor.git $ ls Dockerfile build llvm-tutor qemu-4.0.0 qemu-4.0.0.tar.xz sources.list $ docker run \\ -v /path/to/llvm-tutor:/root/llvm-tutor \\ -v /path/to/build:/root/build \\ -it qemu-spa:latest /bin/bash # In the docker image $ llvm-config-11 --prefix /usr/lib/llvm-11 $ export LLVM_DIR=/usr/lib/llvm-11 # Change CMAKE requirements to 3.10.2 # in /root/llvm-tutor/HelloWorld/CMakeLists.txt $ cd build $ cmake -DLT_LLVM_INSTALL_DIR=$LLVM_DIR /root/llvm-tutor/HelloWorld/ $ make Finally, run the pass with opt # cp qemu-system-x86_64.bc to build # In the docker image $ cd build && ls CMakeCache.txt CMakeFiles Makefile cmake_install.cmake libHelloWorld.so qemu-system-x86_64.bc $ opt-11 \\ -load-pass-plugin ./libHelloWorld.so -passes=hello-world -disable-output \\ qemu-system-x86_64.bc # Expected output ... too many (llvm-tutor) Hello from: lockcnt_wake (llvm-tutor) number of arguments: 1 (llvm-tutor) Hello from: qemu_lockcnt_dec (llvm-tutor) number of arguments: 1 (llvm-tutor) Hello from: qemu_lockcnt_dec_and_lock (llvm-tutor) number of arguments: 1 (llvm-tutor) Hello from: qemu_lockcnt_dec_if_lock (llvm-tutor) number of arguments: 1 (llvm-tutor) Hello from: qemu_lockcnt_lock (llvm-tutor) number of arguments: 1 (llvm-tutor) Hello from: qemu_lockcnt_inc_and_unlock (llvm-tutor) number of arguments: 1 (llvm-tutor) Hello from: qemu_lockcnt_unlock (llvm-tutor) number of arguments: 1 (llvm-tutor) Hello from: qemu_lockcnt_count (llvm-tutor) number of arguments: 1","title":"Run LLVM passes with opt"},{"location":"posts/2020-11-30-wllvm-clang-qemu-x86_64/#reference","text":"[^1]: Red Hat Bugzilla \u2013 Bug 1565766 - qemu failing to build with clang; __atomic_fetch_or_4 \\ [^2]: Building QEMU with clang \\ [^3]: Use Clang to compile Qemu \\ [^4]: SE4VM Detecting Virtualization Bugs in Virtual Machine Platforms: Dev-Harness .","title":"Reference"},{"location":"posts/2021-08-18-Display-in-QEMU/","text":"Display in QEMU Gerd Hoffmann has introduced graphics in QEMU here and there[^1], and in this article, I will do some basic introduction about QEMU displays and QEMU consoles with QEMU code (QEMU 6.1.0-rc3). QEMU Displays QEMU displays are a set of display change listeners with the support of text or graphic tools on the host machine. QEMU Display options As claimed here , we can send the QEMU display to sdl/curses/gtk/vnc/spice windows, or just do not display video output. Only curses supports text mode. \"Nothing is displayed when the graphics device is in graphical mode or if the graphics device does not support a text mode. Generally, only the VGA device models support text mode.\" To talk to the host, each display has a change listener with several callbacks that would call the relative APIs. For example, curses_update will call pnoutrefresh . static const DisplayChangeListenerOps dcl_ops = { .dpy_name = \"curses\", .dpy_text_update = curses_update, .dpy_text_resize = curses_resize, .dpy_refresh = curses_refresh, .dpy_text_cursor = curses_cursor_position, }; Here are all change listener callbacks. ui/curses.c:767:static const DisplayChangeListenerOps dcl_ops = { ui/sdl2.c:761:static const DisplayChangeListenerOps dcl_2d_ops = { ui/sdl2.c:772:static const DisplayChangeListenerOps dcl_gl_ops = { ui/spice-display.c:775:static const DisplayChangeListenerOps display_listener_ops = { ui/spice-display.c:1096:static const DisplayChangeListenerOps display_listener_gl_ops = { ui/egl-headless.c:154:static const DisplayChangeListenerOps egl_ops = { ui/cocoa.m:86:static const DisplayChangeListenerOps dcl_ops = { ui/gtk.c:607:static const DisplayChangeListenerOps dcl_ops = { ui/gtk.c:635:static const DisplayChangeListenerOps dcl_gl_area_ops = { ui/gtk.c:656:static const DisplayChangeListenerOps dcl_egl_ops = { ui/vnc.c:3337:static const DisplayChangeListenerOps dcl_ops = { In QEMU, the registration process is in the following. First, qemu_display_register will register all QemuDisplay objects to dpys[DISPLAY_TYPE__MAX] . static QemuDisplay *dpys[DISPLAY_TYPE__MAX]; void qemu_display_register(QemuDisplay *ui) { assert(ui->type < DISPLAY_TYPE__MAX); dpys[ui->type] = ui; // S3 } static QemuDisplay qemu_display_curses = { .type = DISPLAY_TYPE_CURSES, .init = curses_display_init, }; static void register_curses(void) { qemu_display_register(&qemu_display_curses); // S2 } type_init(register_curses); // S1 Second, qemu_init_displays will first initialize a global DisplayState and initialize all text consoles if available. Then, qemu_init_displays will call qemu_display_init , and then call all .init registered if -display none is not set. static DisplayState *get_alloc_displaystate(void) { if (!display_state) { display_state = g_new0(DisplayState, 1); cursor_timer = timer_new_ms( QEMU_CLOCK_REALTIME, text_console_update_cursor, NULL); } return display_state; } DisplayState *init_displaystate(void) { gchar *name; QemuConsole *con; get_alloc_displaystate(); QTAILQ_FOREACH(con, &consoles, next) { if (con->console_type != GRAPHIC_CONSOLE && con->ds == NULL) { text_console_do_init(con->chr, display_state); } ... } return display_state; } void qemu_display_init(DisplayState *ds, DisplayOptions *opts) { if (opts->type == DISPLAY_TYPE_NONE) { return; } assert(dpys[opts->type] != NULL); dpys[opts->type]->init(ds, opts); } QEMU Console QEMU consoles are the bridges between video devices and QEMU displays. QEMU consoles are defined as a list of QemuConsole . static QTAILQ_HEAD(, QemuConsole) consoles = QTAILQ_HEAD_INITIALIZER(consoles); There is a for-each primitive to traverse each QemuConsole . QTAILQ_FOREACH(con, &consoles, next) { } There are several high-level primitives to access a QemuConsole as well. qemu_console_lookup_by_index(... index) qemu_console_lookup_by_device(... dev, ... head) qemu_console_lookup_by_device_name(... device_id, head) // device_id -> dev qemu_console_lookup_unused() QEMU consoles have three types. typedef enum { GRAPHIC_CONSOLE, TEXT_CONSOLE, TEXT_CONSOLE_FIXED_SIZE } console_type_t; GRAPHIC_CONSOLE // e.g., ati-vga ati_vga_realize -> graphic_console_init -> new_console(..., GRAPHIC_CONSOLE, ...) Other examples are in the following. hw/display/pl110.c hw/display/g364fb.c hw/display/virtio-gpu-base.c hw/display/bochs-display.c hw/display/vga-pci.c hw/display/vmware_vga.c hw/display/xlnx_dp.c hw/display/vga-isa-mm.c hw/display/cirrus_vga.c hw/display/ramfb-standalone.c hw/display/exynos4210_fimd.c hw/display/macfb.c hw/display/bcm2835_fb.c hw/display/cg3.c hw/display/xenfb.c hw/display/cirrus_vga_isa.c hw/display/omap_lcdc.c hw/display/jazz_led.c hw/display/tc6393xb.c hw/display/milkymist-vgafb.c hw/display/vga-isa.c hw/display/next-fb.c hw/display/ssd0323.c hw/display/ati.c hw/display/artist.c hw/display/qxl.c hw/display/ssd0303.c hw/display/tcx.c hw/display/omap_dss.c hw/display/sm501.c hw/display/blizzard.c hw/display/pxa2xx_lcd.c TEXT_CONSOLE[_FIXED_SIZE] // e.g., chardev-vc vc_chr_open -> new_console(..., TEXT_CONSOLE[_FIXED_SIZE], ...) QEMU consoles are initialized by new_console . First, new_console allocates an object and initializes some fields. obj = object_new(TYPE_QEMU_CONSOLE); s = QEMU_CONSOLE(obj); qemu_co_queue_init(&s->dump_queue); s->head = head; Then, if no console is activated, it will choose the first allocated console. However, a graphic console can override others. if (!active_console || ((active_console->console_type != GRAPHIC_CONSOLE) && (console_type == GRAPHIC_CONSOLE))) { active_console = s; } Next, still some fields. s->ds = ds; // with display change listeners s->console_type = console_type; s->window_id = -1; Last, new_console will insert the allocated object to the list consoles . If the list is empty, insert the object directly and then set the index to 0. If the object is not a graphic console and QEMU is in the phase of PHASE_MACHINE_READY , append the object and update its index. If the object is a graphic console, append the object to the last graphic console and keep the graphic consoles in front of the text consoles. If in this situation, the text consoles will be renumbered. QEMU consoles, QEMU video devices and QEMU displays A typical example would be graphic_console_init . First, by calling get_alloc_dispaly , it allocates or gets an allocated DisplayState that is bonded to a list of display change listeners. ds = get_alloc_displaystate(); Second, it finds an unused QEMU console by qemu_console_lookup_unused . A QEMU console is unused when it is at least not linked to a QEMU video device. If there is no console available, it will call new_console to allocate a graphic console with the allocated DisplayState . s = qemu_console_lookup_unused(); if (s) { if (s->surface) { width = surface_width(s->surface); height = surface_height(s->surface); } } else { s = new_console(ds, GRAPHIC_CONSOLE, head); s->ui_timer = timer_new_ms(QEMU_CLOCK_REALTIME, dpy_set_ui_info_timer, s); } Third, it links the console to the QEMU video device and registers relative callbacks. graphic_console_set_hwops(s, hw_ops, opaque); if (dev) { object_property_set_link(OBJECT(s), \"device\", OBJECT(dev), &error_abort); } Finally, create a surface and notify all QEMU displays through s->ds->listeners . surface = qemu_create_placeholder_surface(width, height, noinit); dpy_gfx_replace_surface(s, surface); Here is a summary. +------------------+ +------------+ +-------------+ +QEMU vidio devices+ <-hw_ops- +QEMU console+ -listeners-> +QEMU dispalys+ +------------------+ +------------+ +-------------+ When it comes to a text console, things are similar. First, allocate a QEMU console. if (width == 0 || height == 0) { s = new_console(NULL, TEXT_CONSOLE, 0); } else { s = new_console(NULL, TEXT_CONSOLE_FIXED_SIZE, 0); s->surface = qemu_create_displaysurface(width, height); } Then, link the console with the ChardevVC , DisplayState if available and relative hardware operations. static void text_console_do_init(Chardev *chr, DisplayState *ds) { s->ds = ds ... s->hw_ops = &text_console_ops; s->hw = s; ... } Interactions through QEMU consoles First of all, we will figure out when the hw_ops are called. All hw_ops are defined in the following. typedef struct GraphicHwOps { int (*get_flags)(void *opaque); /* optional, default 0 */ void (*invalidate)(void *opaque); void (*gfx_update)(void *opaque); bool gfx_update_async; /* if true, calls graphic_hw_update_done() */ void (*text_update)(void *opaque, console_ch_t *text); void (*update_interval)(void *opaque, uint64_t interval); int (*ui_info)(void *opaque, uint32_t head, QemuUIInfo *info); void (*gl_block)(void *opaque, bool block); void (*gl_flushed)(void *opaque); } GraphicHwOps; We can group them according to their usage. Group 1: graphic_hw_xxx Callbacks in this group will be called by QEMU displays. Graphic displays usually call graphic_hw_update , while text displays would call graphic_hw_text_udpate . A virtual device must tell the corresponding QEMU displays what should do by implementing these callbacks. graphic_hw_update (gfx_update) graphic_hw_text_update graphic_hw_invalidate graphic_hw_gl_block graphic_hw_gl_flushed Group 2: gui_update -> update_interval When register_displaychangelistener is called by a QEMU display, it will set a timer to call phy_refresh periodically. A virtual device can implement update_interval to synchronize the interval of the timer. Group 3: dpy_compatible_with and dpy_set_ui_info_timer The former checks whether a video device is compatible with a QEMU display by calling get_flags . The latter will be triggered when ui info should be told to the guest. Second, we will figure out how the display listener callbacks work. An example of graphic QEMU display static const DisplayChangeListenerOps dcl_ops = { .dpy_name = \"gtk\", .dpy_gfx_update = gd_update, .dpy_gfx_switch = gd_switch, .dpy_gfx_check_format = qemu_pixman_check_format, .dpy_refresh = gd_refresh, .dpy_mouse_set = gd_mouse_set, .dpy_cursor_define = gd_cursor_define, }; dpy_gfx_update , dpy_gfx_check_format , dpy_mouse_set , and dpy_cursor_define will be called from vedio devices. dpy_refresh is illustrated above. gpy_gfx_switch will be called in register_displaychangelistener or will be called by QEMU displays. What about together? Let's review the history of graphic devices. 1st gen VGA Card: output images but leave all calculations to CPU 2nd gen Graphics Card: integrate image output and processing 3rd gen Video Card: take over the video coding-encoding from CPU 4th gen 3D Accelerator Card: take over the 3D Accelerator from a special 3D card 5th gen GPU: integrate more generic calculation tasks Basically, a video device will process and output images. In QEMU, periodically, graphic_hw_update will be called switching from QEMU displays to QEMU video devices. The devices will process the image and then call dpy_gfx_update to inform the changes to QEMU displays. [^1]: Graphics in QEMU","title":"Display in QEMU"},{"location":"posts/2021-08-18-Display-in-QEMU/#display-in-qemu","text":"Gerd Hoffmann has introduced graphics in QEMU here and there[^1], and in this article, I will do some basic introduction about QEMU displays and QEMU consoles with QEMU code (QEMU 6.1.0-rc3).","title":"Display in QEMU"},{"location":"posts/2021-08-18-Display-in-QEMU/#qemu-displays","text":"QEMU displays are a set of display change listeners with the support of text or graphic tools on the host machine.","title":"QEMU Displays"},{"location":"posts/2021-08-18-Display-in-QEMU/#qemu-display-options","text":"As claimed here , we can send the QEMU display to sdl/curses/gtk/vnc/spice windows, or just do not display video output. Only curses supports text mode. \"Nothing is displayed when the graphics device is in graphical mode or if the graphics device does not support a text mode. Generally, only the VGA device models support text mode.\" To talk to the host, each display has a change listener with several callbacks that would call the relative APIs. For example, curses_update will call pnoutrefresh . static const DisplayChangeListenerOps dcl_ops = { .dpy_name = \"curses\", .dpy_text_update = curses_update, .dpy_text_resize = curses_resize, .dpy_refresh = curses_refresh, .dpy_text_cursor = curses_cursor_position, }; Here are all change listener callbacks. ui/curses.c:767:static const DisplayChangeListenerOps dcl_ops = { ui/sdl2.c:761:static const DisplayChangeListenerOps dcl_2d_ops = { ui/sdl2.c:772:static const DisplayChangeListenerOps dcl_gl_ops = { ui/spice-display.c:775:static const DisplayChangeListenerOps display_listener_ops = { ui/spice-display.c:1096:static const DisplayChangeListenerOps display_listener_gl_ops = { ui/egl-headless.c:154:static const DisplayChangeListenerOps egl_ops = { ui/cocoa.m:86:static const DisplayChangeListenerOps dcl_ops = { ui/gtk.c:607:static const DisplayChangeListenerOps dcl_ops = { ui/gtk.c:635:static const DisplayChangeListenerOps dcl_gl_area_ops = { ui/gtk.c:656:static const DisplayChangeListenerOps dcl_egl_ops = { ui/vnc.c:3337:static const DisplayChangeListenerOps dcl_ops = {","title":"QEMU Display options"},{"location":"posts/2021-08-18-Display-in-QEMU/#in-qemu-the-registration-process-is-in-the-following","text":"First, qemu_display_register will register all QemuDisplay objects to dpys[DISPLAY_TYPE__MAX] . static QemuDisplay *dpys[DISPLAY_TYPE__MAX]; void qemu_display_register(QemuDisplay *ui) { assert(ui->type < DISPLAY_TYPE__MAX); dpys[ui->type] = ui; // S3 } static QemuDisplay qemu_display_curses = { .type = DISPLAY_TYPE_CURSES, .init = curses_display_init, }; static void register_curses(void) { qemu_display_register(&qemu_display_curses); // S2 } type_init(register_curses); // S1 Second, qemu_init_displays will first initialize a global DisplayState and initialize all text consoles if available. Then, qemu_init_displays will call qemu_display_init , and then call all .init registered if -display none is not set. static DisplayState *get_alloc_displaystate(void) { if (!display_state) { display_state = g_new0(DisplayState, 1); cursor_timer = timer_new_ms( QEMU_CLOCK_REALTIME, text_console_update_cursor, NULL); } return display_state; } DisplayState *init_displaystate(void) { gchar *name; QemuConsole *con; get_alloc_displaystate(); QTAILQ_FOREACH(con, &consoles, next) { if (con->console_type != GRAPHIC_CONSOLE && con->ds == NULL) { text_console_do_init(con->chr, display_state); } ... } return display_state; } void qemu_display_init(DisplayState *ds, DisplayOptions *opts) { if (opts->type == DISPLAY_TYPE_NONE) { return; } assert(dpys[opts->type] != NULL); dpys[opts->type]->init(ds, opts); }","title":"In QEMU, the registration process is in the following."},{"location":"posts/2021-08-18-Display-in-QEMU/#qemu-console","text":"QEMU consoles are the bridges between video devices and QEMU displays.","title":"QEMU Console"},{"location":"posts/2021-08-18-Display-in-QEMU/#qemu-consoles-are-defined-as-a-list-of-qemuconsole","text":"static QTAILQ_HEAD(, QemuConsole) consoles = QTAILQ_HEAD_INITIALIZER(consoles); There is a for-each primitive to traverse each QemuConsole . QTAILQ_FOREACH(con, &consoles, next) { } There are several high-level primitives to access a QemuConsole as well. qemu_console_lookup_by_index(... index) qemu_console_lookup_by_device(... dev, ... head) qemu_console_lookup_by_device_name(... device_id, head) // device_id -> dev qemu_console_lookup_unused()","title":"QEMU consoles are defined as a list of QemuConsole."},{"location":"posts/2021-08-18-Display-in-QEMU/#qemu-consoles-have-three-types","text":"typedef enum { GRAPHIC_CONSOLE, TEXT_CONSOLE, TEXT_CONSOLE_FIXED_SIZE } console_type_t; GRAPHIC_CONSOLE // e.g., ati-vga ati_vga_realize -> graphic_console_init -> new_console(..., GRAPHIC_CONSOLE, ...) Other examples are in the following. hw/display/pl110.c hw/display/g364fb.c hw/display/virtio-gpu-base.c hw/display/bochs-display.c hw/display/vga-pci.c hw/display/vmware_vga.c hw/display/xlnx_dp.c hw/display/vga-isa-mm.c hw/display/cirrus_vga.c hw/display/ramfb-standalone.c hw/display/exynos4210_fimd.c hw/display/macfb.c hw/display/bcm2835_fb.c hw/display/cg3.c hw/display/xenfb.c hw/display/cirrus_vga_isa.c hw/display/omap_lcdc.c hw/display/jazz_led.c hw/display/tc6393xb.c hw/display/milkymist-vgafb.c hw/display/vga-isa.c hw/display/next-fb.c hw/display/ssd0323.c hw/display/ati.c hw/display/artist.c hw/display/qxl.c hw/display/ssd0303.c hw/display/tcx.c hw/display/omap_dss.c hw/display/sm501.c hw/display/blizzard.c hw/display/pxa2xx_lcd.c TEXT_CONSOLE[_FIXED_SIZE] // e.g., chardev-vc vc_chr_open -> new_console(..., TEXT_CONSOLE[_FIXED_SIZE], ...)","title":"QEMU consoles have three types."},{"location":"posts/2021-08-18-Display-in-QEMU/#qemu-consoles-are-initialized-by-new_console","text":"First, new_console allocates an object and initializes some fields. obj = object_new(TYPE_QEMU_CONSOLE); s = QEMU_CONSOLE(obj); qemu_co_queue_init(&s->dump_queue); s->head = head; Then, if no console is activated, it will choose the first allocated console. However, a graphic console can override others. if (!active_console || ((active_console->console_type != GRAPHIC_CONSOLE) && (console_type == GRAPHIC_CONSOLE))) { active_console = s; } Next, still some fields. s->ds = ds; // with display change listeners s->console_type = console_type; s->window_id = -1; Last, new_console will insert the allocated object to the list consoles . If the list is empty, insert the object directly and then set the index to 0. If the object is not a graphic console and QEMU is in the phase of PHASE_MACHINE_READY , append the object and update its index. If the object is a graphic console, append the object to the last graphic console and keep the graphic consoles in front of the text consoles. If in this situation, the text consoles will be renumbered.","title":"QEMU consoles are initialized by new_console."},{"location":"posts/2021-08-18-Display-in-QEMU/#qemu-consoles-qemu-video-devices-and-qemu-displays","text":"","title":"QEMU consoles, QEMU video devices and QEMU displays"},{"location":"posts/2021-08-18-Display-in-QEMU/#a-typical-example-would-be-graphic_console_init","text":"First, by calling get_alloc_dispaly , it allocates or gets an allocated DisplayState that is bonded to a list of display change listeners. ds = get_alloc_displaystate(); Second, it finds an unused QEMU console by qemu_console_lookup_unused . A QEMU console is unused when it is at least not linked to a QEMU video device. If there is no console available, it will call new_console to allocate a graphic console with the allocated DisplayState . s = qemu_console_lookup_unused(); if (s) { if (s->surface) { width = surface_width(s->surface); height = surface_height(s->surface); } } else { s = new_console(ds, GRAPHIC_CONSOLE, head); s->ui_timer = timer_new_ms(QEMU_CLOCK_REALTIME, dpy_set_ui_info_timer, s); } Third, it links the console to the QEMU video device and registers relative callbacks. graphic_console_set_hwops(s, hw_ops, opaque); if (dev) { object_property_set_link(OBJECT(s), \"device\", OBJECT(dev), &error_abort); } Finally, create a surface and notify all QEMU displays through s->ds->listeners . surface = qemu_create_placeholder_surface(width, height, noinit); dpy_gfx_replace_surface(s, surface); Here is a summary. +------------------+ +------------+ +-------------+ +QEMU vidio devices+ <-hw_ops- +QEMU console+ -listeners-> +QEMU dispalys+ +------------------+ +------------+ +-------------+","title":"A typical example would be graphic_console_init."},{"location":"posts/2021-08-18-Display-in-QEMU/#when-it-comes-to-a-text-console-things-are-similar","text":"First, allocate a QEMU console. if (width == 0 || height == 0) { s = new_console(NULL, TEXT_CONSOLE, 0); } else { s = new_console(NULL, TEXT_CONSOLE_FIXED_SIZE, 0); s->surface = qemu_create_displaysurface(width, height); } Then, link the console with the ChardevVC , DisplayState if available and relative hardware operations. static void text_console_do_init(Chardev *chr, DisplayState *ds) { s->ds = ds ... s->hw_ops = &text_console_ops; s->hw = s; ... }","title":"When it comes to a text console, things are similar."},{"location":"posts/2021-08-18-Display-in-QEMU/#interactions-through-qemu-consoles","text":"","title":"Interactions through QEMU consoles"},{"location":"posts/2021-08-18-Display-in-QEMU/#first-of-all-we-will-figure-out-when-the-hw_ops-are-called","text":"All hw_ops are defined in the following. typedef struct GraphicHwOps { int (*get_flags)(void *opaque); /* optional, default 0 */ void (*invalidate)(void *opaque); void (*gfx_update)(void *opaque); bool gfx_update_async; /* if true, calls graphic_hw_update_done() */ void (*text_update)(void *opaque, console_ch_t *text); void (*update_interval)(void *opaque, uint64_t interval); int (*ui_info)(void *opaque, uint32_t head, QemuUIInfo *info); void (*gl_block)(void *opaque, bool block); void (*gl_flushed)(void *opaque); } GraphicHwOps; We can group them according to their usage.","title":"First of all, we will figure out when the hw_ops are called."},{"location":"posts/2021-08-18-Display-in-QEMU/#group-1-graphic_hw_xxx","text":"Callbacks in this group will be called by QEMU displays. Graphic displays usually call graphic_hw_update , while text displays would call graphic_hw_text_udpate . A virtual device must tell the corresponding QEMU displays what should do by implementing these callbacks. graphic_hw_update (gfx_update) graphic_hw_text_update graphic_hw_invalidate graphic_hw_gl_block graphic_hw_gl_flushed","title":"Group 1: graphic_hw_xxx"},{"location":"posts/2021-08-18-Display-in-QEMU/#group-2-gui_update-update_interval","text":"When register_displaychangelistener is called by a QEMU display, it will set a timer to call phy_refresh periodically. A virtual device can implement update_interval to synchronize the interval of the timer.","title":"Group 2: gui_update -&gt; update_interval"},{"location":"posts/2021-08-18-Display-in-QEMU/#group-3-dpy_compatible_with-and-dpy_set_ui_info_timer","text":"The former checks whether a video device is compatible with a QEMU display by calling get_flags . The latter will be triggered when ui info should be told to the guest.","title":"Group 3: dpy_compatible_with and dpy_set_ui_info_timer"},{"location":"posts/2021-08-18-Display-in-QEMU/#second-we-will-figure-out-how-the-display-listener-callbacks-work","text":"","title":"Second, we will figure out how the display listener callbacks work."},{"location":"posts/2021-08-18-Display-in-QEMU/#an-example-of-graphic-qemu-display","text":"static const DisplayChangeListenerOps dcl_ops = { .dpy_name = \"gtk\", .dpy_gfx_update = gd_update, .dpy_gfx_switch = gd_switch, .dpy_gfx_check_format = qemu_pixman_check_format, .dpy_refresh = gd_refresh, .dpy_mouse_set = gd_mouse_set, .dpy_cursor_define = gd_cursor_define, }; dpy_gfx_update , dpy_gfx_check_format , dpy_mouse_set , and dpy_cursor_define will be called from vedio devices. dpy_refresh is illustrated above. gpy_gfx_switch will be called in register_displaychangelistener or will be called by QEMU displays.","title":"An example of graphic QEMU display"},{"location":"posts/2021-08-18-Display-in-QEMU/#what-about-together","text":"Let's review the history of graphic devices. 1st gen VGA Card: output images but leave all calculations to CPU 2nd gen Graphics Card: integrate image output and processing 3rd gen Video Card: take over the video coding-encoding from CPU 4th gen 3D Accelerator Card: take over the 3D Accelerator from a special 3D card 5th gen GPU: integrate more generic calculation tasks Basically, a video device will process and output images. In QEMU, periodically, graphic_hw_update will be called switching from QEMU displays to QEMU video devices. The devices will process the image and then call dpy_gfx_update to inform the changes to QEMU displays. [^1]: Graphics in QEMU","title":"What about together?"},{"location":"posts/2021-08-27-Principle-of-Presentation/","text":"Principles of Research Presentation To convey information and request feedback, you need to give presentations in group meetings, defense meetings and invited talks. You may be required to give an oral and short introduction or to demonstrate your ideas with slides and answer questions in 1 hour. Here are some principles that you should keep in mind and practice in your daily research. Be aware of your purpose - Time and Topic You will be required to give presentations in the following scenario. A brief introduction about your research career. A brief introduction about what you are doing now. An presentation to introduce what you are doing now. An introduction about your questions and solutions. An introduction about your new ideas and some results. A presentation to defend your dissertation, thesis, proposal, Post Doc. application, tenure application, etc. A presentation to demonstrate the progress of your projects. A presentation to advertise yourself and seek collaboration. Scenario 1-5 are common in group meetings, 6 and 7 are common in defense meetings, while scenario 8 is for invited talks. You have to be aware of your purpose to give a presentation because it decides how much time you have and what topics you should include. Be aware of your audience - Context and Tricks You have to be aware of your audience because different audiences have different backgrounds and expectations. You will have the following audiences. Your supervisor. Senior students. Junior students. A group of people mixed with the above people. Reviewers from your committee. You have to make sure what they know about what you are going to present and then select different techniques to achieve your purpose efficiently. To be continued.","title":"Principles of Research Presentation"},{"location":"posts/2021-08-27-Principle-of-Presentation/#principles-of-research-presentation","text":"To convey information and request feedback, you need to give presentations in group meetings, defense meetings and invited talks. You may be required to give an oral and short introduction or to demonstrate your ideas with slides and answer questions in 1 hour. Here are some principles that you should keep in mind and practice in your daily research.","title":"Principles of Research Presentation"},{"location":"posts/2021-08-27-Principle-of-Presentation/#be-aware-of-your-purpose-time-and-topic","text":"You will be required to give presentations in the following scenario. A brief introduction about your research career. A brief introduction about what you are doing now. An presentation to introduce what you are doing now. An introduction about your questions and solutions. An introduction about your new ideas and some results. A presentation to defend your dissertation, thesis, proposal, Post Doc. application, tenure application, etc. A presentation to demonstrate the progress of your projects. A presentation to advertise yourself and seek collaboration. Scenario 1-5 are common in group meetings, 6 and 7 are common in defense meetings, while scenario 8 is for invited talks. You have to be aware of your purpose to give a presentation because it decides how much time you have and what topics you should include.","title":"Be aware of your purpose - Time and Topic"},{"location":"posts/2021-08-27-Principle-of-Presentation/#be-aware-of-your-audience-context-and-tricks","text":"You have to be aware of your audience because different audiences have different backgrounds and expectations. You will have the following audiences. Your supervisor. Senior students. Junior students. A group of people mixed with the above people. Reviewers from your committee. You have to make sure what they know about what you are going to present and then select different techniques to achieve your purpose efficiently. To be continued.","title":"Be aware of your audience - Context and Tricks"},{"location":"posts/2021-09-03-Summary-Research-SE/","text":"Programming Skills for Research We would like to see solid implementation along with a novel idea. To be good at solid coding, we need specific skills and efficient collaboration because of the time budget. Usually, we want to finish most of the research projects within half a year or one year to cover three or four deadlines of top-tier conferences. I group the following programming skills into four levels regarding my personal experiences. At level 1, attend basic courses in computer science to get familiar with theories and design decisions in computing systems. At level 2, train ourselves about how to involve, develop, and maintain an open-source project. At level 3, develop our coding style for research projects and make our research reproducible, inspiring, and influential. At level 4, try existing open source projects (maybe join their community by sending patches) and learn advanced algorithms. Level 1 At the very beginning, we have to take the courses in the following. + Data Structure and Algorithm + Database + Network + Operating System + Architecture and Computation System You are encouraged to take the following courses to go further. + Compiler + Computation Theory + Information Security At the same time, we are encouraged to seize two or three programming languages. Usually, they can be C/C++, Java, and Python. Usually, it is quite helpful to know shell commands. Level 2 At this level, we have to train ourselves through projects and be familiar with what in the following. + Requirements Analysis + Code Style + Documentation + Version Control: Pull, Documentation, Commit, Push or Pull Request + Discussion: Issue, Maillist, and Forum + Debug and Patch + Testing and Automation + Time/Risk Control + Package Manager: npm, pip, and README Level 3 At this level, develop our style for research project code. + Build the smallest SDK with limited but enough unit tests + Build our applications on that SDK + Move commonly used code in the applications to the SDK + Don't do too much when developing the changing applications Level 4 At this level, we are supposed to learn existing wheels and their details. For instance, we can learn how Flask and Django web servers work. After that, we should know the design choices, their pros/cons, and how to set up a minimum web quickly. Think about some metrics. + CPU utilization + Cache optimization + Memory consumption + Disk consumption Here is a summary of selected projects. + Application: QT, Android + Web Server: Flask, Django + Operating System: Linux Kernel + Virtualization: QEMU + Message Queue: Kafka + Container: Docker At the same time, learn more advanced algorithms from papers or graduate courses. Summary Develop quick and dirty code and improve your skills by learning existing projects. Keep learning!","title":"Programming Skills for Research"},{"location":"posts/2021-09-03-Summary-Research-SE/#programming-skills-for-research","text":"We would like to see solid implementation along with a novel idea. To be good at solid coding, we need specific skills and efficient collaboration because of the time budget. Usually, we want to finish most of the research projects within half a year or one year to cover three or four deadlines of top-tier conferences. I group the following programming skills into four levels regarding my personal experiences. At level 1, attend basic courses in computer science to get familiar with theories and design decisions in computing systems. At level 2, train ourselves about how to involve, develop, and maintain an open-source project. At level 3, develop our coding style for research projects and make our research reproducible, inspiring, and influential. At level 4, try existing open source projects (maybe join their community by sending patches) and learn advanced algorithms.","title":"Programming Skills for Research"},{"location":"posts/2021-09-03-Summary-Research-SE/#level-1","text":"At the very beginning, we have to take the courses in the following. + Data Structure and Algorithm + Database + Network + Operating System + Architecture and Computation System You are encouraged to take the following courses to go further. + Compiler + Computation Theory + Information Security At the same time, we are encouraged to seize two or three programming languages. Usually, they can be C/C++, Java, and Python. Usually, it is quite helpful to know shell commands.","title":"Level 1"},{"location":"posts/2021-09-03-Summary-Research-SE/#level-2","text":"At this level, we have to train ourselves through projects and be familiar with what in the following. + Requirements Analysis + Code Style + Documentation + Version Control: Pull, Documentation, Commit, Push or Pull Request + Discussion: Issue, Maillist, and Forum + Debug and Patch + Testing and Automation + Time/Risk Control + Package Manager: npm, pip, and README","title":"Level 2"},{"location":"posts/2021-09-03-Summary-Research-SE/#level-3","text":"At this level, develop our style for research project code. + Build the smallest SDK with limited but enough unit tests + Build our applications on that SDK + Move commonly used code in the applications to the SDK + Don't do too much when developing the changing applications","title":"Level 3"},{"location":"posts/2021-09-03-Summary-Research-SE/#level-4","text":"At this level, we are supposed to learn existing wheels and their details. For instance, we can learn how Flask and Django web servers work. After that, we should know the design choices, their pros/cons, and how to set up a minimum web quickly. Think about some metrics. + CPU utilization + Cache optimization + Memory consumption + Disk consumption Here is a summary of selected projects. + Application: QT, Android + Web Server: Flask, Django + Operating System: Linux Kernel + Virtualization: QEMU + Message Queue: Kafka + Container: Docker At the same time, learn more advanced algorithms from papers or graduate courses. Summary Develop quick and dirty code and improve your skills by learning existing projects. Keep learning!","title":"Level 4"},{"location":"posts/2021-09-07-Research-Philosophy/","text":"How to Do [System|Software] (Security) Research Where to find a problem Most practical ideas come from our research activities. Usually, we can read and propose a new idea after reading a paper. However, there would be a delay. First, a research paper would be published two years later than its authors came up with that idea. Second, even though some PC members can check all interesting papers submitted to a conference, there is about half a year or one-year delay. How can we fill the gap? No, we cannot unless we are connecting or collaborating with these scholars. Another source of research ideas is practical requirements from users. This source is so inefficient unless we are connecting or collaborating with industry people. Practical ideas come from our research activities, and we should be curious about everything in our research activities all the time. To make it more clear, we can put it in this way. We can study everything. Whenever we find or hear of a thing, we should show our interests and clarify the motivation to study it. Of course, do not forget our connection with the academic and industrial community in which inevitable benefits will come as well. How to define a problem Before going further, I would like to discuss the types of knowledge. One type of knowledge looks forward, and the other focuses on backward. Classifying research ideas in computer science bridges computer science to other disciplines. Physics looks forward, and history looks backwards. We should also think in this way during our research activities. Designing a system looks forward while reviewing literature looks backwards. Learning the history of all science helps to improve our research quality of ideas, evaluation, and writing. Here, we have the first category we should judge for a thing to be studied: looking forward or looking backwards. A thing is an object to be studied. During our activities, we always do something. We should be curious about a thing since it would be our research object. An object can be a thing in the real world, for example, a piece of software; an object can be a process of humans, for example, developing a piece of software. We can see similarities and differences between them. Interestingly, if we focus on a thing itself, the research problems would look forward; if we focus on a human process, the research problems look backwards. Here, we have the second category: a thing or a human process. Define a looking-forward problem starting from its nature while defining a looking-backwards problem starting from history. To make our research more scientific, we should avoid some construction problems that usually make computer science (and technology) to computer engineering in which all scientific parts hide. For a looking-forward problem, we have to define what to predict, and for a looking-backwards problem, we should define what to summarize. Here, we have the third category: nature and history. BTW, check this article to learn the patterns of research and other tips. How to evaluate the problems Now, we have two simple problems: what to predict and what to summarize. We have to introduce more principles to evaluate our problems because not all problems are worthy of study. The first question is whether a problem is generic. We have to check whether this problem has many instances in the real world, such that the real impact is there. The second question is whether a problem is solvable. We have to seek help from the computation theory and estimate what the best we can do. We should carefully take reasonable assumptions and think of several solutions. The third question is whether our solutions are applicable to other scenarios. Other tricks are in the following. + Please pay attention to how many papers and how many efforts exist. You may want to be at the beginning (0-2 papers) or not later than the peak (it depends.) of the publication wave related to our problems. How to evaluate the ideas Remember that not all ideas can be accepted by top-tier conferences. One is the novelty , and the other is superiority . To be novel, we have to do a literature review and distinguish our idea from others\u2019. Because of the time budget, we cannot make our idea superior to others in every aspect, and thus we can choose the core metrics. The core metrics evolve among the development of the whole community. Some technology becomes mature such that some metrics are easier to achieve. Such easier metrics are not the core metrics but that we have to include. Consider all techniques we can use to be superior. OK. Let us do it! To save time, we are not supposed to make many mistakes. Nowadays, the computer science research community is competitive because not only most of the problems are easier to solve but also more and more people join us. When reviewers scan a manuscript, they pick up our mistakes and reject the papers that have more. Here are some tips from past research activities to evaluate our ideas quickly. Budge our time Tell ourselves the DDL is truly two weeks in advance. Always consider what we are doing to be some paragraph in the paper and never do it twice. Think and ask ourselves about what is the fastest way to do this and then do it. Spend 30 seconds more to save us from a 30 mins disaster. It is the context switch that wastes a lot of time. Spend less than one day on a project we are not the first author. Take holidays every four or five months: e.g., Chinese Spring Festivals, Labor Days, and National Holidays. Know what we are going to do Review papers, run their systems, and write the summary (related work) Identify challenges and evaluate solutions in theory (challenges, insights, solutions) Design system and evaluate design choices in theory (background, system design) Implement a generic prototype and write evaluation scripts (implementation, evaluation) Write our paper in advance and get feedback from others . Set up servers What architectures should you use? How many servers do you have? If you are in the sudo group? Save runtime/intermediate data on SSD and save results on HDD. If there is no storage? Buy more! If you disabled the hyper-threading? Write evaluation scripts All in Docker container. Make it parallel. Quick results first, middle-long results for writing, then long time evaluation for submission. Diversity first, then quantity. Some tips about parallel tasks Be busy when it is busy and have fun when it is not busy Create a task, think about the solutions, importantly, think about why our results are not correct Write our task down before we start and close it after we finish it ( I am using Marp (Markdown Slides). ) Do not delete any data if we are definitely sure. Just buy more storage! Utilize all hardware resources we have. Do not make them have a rest. How to sell our idea Some techniques Tell a logical and clear story. Minimize disadvantages. If existing metrics cannot show better results, define a new one. Write a good paper Keep learning to write a paper Reader-centered writing Unity, Support, and Coherent Revise context and sentences, and do editing A detailed analysis What we cannot control How many papers were submitted to a conference and the target acceptance rate. Which reviewers would revise our paper, and how well they know about what we are doing. What we can control Importance/Novelty/Superior Reasonable techniques and good enough implementation Clear writing Handle small flaws Clear writing Each paragraph has its goal. Make sure the topic sentence highlight the goal. A strong argument includes 1) point, 2) theoretical argument (papers), 3) factual argument (data). Be confident but do not overclaim. Be critical but be not rude. Keep in mind that reviewers do not join our group meetings, so do not expect too much! Keep a common storyline and make one sentence unique meaning. Storyline Importance, limitations of existing work, new theory and new techniques, evaluation Title: Summary of our work; Be attractive; No details Abstract: 2-minute storyline; Use hypernyms; No technical details; Introduction: 10-minute storyline; Show rationals; No concrete details; Backgroud: Big background; Terminologies; Motivating Example System, Implementation, and Evaluation: Problems -> Approaches -> Why -> How well Related work: Introduce related works and Highlight the difference Discussion: Answer reviewers' questions and hint the future work Conclusion: Summarize and extract new knowledge Advertise Homepage Twitteriture Group Main conference session Poster session How to solve a problem (WIP) This section is new and inspired by some social science disciplines. In general, we will define a problem as a computation problem in computer science. In practice, we will use possible threat models, system primitives, existing tools, and existing algorithms. Besides, we think about decidability, time, and storage complexity. However, we can do more than that. Classification Classification is the first naive and powerful tool we are supposed to use. In fact, we use this tool implicitly every day. When we are talking about fuzzers, we will split them into black-box, white-box, and grey-box fuzzers. If someone asks we what is this, why is this, and how is this, probably the first answer is to ask what categories are of \"this\". If someone asks we what our favourite food is, we may ask: what categories of food we are asking?","title":"How to Do [System|Software] (Security) Research"},{"location":"posts/2021-09-07-Research-Philosophy/#how-to-do-systemsoftware-security-research","text":"","title":"How to Do [System|Software] (Security) Research"},{"location":"posts/2021-09-07-Research-Philosophy/#where-to-find-a-problem","text":"Most practical ideas come from our research activities. Usually, we can read and propose a new idea after reading a paper. However, there would be a delay. First, a research paper would be published two years later than its authors came up with that idea. Second, even though some PC members can check all interesting papers submitted to a conference, there is about half a year or one-year delay. How can we fill the gap? No, we cannot unless we are connecting or collaborating with these scholars. Another source of research ideas is practical requirements from users. This source is so inefficient unless we are connecting or collaborating with industry people. Practical ideas come from our research activities, and we should be curious about everything in our research activities all the time. To make it more clear, we can put it in this way. We can study everything. Whenever we find or hear of a thing, we should show our interests and clarify the motivation to study it. Of course, do not forget our connection with the academic and industrial community in which inevitable benefits will come as well.","title":"Where to find a problem"},{"location":"posts/2021-09-07-Research-Philosophy/#how-to-define-a-problem","text":"Before going further, I would like to discuss the types of knowledge. One type of knowledge looks forward, and the other focuses on backward. Classifying research ideas in computer science bridges computer science to other disciplines. Physics looks forward, and history looks backwards. We should also think in this way during our research activities. Designing a system looks forward while reviewing literature looks backwards. Learning the history of all science helps to improve our research quality of ideas, evaluation, and writing. Here, we have the first category we should judge for a thing to be studied: looking forward or looking backwards. A thing is an object to be studied. During our activities, we always do something. We should be curious about a thing since it would be our research object. An object can be a thing in the real world, for example, a piece of software; an object can be a process of humans, for example, developing a piece of software. We can see similarities and differences between them. Interestingly, if we focus on a thing itself, the research problems would look forward; if we focus on a human process, the research problems look backwards. Here, we have the second category: a thing or a human process. Define a looking-forward problem starting from its nature while defining a looking-backwards problem starting from history. To make our research more scientific, we should avoid some construction problems that usually make computer science (and technology) to computer engineering in which all scientific parts hide. For a looking-forward problem, we have to define what to predict, and for a looking-backwards problem, we should define what to summarize. Here, we have the third category: nature and history. BTW, check this article to learn the patterns of research and other tips.","title":"How to define a problem"},{"location":"posts/2021-09-07-Research-Philosophy/#how-to-evaluate-the-problems","text":"Now, we have two simple problems: what to predict and what to summarize. We have to introduce more principles to evaluate our problems because not all problems are worthy of study. The first question is whether a problem is generic. We have to check whether this problem has many instances in the real world, such that the real impact is there. The second question is whether a problem is solvable. We have to seek help from the computation theory and estimate what the best we can do. We should carefully take reasonable assumptions and think of several solutions. The third question is whether our solutions are applicable to other scenarios. Other tricks are in the following. + Please pay attention to how many papers and how many efforts exist. You may want to be at the beginning (0-2 papers) or not later than the peak (it depends.) of the publication wave related to our problems.","title":"How to evaluate the problems"},{"location":"posts/2021-09-07-Research-Philosophy/#how-to-evaluate-the-ideas","text":"Remember that not all ideas can be accepted by top-tier conferences. One is the novelty , and the other is superiority . To be novel, we have to do a literature review and distinguish our idea from others\u2019. Because of the time budget, we cannot make our idea superior to others in every aspect, and thus we can choose the core metrics. The core metrics evolve among the development of the whole community. Some technology becomes mature such that some metrics are easier to achieve. Such easier metrics are not the core metrics but that we have to include. Consider all techniques we can use to be superior. OK. Let us do it! To save time, we are not supposed to make many mistakes. Nowadays, the computer science research community is competitive because not only most of the problems are easier to solve but also more and more people join us. When reviewers scan a manuscript, they pick up our mistakes and reject the papers that have more. Here are some tips from past research activities to evaluate our ideas quickly.","title":"How to evaluate the ideas"},{"location":"posts/2021-09-07-Research-Philosophy/#budge-our-time","text":"Tell ourselves the DDL is truly two weeks in advance. Always consider what we are doing to be some paragraph in the paper and never do it twice. Think and ask ourselves about what is the fastest way to do this and then do it. Spend 30 seconds more to save us from a 30 mins disaster. It is the context switch that wastes a lot of time. Spend less than one day on a project we are not the first author. Take holidays every four or five months: e.g., Chinese Spring Festivals, Labor Days, and National Holidays.","title":"Budge our time"},{"location":"posts/2021-09-07-Research-Philosophy/#know-what-we-are-going-to-do","text":"Review papers, run their systems, and write the summary (related work) Identify challenges and evaluate solutions in theory (challenges, insights, solutions) Design system and evaluate design choices in theory (background, system design) Implement a generic prototype and write evaluation scripts (implementation, evaluation) Write our paper in advance and get feedback from others .","title":"Know what we are going to do"},{"location":"posts/2021-09-07-Research-Philosophy/#set-up-servers","text":"What architectures should you use? How many servers do you have? If you are in the sudo group? Save runtime/intermediate data on SSD and save results on HDD. If there is no storage? Buy more! If you disabled the hyper-threading?","title":"Set up servers"},{"location":"posts/2021-09-07-Research-Philosophy/#write-evaluation-scripts","text":"All in Docker container. Make it parallel. Quick results first, middle-long results for writing, then long time evaluation for submission. Diversity first, then quantity.","title":"Write evaluation scripts"},{"location":"posts/2021-09-07-Research-Philosophy/#some-tips-about-parallel-tasks","text":"Be busy when it is busy and have fun when it is not busy Create a task, think about the solutions, importantly, think about why our results are not correct Write our task down before we start and close it after we finish it ( I am using Marp (Markdown Slides). ) Do not delete any data if we are definitely sure. Just buy more storage! Utilize all hardware resources we have. Do not make them have a rest.","title":"Some tips about parallel tasks"},{"location":"posts/2021-09-07-Research-Philosophy/#how-to-sell-our-idea","text":"","title":"How to sell our idea"},{"location":"posts/2021-09-07-Research-Philosophy/#some-techniques","text":"Tell a logical and clear story. Minimize disadvantages. If existing metrics cannot show better results, define a new one.","title":"Some techniques"},{"location":"posts/2021-09-07-Research-Philosophy/#write-a-good-paper","text":"Keep learning to write a paper Reader-centered writing Unity, Support, and Coherent Revise context and sentences, and do editing","title":"Write a good paper"},{"location":"posts/2021-09-07-Research-Philosophy/#a-detailed-analysis","text":"What we cannot control How many papers were submitted to a conference and the target acceptance rate. Which reviewers would revise our paper, and how well they know about what we are doing. What we can control Importance/Novelty/Superior Reasonable techniques and good enough implementation Clear writing Handle small flaws Clear writing Each paragraph has its goal. Make sure the topic sentence highlight the goal. A strong argument includes 1) point, 2) theoretical argument (papers), 3) factual argument (data). Be confident but do not overclaim. Be critical but be not rude. Keep in mind that reviewers do not join our group meetings, so do not expect too much! Keep a common storyline and make one sentence unique meaning. Storyline Importance, limitations of existing work, new theory and new techniques, evaluation Title: Summary of our work; Be attractive; No details Abstract: 2-minute storyline; Use hypernyms; No technical details; Introduction: 10-minute storyline; Show rationals; No concrete details; Backgroud: Big background; Terminologies; Motivating Example System, Implementation, and Evaluation: Problems -> Approaches -> Why -> How well Related work: Introduce related works and Highlight the difference Discussion: Answer reviewers' questions and hint the future work Conclusion: Summarize and extract new knowledge","title":"A detailed analysis"},{"location":"posts/2021-09-07-Research-Philosophy/#advertise","text":"Homepage Twitteriture Group Main conference session Poster session","title":"Advertise"},{"location":"posts/2021-09-07-Research-Philosophy/#how-to-solve-a-problem-wip","text":"This section is new and inspired by some social science disciplines. In general, we will define a problem as a computation problem in computer science. In practice, we will use possible threat models, system primitives, existing tools, and existing algorithms. Besides, we think about decidability, time, and storage complexity. However, we can do more than that.","title":"How to solve a problem (WIP)"},{"location":"posts/2021-09-07-Research-Philosophy/#classification","text":"Classification is the first naive and powerful tool we are supposed to use. In fact, we use this tool implicitly every day. When we are talking about fuzzers, we will split them into black-box, white-box, and grey-box fuzzers. If someone asks we what is this, why is this, and how is this, probably the first answer is to ask what categories are of \"this\". If someone asks we what our favourite food is, we may ask: what categories of food we are asking?","title":"Classification"},{"location":"posts/2021-10-22-fuzzing-presentation/","text":"CS-725 Presentation - Fuzz Testing This is the text of my speech in CS-725. This text is about fuzz testing, its terminologies, a generic model fuzzer with different design choices, and some discussion about the future work. This text is mainly based on one survey[^1] and take some content from another review article[^2]. Text (25 min: ~2800 words) and Slides Hello every. I'm going to present some slides on fuzzing, or fuzz testing, based on one survey paper (reading its name on Slide~1) that was accepted by TSE'19 and one review article (reading its name on Slide~1) written by Patrice Godefroid, working at Microsoft Research, a pioneer of white-box fuzzing. Mostly, slides are from the first survey paper because it's a journal paper through peer reviews. Some slides are from the second review article and I will let you know by an asterisk (*) symbol. (90/170, 40 s) (skipped) Let's start. Let's think about how we mine vulnerabilities in general. As Patrice said in its review paper, we could first apply static program analysis. We can do static program analysis when compiling a binary. As we all know, both GCC and Clang have many checkers. For instance, Clang has checks of insecure APIs, float loop counters, in its current implementation. Compared to run-time solutions, these checkers are fast and good at shallow bugs. However, they suffer from false alarms will miss deeper bugs. Second, we could manually review the code. Apparently, it is flexible and applicable because we do not need much tooling to start if we have the source code or any disassembly. With manual inspection, we can even find deep coding errors and even design flaws. However, this approach is labor-intensive, expensive, and not scalable to lot of software at the same time. The third major approach is fuzzing or fuzz testing, which is also the topic of this presentation. Patrice suggests using fuzzing because they can always find bugs when they fuzz projects in Microsoft, showing the effectiveness of fuzzing. Meanwhile, fuzzing doesn't report false alarms mostly. Fuzzing has its drawbacks. Fuzzing requires test automation and requires each test to run fast and the application state to be reset after each iteration. It is difficult to set up and expensive. Fuzzing can miss bugs as well. In practice, fuzzing is so effective that has been widely deployed by attackers, security competitions, and companies like Microsoft and Google. The fuzzing community is very vibrant. GitHub itself hosts over a thousand public repositories related to fuzzing and as counted in the survey paper, from 2008 to 2019, the big-4 security conferences and three major software engineering conferences have witnessed more than 110 fuzzers. Recently, the number of fuzzing-related papers is 78. Are there any problems? First, the description of fuzzers doesn't go much beyond their source code and manual page. It is easy to lose track of the design decisions and potentially important tweaks (or improvements) in these fuzzers over time. Furthermore, various fuzzers do not always use the same terminologies. AFL uses \"test case minimization\" to refer to a technique that reduces the size of a crashing input. The same technique in funfuzz is called \"test case reduction\". This kind of hinders our communication and the progress of knowledge. According to the above two problems, we need to consolidate the distill a large amount of progress in fuzzing, and hopefully improve it. (160/568, 1 min) Here is the outline of this presentation. First, I will introduce a serial of terminologies in fuzz testing and then introduce a unified fuzzing model that covers different stages when we do fuzzing, such as preprocessing and input evaluation. The major and final part of this presentation is to introduce the design choices in each stage and trade-offs we can and should make. (60/634, 30 s) Let's review some terminologies in fuzzing. Before some definitions, let's see what is a PUT: A PUT is a program under test, which I think is from the software engineering aspect. So, what is fuzzing? Fuzzing is the execution of the PUT using input(s) sampled from an input space that protrudes the expected input space of the PUT. The key word here is protruding, reflecting the meaning that an unexpected input makes a PUT performs incorrectly and unintended. The fuzz testing is then the use of fuzzing to test if a PUT violates a correctness policy; the fuzzer is then a program that performs fuzz testing on a PUT; the fuzzing campaign, namely, is a specific execution of a fuzzer on a PUT with a specific correctness policy. The next important definition is \"bug oracle\", which defines how a fuzzing campaign violates a correctness policy. The correctness policy reflects the bug oracle rather than, say, performance issues. Fuzzing itself can be applied in other non-security scenarios by altering the corresponding policy. A fuzzer requires not only the PUT but also some extensive information, e.g., coverage information, that is, fuzz configuration. These are parameter values that control the fuzz algorithm. A seed pool is another kind of fuzz configuration. (210/842, 2 min) Here is the model fuzzer, the algorithm in the figure. This algorithm is generic enough to accommodate existing fuzzing techniques, including black-, grey-, and white-box fuzzing. Let's check this algorithm. It has two inputs, a set of fuzz configurations and a timeout. Its output is a set of bugs. The algorithm has two parts. The first part is to preprocess the fuzz configurations, such as PUT instrumentation. The second part goes into a loop. In this loop, the model fuzzer will schedule the fuzz configurations, generate an input, evaluation the input, and update the configuration set. I will explain them one by one in the following. Before going on, I'd like to introduce three groups of fuzzers that would be used in the following presentation. Based on the granularity of semantics fuzzers can obverse, they have three groups. The black-box fuzzer doesn't see the internals of the PUT, that is, it can only observe the input/out behaviors of the PUT. At the other extreme, white-box fuzzing generates test cases by analyzing the internals of the PUT and gathering the information when executing the PUT with symbolic execution or taint analysis. What in the middle is the grey-box fuzzer. They may perform lightweight static analysis on the PUT and/or gather dynamic information about its execution, such as code coverage. The distinction is not always clear. Sometimes, it needs human's judgment. (230/1077, 2 mins) Some fuzzers have to preprocess the set of configurations. They usually instrument the PUT, select seeds, trim seeds, and sometimes use a driver application to dispatch seed when it is hard to directly fuzz the PUT. The survey paper didn't say much about the driver application, such that I'd like put it shortly in advance. The driver application is usually manually constructed, which is a one-time effort. Recently, several papers tried to automatically construct the driver application, e.g., FuzzGen, WINNE, APICraft. The driver application is diverse in implementation, which depends on the PUT you'd like to fuzz. (100/1171, 40 s) Let's check the design decisions in instrumentation. Program instrumentation can be either static or dynamic. The former happens before the PUT runs. It can operate source code, IR, or binary. The latter happens while the PUT is running. The static instrumentation generally imposes less run-time overhead. The dynamic instrumentation is good at handling libraries. What are the usage scenarios of the instrumentation? First, instrumentation can be used to collect execution feedback. AFL, libFuzzer, and its descendants compute the branch coverage and store the coverage in a compact bit vector. It is straightforward but has path collisions. Second, instrumentation can be used to schedule threads to trigger different non-deterministic program behaviors. In practice, random scheduling works effectively to discover race condition bugs. The final one is in-memory fuzzing. Sometimes, we want to test a portion of a large PUT to save the time of initialization or startup. Two popular techniques are snapshot and fork server. The former usually has one process, and the latter creates new processes. Next, what if we don't restore the state of the PUT after each iteration, which is named in-memory API fuzzing. A particular example is AFL persistent mode. This technique has side effects: bugs (or crashes) may not be reproducible. In ViDeZZo, we take this technique to accelerate the fuzzing campaign. If the bug or crash cannot be reproducible, we will save all test cases in order, and use delta-debugging to find all necessary test cases. (250/1420, 2 mins) The second and third parts of preprocessing are seed selection and seed trimming. We don't want all the seeds when the number of seeds is large and each of them doesn't equally contribute. The common approach is minset, which tries to find a minimal set of seeds that maximizes a coverage metric. What can be the coverage metric? AFL's minset is based on branch coverage with a logarithmic counter. The rationale behind this is to consider branch counts as different only when they differ in their orders of magnitude. Honggfuzz computes coverage based on the number of executed instructions, executed branches, and unique basic blocks. This metric allows the fuzzer to add longer executions to the minset. When it comes to seed trimming, the goal is to make seeds smaller because they are likely to consume less memory and entail higher throughput. Different tools have different intuitions. AFL reduces the size of a seed by the code coverage. A USec'14 paper shows that the seed with a smaller size might be better. MoonShines tells us we should keep the dependent syscalls. BTW, both of them can be performed in the fuzzing loop, in UpdateConf, after the input evaluation. (200/1621, 2 mins) Fuzzing scheduling means selecting a fuzz configuration for the next fuzz iteration. For more and more advanced fuzzers, a major factor to their success lies in their innovative scheduling algorithms. They usually optimize for the number of bugs or code coverage. They select a better seed entailing more bugs and coverage. From the aspect of game theory, there is a scheduling problem. Fundamentally, every scheduling algorithm confronts the same exploration v.s. exploitation conflict - time can either be spent on gathering more accurate information on each configuration to inform future decisions or on fuzzing the configurations that are currently believed to lead to more favorable outcomes. In the model fuzzer, the schedule function accepts three inputs: the current configuration C with new information gathered in preprocessing or conf updating, the current time, and the total time budget. For black-box fuzzers, the only information is the fuzz outcomes, the number of crashes and bugs and the amount of time spent on it so far. For grey-box fuzzers, they can obtain richer information about each configuration, e.g., the code coverage. AFL, the pioneer, is based on an evolutionary algorithm. Intuitively, an EA maintains a population of configurations, each with some values of fitnesses. Fitness defines how better a test case is. (230/1850, 2 min) The input generation is the most influential design decision in a fuzzer because the content of the input directly triggers a bug. In general, the input generation can be model-based or model-less, which is also named generation- or mutation-based. Model-based or generation-based input generation uses a given model that describes the inputs that the PUT may accept. The model can be predefined. The model can be tool-specific, or grammar, or protocol, or system call templates, or file formats. It depends on the type of input of your PUT. Predefined models are reasonable when the number of models is limited. Patrice said in his review article that how to xxx is another challenge. The model inference can happen in either preprocessing or conf updating. In reprocessing, the model can be inferred from the binary itself, from seeds, or from API logs. In configuration updating, the model can be from kinds of dynamic behaviors. Another type of model is the encoder model. What is an encoder? Many file formats have their decoders and corresponding encoders. The idea behind this is if we can mutate the encoder, we can generate semantic-aware inputs. This design choice can be implemented with program slicing. The model-less input generation, or mutation-based input generation, is a part of the evolutionary algorithm. It can perform bit-flipping. As shown in previous papers, each PUT has a specific mutation ratio. It can perform arithmetic mutation. The mutation first cast 4 bytes to an integer and then does plus or minus operation. It can also perform block-based mutation. Namely, a block is several bytes. The mutation can add, append, delete, replace, shuffle, or crossover these blocks. It can also use the dictionary. The dictionary has a set of strings or bytes that are difficult to guess but helpful to breakthrough some checks. (300/2151, 3 mins) What about the white-box fuzzers? White-box fuzzers generate test cases via dynamic symbolic execution. It is expensive. As said in the review article written by Patrice, how to. In practice, we can specify uninterested parts of a PUT or alternate between concolic testing and grey-box fuzzing. The concolic testing is on-demand when the fuzzer needs it to solve some constraints. Some fuzzers leverage static or dynamic program analysis to boost the fuzzing effectiveness. They usually have two steps. Step 1: heavy program analysis; step 2: test case generation. For example, some fuzzers use taint analysis to identify hot bytes in an input. The hots bytes flow to target APIs or syscalls. Some fuzzers extract the control or data flow features of the PUT and guide the input generation. Another interesting direction is to change the PUT and recover it when reproducing. For example, we can remove the checksum checks in the PUT and add them when reproducing a crash. We can also remove the non-critical checks to boost the fuzzing outcomes. (200/2352, 2 mins) After the input generation, the fuzzer executes the PUT on the input and decides what to do the resulting execution. This process is called input evaluation. Here, we have bug oracles, execution optimization, and triage in the next slide. At the very beginning, fuzz testing considers every PUT terminates by a fatal signal. This policy is simple and easy to enforce. However, it cannot detect memory bugs. As mitigation, researchers have proposed a variety of efficient program transformations to detect unsafe or unwanted program behaviors and abort the program. These are often called sanitizers. Memory safety errors can be spatial and temporal. AddressSanitizer is useful to detect many memory safety errors. Besides, CFI enforcement is another class of memory safety protection. For other undefined behaviors, uninitialized memory, etc., can be detected by MSAN and UBSAN. In addition to sanitizers, fuzzers can validate input by manually specific patterns or differential testing. As we talked about in the instrumentation, to optimize the execution, fuzzers can use fork-server or in-memory fuzzing to avoid wasting the time of initialization or PUT reset. (150/2489, 1 min) The final part is to triage. It has three steps: deduplication, prioritization, and minimization. Deduplication is the process to remove the test case in the output that causes the same bug. Three are three techniques. First, stack backtrace hashing. It is widely used but \"some xxx\", which means that some test cases are not going to be removed. Second, coverage-based deduplication. The crash covered a previously unseen edge is a new test case that should be kept. Third, semantic-aware deduplication. This technique tries to find the root cause of a bug then remove the duplicated test cases. Next, how to prioritize the test cases due to the conflict of the number of bugs found and limited human resources. The prioritization is usually based on exploitability. This is fair, but we have to decide whether the bug can be exploited, which is another challenging problem. The final is to minimize the test cases. We mentioned test case minimization and trimming in preprocessing. The difference is that test case minimization here can leverage the bug oracle. This design choice can be implemented via delta-debugging or some other specific approaches, like C-Reduced. (200/2680, 2 min) Finally, we come to the configuration updating. Mostly black-box fuzzer don't update configuration because they are not aware of any execution information. White-box fuzzers generate a configuration for each generated test case. For an evolutionary algorithm, one of the most important parts is to add a new test case in the seed pool. Each test case has a fitness. The common approach is to check whether this test case contributes node or branch coverage. The fitness function is usually refined in many ways. For instance, AFL takes the number of token branches into consideration. VUzzer considers the weights of each BB. To avoid creating too many configurations, the fuzzer should maintain a minset. There are many variants here. We can either remove the configurations that not in the minset or mark them in-favorable. (130/2817, 1 min) All in all, the survey paper introduced rich taxonomy, a general-purpose model fuzzer, and design decision in each stage. Hopefully, it can bring more uniformity, particularly in the terminology and presentation of fuzzing algorithms. (30/2854, 30 s) Some selected comments CFI here is shitty for fuzzing, which should not be listed here. The initial set is under-valued. In this presentation, the initial set is part of the configuration. However, when we provide a good set of initial seeds, the fuzzer can only focus on exploitability. Pay attention to what are the problems in this field, what are solved, and what are not solved. Do you think this paper is useful for terminology uniformity? Answer: Yes, but I do not think we have the agreement in practice. Scholars create their own terminologies all the time. [^1]: The Art, Science, and Engineering of Fuzzing: A Survey \\ [^2]: Fuzzing: Hack, Art, and Science","title":"CS-725 Presentation - Fuzz Testing"},{"location":"posts/2021-10-22-fuzzing-presentation/#cs-725-presentation-fuzz-testing","text":"This is the text of my speech in CS-725. This text is about fuzz testing, its terminologies, a generic model fuzzer with different design choices, and some discussion about the future work. This text is mainly based on one survey[^1] and take some content from another review article[^2].","title":"CS-725 Presentation - Fuzz Testing"},{"location":"posts/2021-10-22-fuzzing-presentation/#text-25-min-2800-words-and-slides","text":"Hello every. I'm going to present some slides on fuzzing, or fuzz testing, based on one survey paper (reading its name on Slide~1) that was accepted by TSE'19 and one review article (reading its name on Slide~1) written by Patrice Godefroid, working at Microsoft Research, a pioneer of white-box fuzzing. Mostly, slides are from the first survey paper because it's a journal paper through peer reviews. Some slides are from the second review article and I will let you know by an asterisk (*) symbol. (90/170, 40 s) (skipped) Let's start. Let's think about how we mine vulnerabilities in general. As Patrice said in its review paper, we could first apply static program analysis. We can do static program analysis when compiling a binary. As we all know, both GCC and Clang have many checkers. For instance, Clang has checks of insecure APIs, float loop counters, in its current implementation. Compared to run-time solutions, these checkers are fast and good at shallow bugs. However, they suffer from false alarms will miss deeper bugs. Second, we could manually review the code. Apparently, it is flexible and applicable because we do not need much tooling to start if we have the source code or any disassembly. With manual inspection, we can even find deep coding errors and even design flaws. However, this approach is labor-intensive, expensive, and not scalable to lot of software at the same time. The third major approach is fuzzing or fuzz testing, which is also the topic of this presentation. Patrice suggests using fuzzing because they can always find bugs when they fuzz projects in Microsoft, showing the effectiveness of fuzzing. Meanwhile, fuzzing doesn't report false alarms mostly. Fuzzing has its drawbacks. Fuzzing requires test automation and requires each test to run fast and the application state to be reset after each iteration. It is difficult to set up and expensive. Fuzzing can miss bugs as well. In practice, fuzzing is so effective that has been widely deployed by attackers, security competitions, and companies like Microsoft and Google. The fuzzing community is very vibrant. GitHub itself hosts over a thousand public repositories related to fuzzing and as counted in the survey paper, from 2008 to 2019, the big-4 security conferences and three major software engineering conferences have witnessed more than 110 fuzzers. Recently, the number of fuzzing-related papers is 78. Are there any problems? First, the description of fuzzers doesn't go much beyond their source code and manual page. It is easy to lose track of the design decisions and potentially important tweaks (or improvements) in these fuzzers over time. Furthermore, various fuzzers do not always use the same terminologies. AFL uses \"test case minimization\" to refer to a technique that reduces the size of a crashing input. The same technique in funfuzz is called \"test case reduction\". This kind of hinders our communication and the progress of knowledge. According to the above two problems, we need to consolidate the distill a large amount of progress in fuzzing, and hopefully improve it. (160/568, 1 min) Here is the outline of this presentation. First, I will introduce a serial of terminologies in fuzz testing and then introduce a unified fuzzing model that covers different stages when we do fuzzing, such as preprocessing and input evaluation. The major and final part of this presentation is to introduce the design choices in each stage and trade-offs we can and should make. (60/634, 30 s) Let's review some terminologies in fuzzing. Before some definitions, let's see what is a PUT: A PUT is a program under test, which I think is from the software engineering aspect. So, what is fuzzing? Fuzzing is the execution of the PUT using input(s) sampled from an input space that protrudes the expected input space of the PUT. The key word here is protruding, reflecting the meaning that an unexpected input makes a PUT performs incorrectly and unintended. The fuzz testing is then the use of fuzzing to test if a PUT violates a correctness policy; the fuzzer is then a program that performs fuzz testing on a PUT; the fuzzing campaign, namely, is a specific execution of a fuzzer on a PUT with a specific correctness policy. The next important definition is \"bug oracle\", which defines how a fuzzing campaign violates a correctness policy. The correctness policy reflects the bug oracle rather than, say, performance issues. Fuzzing itself can be applied in other non-security scenarios by altering the corresponding policy. A fuzzer requires not only the PUT but also some extensive information, e.g., coverage information, that is, fuzz configuration. These are parameter values that control the fuzz algorithm. A seed pool is another kind of fuzz configuration. (210/842, 2 min) Here is the model fuzzer, the algorithm in the figure. This algorithm is generic enough to accommodate existing fuzzing techniques, including black-, grey-, and white-box fuzzing. Let's check this algorithm. It has two inputs, a set of fuzz configurations and a timeout. Its output is a set of bugs. The algorithm has two parts. The first part is to preprocess the fuzz configurations, such as PUT instrumentation. The second part goes into a loop. In this loop, the model fuzzer will schedule the fuzz configurations, generate an input, evaluation the input, and update the configuration set. I will explain them one by one in the following. Before going on, I'd like to introduce three groups of fuzzers that would be used in the following presentation. Based on the granularity of semantics fuzzers can obverse, they have three groups. The black-box fuzzer doesn't see the internals of the PUT, that is, it can only observe the input/out behaviors of the PUT. At the other extreme, white-box fuzzing generates test cases by analyzing the internals of the PUT and gathering the information when executing the PUT with symbolic execution or taint analysis. What in the middle is the grey-box fuzzer. They may perform lightweight static analysis on the PUT and/or gather dynamic information about its execution, such as code coverage. The distinction is not always clear. Sometimes, it needs human's judgment. (230/1077, 2 mins) Some fuzzers have to preprocess the set of configurations. They usually instrument the PUT, select seeds, trim seeds, and sometimes use a driver application to dispatch seed when it is hard to directly fuzz the PUT. The survey paper didn't say much about the driver application, such that I'd like put it shortly in advance. The driver application is usually manually constructed, which is a one-time effort. Recently, several papers tried to automatically construct the driver application, e.g., FuzzGen, WINNE, APICraft. The driver application is diverse in implementation, which depends on the PUT you'd like to fuzz. (100/1171, 40 s) Let's check the design decisions in instrumentation. Program instrumentation can be either static or dynamic. The former happens before the PUT runs. It can operate source code, IR, or binary. The latter happens while the PUT is running. The static instrumentation generally imposes less run-time overhead. The dynamic instrumentation is good at handling libraries. What are the usage scenarios of the instrumentation? First, instrumentation can be used to collect execution feedback. AFL, libFuzzer, and its descendants compute the branch coverage and store the coverage in a compact bit vector. It is straightforward but has path collisions. Second, instrumentation can be used to schedule threads to trigger different non-deterministic program behaviors. In practice, random scheduling works effectively to discover race condition bugs. The final one is in-memory fuzzing. Sometimes, we want to test a portion of a large PUT to save the time of initialization or startup. Two popular techniques are snapshot and fork server. The former usually has one process, and the latter creates new processes. Next, what if we don't restore the state of the PUT after each iteration, which is named in-memory API fuzzing. A particular example is AFL persistent mode. This technique has side effects: bugs (or crashes) may not be reproducible. In ViDeZZo, we take this technique to accelerate the fuzzing campaign. If the bug or crash cannot be reproducible, we will save all test cases in order, and use delta-debugging to find all necessary test cases. (250/1420, 2 mins) The second and third parts of preprocessing are seed selection and seed trimming. We don't want all the seeds when the number of seeds is large and each of them doesn't equally contribute. The common approach is minset, which tries to find a minimal set of seeds that maximizes a coverage metric. What can be the coverage metric? AFL's minset is based on branch coverage with a logarithmic counter. The rationale behind this is to consider branch counts as different only when they differ in their orders of magnitude. Honggfuzz computes coverage based on the number of executed instructions, executed branches, and unique basic blocks. This metric allows the fuzzer to add longer executions to the minset. When it comes to seed trimming, the goal is to make seeds smaller because they are likely to consume less memory and entail higher throughput. Different tools have different intuitions. AFL reduces the size of a seed by the code coverage. A USec'14 paper shows that the seed with a smaller size might be better. MoonShines tells us we should keep the dependent syscalls. BTW, both of them can be performed in the fuzzing loop, in UpdateConf, after the input evaluation. (200/1621, 2 mins) Fuzzing scheduling means selecting a fuzz configuration for the next fuzz iteration. For more and more advanced fuzzers, a major factor to their success lies in their innovative scheduling algorithms. They usually optimize for the number of bugs or code coverage. They select a better seed entailing more bugs and coverage. From the aspect of game theory, there is a scheduling problem. Fundamentally, every scheduling algorithm confronts the same exploration v.s. exploitation conflict - time can either be spent on gathering more accurate information on each configuration to inform future decisions or on fuzzing the configurations that are currently believed to lead to more favorable outcomes. In the model fuzzer, the schedule function accepts three inputs: the current configuration C with new information gathered in preprocessing or conf updating, the current time, and the total time budget. For black-box fuzzers, the only information is the fuzz outcomes, the number of crashes and bugs and the amount of time spent on it so far. For grey-box fuzzers, they can obtain richer information about each configuration, e.g., the code coverage. AFL, the pioneer, is based on an evolutionary algorithm. Intuitively, an EA maintains a population of configurations, each with some values of fitnesses. Fitness defines how better a test case is. (230/1850, 2 min) The input generation is the most influential design decision in a fuzzer because the content of the input directly triggers a bug. In general, the input generation can be model-based or model-less, which is also named generation- or mutation-based. Model-based or generation-based input generation uses a given model that describes the inputs that the PUT may accept. The model can be predefined. The model can be tool-specific, or grammar, or protocol, or system call templates, or file formats. It depends on the type of input of your PUT. Predefined models are reasonable when the number of models is limited. Patrice said in his review article that how to xxx is another challenge. The model inference can happen in either preprocessing or conf updating. In reprocessing, the model can be inferred from the binary itself, from seeds, or from API logs. In configuration updating, the model can be from kinds of dynamic behaviors. Another type of model is the encoder model. What is an encoder? Many file formats have their decoders and corresponding encoders. The idea behind this is if we can mutate the encoder, we can generate semantic-aware inputs. This design choice can be implemented with program slicing. The model-less input generation, or mutation-based input generation, is a part of the evolutionary algorithm. It can perform bit-flipping. As shown in previous papers, each PUT has a specific mutation ratio. It can perform arithmetic mutation. The mutation first cast 4 bytes to an integer and then does plus or minus operation. It can also perform block-based mutation. Namely, a block is several bytes. The mutation can add, append, delete, replace, shuffle, or crossover these blocks. It can also use the dictionary. The dictionary has a set of strings or bytes that are difficult to guess but helpful to breakthrough some checks. (300/2151, 3 mins) What about the white-box fuzzers? White-box fuzzers generate test cases via dynamic symbolic execution. It is expensive. As said in the review article written by Patrice, how to. In practice, we can specify uninterested parts of a PUT or alternate between concolic testing and grey-box fuzzing. The concolic testing is on-demand when the fuzzer needs it to solve some constraints. Some fuzzers leverage static or dynamic program analysis to boost the fuzzing effectiveness. They usually have two steps. Step 1: heavy program analysis; step 2: test case generation. For example, some fuzzers use taint analysis to identify hot bytes in an input. The hots bytes flow to target APIs or syscalls. Some fuzzers extract the control or data flow features of the PUT and guide the input generation. Another interesting direction is to change the PUT and recover it when reproducing. For example, we can remove the checksum checks in the PUT and add them when reproducing a crash. We can also remove the non-critical checks to boost the fuzzing outcomes. (200/2352, 2 mins) After the input generation, the fuzzer executes the PUT on the input and decides what to do the resulting execution. This process is called input evaluation. Here, we have bug oracles, execution optimization, and triage in the next slide. At the very beginning, fuzz testing considers every PUT terminates by a fatal signal. This policy is simple and easy to enforce. However, it cannot detect memory bugs. As mitigation, researchers have proposed a variety of efficient program transformations to detect unsafe or unwanted program behaviors and abort the program. These are often called sanitizers. Memory safety errors can be spatial and temporal. AddressSanitizer is useful to detect many memory safety errors. Besides, CFI enforcement is another class of memory safety protection. For other undefined behaviors, uninitialized memory, etc., can be detected by MSAN and UBSAN. In addition to sanitizers, fuzzers can validate input by manually specific patterns or differential testing. As we talked about in the instrumentation, to optimize the execution, fuzzers can use fork-server or in-memory fuzzing to avoid wasting the time of initialization or PUT reset. (150/2489, 1 min) The final part is to triage. It has three steps: deduplication, prioritization, and minimization. Deduplication is the process to remove the test case in the output that causes the same bug. Three are three techniques. First, stack backtrace hashing. It is widely used but \"some xxx\", which means that some test cases are not going to be removed. Second, coverage-based deduplication. The crash covered a previously unseen edge is a new test case that should be kept. Third, semantic-aware deduplication. This technique tries to find the root cause of a bug then remove the duplicated test cases. Next, how to prioritize the test cases due to the conflict of the number of bugs found and limited human resources. The prioritization is usually based on exploitability. This is fair, but we have to decide whether the bug can be exploited, which is another challenging problem. The final is to minimize the test cases. We mentioned test case minimization and trimming in preprocessing. The difference is that test case minimization here can leverage the bug oracle. This design choice can be implemented via delta-debugging or some other specific approaches, like C-Reduced. (200/2680, 2 min) Finally, we come to the configuration updating. Mostly black-box fuzzer don't update configuration because they are not aware of any execution information. White-box fuzzers generate a configuration for each generated test case. For an evolutionary algorithm, one of the most important parts is to add a new test case in the seed pool. Each test case has a fitness. The common approach is to check whether this test case contributes node or branch coverage. The fitness function is usually refined in many ways. For instance, AFL takes the number of token branches into consideration. VUzzer considers the weights of each BB. To avoid creating too many configurations, the fuzzer should maintain a minset. There are many variants here. We can either remove the configurations that not in the minset or mark them in-favorable. (130/2817, 1 min) All in all, the survey paper introduced rich taxonomy, a general-purpose model fuzzer, and design decision in each stage. Hopefully, it can bring more uniformity, particularly in the terminology and presentation of fuzzing algorithms. (30/2854, 30 s)","title":"Text (25 min: ~2800 words) and Slides"},{"location":"posts/2021-10-22-fuzzing-presentation/#some-selected-comments","text":"CFI here is shitty for fuzzing, which should not be listed here. The initial set is under-valued. In this presentation, the initial set is part of the configuration. However, when we provide a good set of initial seeds, the fuzzer can only focus on exploitability. Pay attention to what are the problems in this field, what are solved, and what are not solved. Do you think this paper is useful for terminology uniformity? Answer: Yes, but I do not think we have the agreement in practice. Scholars create their own terminologies all the time. [^1]: The Art, Science, and Engineering of Fuzzing: A Survey \\ [^2]: Fuzzing: Hack, Art, and Science","title":"Some selected comments"},{"location":"posts/2021-10-27-introduction-to-bhyve/","text":"Introduction to Bhyve In this short article, I'm going to introduce what is Bhyve, how it works, and how to modify it. What is Bhyve?[^1][^2][^3] Bhyve, pronounced \"beehive\", is a hypervisor for FreeBSD. Bhyve runs on x86_64 host and supports i386 and x86_64 guests. Bhyve requires VT-x/EPT CPU support (core i*). Bhyve consists of a kernel module: vmm.ko , a library libvmmapi , and some utilities bhyve , bhyveload , and bhyvectl . Yes, it works as a kernel model like KVM . The source code is in the FreeBSD SVN source repository: sys/amd64/vmm/, usr.sbin/bhyve/, usr.sbin/bhyveload/, usr.sbin/bhyvectl/, and lib/libvmmapi/ Variants: xhyve [^4], Pluribus Netvisor , bhyve in Illumos-based distributions . Components[^5] component functionality vmm.ko VT-x, local APCI, VT-d for PCI pass-thru, guest phymem mgmt, user-space cdev-interface bhyveload user-space bootloader, userboot lib + bhyve API, creates VM, lays out kernel + metadata, sets up initial VM register state bhyve user-space run loop, PCI bus/device emulation, device backends, threads for vCPU, i/o devs, kqueue loop bhyvectl dump/modify VM state, dump VM stats, delete VMs libvmmapi userland API Dismistafication vhyveload only supports FreeBSD, grub2-bhyve can load Linux and OpenBSD each /dev/vmm/${vmname} contains each VM instance state VMX-root: hypervisor, VMX-non-root: VM VMX (VMCS-maintenace) instructions VMPTRLD \u2014 It makes the referenced VMCS active and current. VMPTRST \u2014 The current-VMCS pointer is stored into the destination operand. VMCLEAR \u2014 The instruction sets the launch state of the VMCS referenced by the operand to \u201cclear\u201d, renders that VMCS inactive, and ensures that data for the VMCS have been written to the VMCS-data area in the referenced VMCS region. If the operand is the same as the current-VMCS pointer, that pointer is made invalid. VMREAD \u2014 This instruction reads a component from a VMCS. VMWRITE \u2014 This instruction writes a component to a VMCS. VMLAUNCH \u2014 This instruction launches a virtual machine managed by the VMCS. A VM entry occurs, transferring control to the VM. VMRESUME \u2014 This instruction resumes a virtual machine managed by the VMCS. A VM entry occurs, transferring control to the VM. VMXOFF \u2014 This instruction causes the processor to leave VMX operation. VMXON \u2014 It causes a logical processor to enter VMX root operation. (vmm_init -> vm_init -> vm_enable -> vmxon) INVEPT \u2014 This instruction invalidates entries in the TLBs and paging-structure caches that were derived from extended page tables (EPT). INVVPID \u2014 This instruction invalidates entries in the TLBs and paging-structure caches based on a VirtualProcessor Identifier (VPID). VMCALL \u2014 This instruction allows software in VMX non-root operation to call the VMM for service. A VM exit occurs, transferring control to the VMM. VMFUNC \u2014 This instruction allows software in VMX non-root operation to invoke a VM function (processor functionality enabled and configured by software in VMX root operation) without a VM exit. Some data structs #define VM_MAXCPU 8 struct vm_exit { enum vm_exitcode exitcode; int inst_length; /* 0 means unknown */ uint64_t rip; union { struct {} inout; // direction, how many bytes, port number, eax for out struct {} paging; struct {} vmx; struct {} msr; } u; }; struct vm_exit vmexit[VM_MAXCPU]; The above code defines exit information for each virtual cpu. BHyve VMExit code code handler description next VM_EXITCODE_INOUT vmexit_inout in and out instructions VMEXIT_CONTINUE or VMEXIT_ABORT VM_EXITCODE_VMX vmexit_vmx vm exit VMEXIT_ABORT VM_EXITCODE_BOGUS vmexit_bogus VMEXIT_RESTART or VMEXIT_SWITCH VM_EXITCODE_RDMSR vmexit_rdmsr Local APIC VMEXIT_ABORT VM_EXITCODE_WRMSR vmexit_wrmsr -> emulate_wrmsr Local APIC VMEXIT_CONTINUE or VMEXIT_SWITCH VM_EXITCODE_MTRAP vmexit_mtrap VMEXIT_RESTART VM_EXITCODE_PAGING vmexit_paging -> emulate_instruction VMEXIT_CONTINUE or VMEXIT_ABORT Example: vmexit_inout static int vmexit_inout(struct vmctx *ctx, struct vm_exit *vme, int *pvcpu) { // ignore ins/outs if (vme->u.inout.string || vme->u.inout.rep) return (VMEXIT_ABORT); // reset: out 0x64, 0xFE -> vmexit_catch_reset -> VMEXIT_RESET if (out && port == 0x64 && (uint8_t)eax == 0xFE) return (vmexit_catch_reset()); // host notification: out 0x488, {0, 1, 5} -> VMEXIT_CONTINUE if (out && port == GUEST_NIO_PORT) return (vmexit_handle_notify(ctx, vme, pvcpu, eax)); // handle other in/out error = emulate_inout(ctx, vcpu, in, port, bytes, &eax, strictio); if (error == 0 && in) error = vm_set_register(ctx, vcpu, VM_REG_GUEST_RAX, eax); if (error == 0) return (VMEXIT_CONTINUE); else { return (vmexit_catch_inout()); // VMEXIT_ABORT } } Some data structs #define SET_DECLARE(set, ptype) \\ extern ptype *__CONCAT(__start_set_,set); \\ extern ptype *__CONCAT(__stop_set_,set) #define SET_BEGIN(set) \\ (&__CONCAT(__start_set_,set)) #define SET_LIMIT(set) \\ (&__CONCAT(__stop_set_,set)) #define SET_FOREACH(pvar, set) \\ for (pvar = SET_BEGIN(set); pvar < SET_LIMIT(set); pvar++) #define SET_ITEM(set, i) \\ ((SET_BEGIN(set))[i]) #define SET_COUNT(set) \\ (SET_LIMIT(set) - SET_BEGIN(set)) SET_DECLARE(pci_devemu_set, struct pci_devemu); struct pci_devemu { char *pe_emu; /* Name of device emulation */ /* instance creation */ int (*pe_init)(struct vmctx *, struct pci_devinst *, char *opts); /* config space read/write callbacks */ int (*pe_cfgwrite)(...) int (*pe_cfgread)(...) /* I/O space read/write callbacks */ void (*pe_iow)(...) uint32_t (*pe_ior)(...) }; #ifdef __GNUCLIKE___SECTION #define __MAKE_SET(set, sym) \\ __GLOBL(__CONCAT(__start_set_,set)); \\ __GLOBL(__CONCAT(__stop_set_,set)); \\ static void const * const __set_##set##_sym_##sym \\ __section(\"set_\" #set) __used = &sym #else /* !__GNUCLIKE___SECTION */ #ifndef lint #error this file needs to be ported to your compiler #endif /* lint */ #define __MAKE_SET(set, sym) extern void const * const (__set_##set##_sym_##sym) #endif /* __GNUCLIKE___SECTION */ #define TEXT_SET(set, sym) __MAKE_SET(set, sym) #define DATA_SET(set, sym) __MAKE_SET(set, sym) #define BSS_SET(set, sym) __MAKE_SET(set, sym) #define ABS_SET(set, sym) __MAKE_SET(set, sym) #define SET_ENTRY(set, sym) __MAKE_SET(set, sym) PCI_EMUL_SET(pci_xxx); The above code defines name and callbacks of each PCI devices. Virtual devices (dummy means very low fidelity) (Old BHyve) peripheral file description atpic usr.sbin/bhyve/atpic.c dummy console usr.sbin/bhyve/consport.c ttyread|ttywrite gdbport usr.sbin/bhyve/dbgport.c bind, listen, accept, read|write elcr usr.sbin/bhyve/dbgport.c dummy pit 8254 usr.sbin/bhyve/pit_8254.c pit_8254_handler post usr.sbin/bhyve/post.c dummy rtc usr.sbin/bhyve/rtc.c rtc_addr_handler|rtc_data_handler uart usr.sbin/bhyve/uart.c dummy pci-dummy usr.sbin/bhyve/pci_emul.c pci_emul_dinit|pci_emul_diow|pci_emul_dior pci-hostbridge usr.sbin/bhyve/pci_hostbridge.c pci_hostbridge_init pci-passthru usr.sbin/bhyve/pci_passthru.c /dev/pci, /dev/io pci-uart usr.sbin/bhyve/pci_uart.c pci_uart_init|pci_uart_write|pci_uart_read pci-virtio-blk usr.sbin/bhyve/pci_virtio_block.c pci_vtblk_init|pci_vtblk_write|pci_vtblk_read pci-virtio-net usr.sbin/bhyve/pci_virtio_net.c pci_vtnet_init|pci_vtnet_write|pci_vtnet_read Virtual device initialization while (c = getopt()) switch (c) case 's': pci_parse_slot(optarg, 0); // not legacy break; case 'S': pci_parse_slot(optarg, 1); // legacy break; // ------------------------------ // pci_parse_slot // ------------------------------ // snum is from 0 to 31 // 0,hostbridge // 1,virtio-net,tap0 // pci_slotinfo[snum].si_name = emul; // hostbridge, virtio-net // pci_slotinfo[snum].si_param = config; // null, tap0 // pci_slotinfo[snum].si_legacy = legacy; // 0, 1 init_inout install handler for each port: atpic, console, gdbport, elcr, pci_emu, pit 8254, post, rtc, and uart. init_pci // it depends on opts pde = pci_emul_finddev(si->si_name); if (pde != NULL) { pci_emul_init(ctx, pde, i, si->si_param); // invoke ->init Extend BTest (like QTest) to BHyve The basic idea of BTest is to implement the same primitives as QTest. We can leverage PCI interfaces to implemented it because we are doing in-memory fuzzing rather than doing traps. [^1]: Homepage of Bhyve \\ [^2]: Wikipedia of Bhyve \\ [^3]: Q&A of Byyve \\ [^4]: xhyve \\ [^5]: Extending bhyve beyond FreeBD guests","title":"Introduction to Bhyve"},{"location":"posts/2021-10-27-introduction-to-bhyve/#introduction-to-bhyve","text":"In this short article, I'm going to introduce what is Bhyve, how it works, and how to modify it.","title":"Introduction to Bhyve"},{"location":"posts/2021-10-27-introduction-to-bhyve/#what-is-bhyve123","text":"Bhyve, pronounced \"beehive\", is a hypervisor for FreeBSD. Bhyve runs on x86_64 host and supports i386 and x86_64 guests. Bhyve requires VT-x/EPT CPU support (core i*). Bhyve consists of a kernel module: vmm.ko , a library libvmmapi , and some utilities bhyve , bhyveload , and bhyvectl . Yes, it works as a kernel model like KVM . The source code is in the FreeBSD SVN source repository: sys/amd64/vmm/, usr.sbin/bhyve/, usr.sbin/bhyveload/, usr.sbin/bhyvectl/, and lib/libvmmapi/ Variants: xhyve [^4], Pluribus Netvisor , bhyve in Illumos-based distributions .","title":"What is Bhyve?[^1][^2][^3]"},{"location":"posts/2021-10-27-introduction-to-bhyve/#components5","text":"component functionality vmm.ko VT-x, local APCI, VT-d for PCI pass-thru, guest phymem mgmt, user-space cdev-interface bhyveload user-space bootloader, userboot lib + bhyve API, creates VM, lays out kernel + metadata, sets up initial VM register state bhyve user-space run loop, PCI bus/device emulation, device backends, threads for vCPU, i/o devs, kqueue loop bhyvectl dump/modify VM state, dump VM stats, delete VMs libvmmapi userland API","title":"Components[^5]"},{"location":"posts/2021-10-27-introduction-to-bhyve/#dismistafication","text":"vhyveload only supports FreeBSD, grub2-bhyve can load Linux and OpenBSD each /dev/vmm/${vmname} contains each VM instance state VMX-root: hypervisor, VMX-non-root: VM","title":"Dismistafication"},{"location":"posts/2021-10-27-introduction-to-bhyve/#vmx-vmcs-maintenace-instructions","text":"VMPTRLD \u2014 It makes the referenced VMCS active and current. VMPTRST \u2014 The current-VMCS pointer is stored into the destination operand. VMCLEAR \u2014 The instruction sets the launch state of the VMCS referenced by the operand to \u201cclear\u201d, renders that VMCS inactive, and ensures that data for the VMCS have been written to the VMCS-data area in the referenced VMCS region. If the operand is the same as the current-VMCS pointer, that pointer is made invalid. VMREAD \u2014 This instruction reads a component from a VMCS. VMWRITE \u2014 This instruction writes a component to a VMCS. VMLAUNCH \u2014 This instruction launches a virtual machine managed by the VMCS. A VM entry occurs, transferring control to the VM. VMRESUME \u2014 This instruction resumes a virtual machine managed by the VMCS. A VM entry occurs, transferring control to the VM. VMXOFF \u2014 This instruction causes the processor to leave VMX operation. VMXON \u2014 It causes a logical processor to enter VMX root operation. (vmm_init -> vm_init -> vm_enable -> vmxon) INVEPT \u2014 This instruction invalidates entries in the TLBs and paging-structure caches that were derived from extended page tables (EPT). INVVPID \u2014 This instruction invalidates entries in the TLBs and paging-structure caches based on a VirtualProcessor Identifier (VPID). VMCALL \u2014 This instruction allows software in VMX non-root operation to call the VMM for service. A VM exit occurs, transferring control to the VMM. VMFUNC \u2014 This instruction allows software in VMX non-root operation to invoke a VM function (processor functionality enabled and configured by software in VMX root operation) without a VM exit.","title":"VMX (VMCS-maintenace) instructions"},{"location":"posts/2021-10-27-introduction-to-bhyve/#some-data-structs","text":"#define VM_MAXCPU 8 struct vm_exit { enum vm_exitcode exitcode; int inst_length; /* 0 means unknown */ uint64_t rip; union { struct {} inout; // direction, how many bytes, port number, eax for out struct {} paging; struct {} vmx; struct {} msr; } u; }; struct vm_exit vmexit[VM_MAXCPU]; The above code defines exit information for each virtual cpu.","title":"Some data structs"},{"location":"posts/2021-10-27-introduction-to-bhyve/#bhyve-vmexit-code","text":"code handler description next VM_EXITCODE_INOUT vmexit_inout in and out instructions VMEXIT_CONTINUE or VMEXIT_ABORT VM_EXITCODE_VMX vmexit_vmx vm exit VMEXIT_ABORT VM_EXITCODE_BOGUS vmexit_bogus VMEXIT_RESTART or VMEXIT_SWITCH VM_EXITCODE_RDMSR vmexit_rdmsr Local APIC VMEXIT_ABORT VM_EXITCODE_WRMSR vmexit_wrmsr -> emulate_wrmsr Local APIC VMEXIT_CONTINUE or VMEXIT_SWITCH VM_EXITCODE_MTRAP vmexit_mtrap VMEXIT_RESTART VM_EXITCODE_PAGING vmexit_paging -> emulate_instruction VMEXIT_CONTINUE or VMEXIT_ABORT","title":"BHyve VMExit code"},{"location":"posts/2021-10-27-introduction-to-bhyve/#example-vmexit_inout","text":"static int vmexit_inout(struct vmctx *ctx, struct vm_exit *vme, int *pvcpu) { // ignore ins/outs if (vme->u.inout.string || vme->u.inout.rep) return (VMEXIT_ABORT); // reset: out 0x64, 0xFE -> vmexit_catch_reset -> VMEXIT_RESET if (out && port == 0x64 && (uint8_t)eax == 0xFE) return (vmexit_catch_reset()); // host notification: out 0x488, {0, 1, 5} -> VMEXIT_CONTINUE if (out && port == GUEST_NIO_PORT) return (vmexit_handle_notify(ctx, vme, pvcpu, eax)); // handle other in/out error = emulate_inout(ctx, vcpu, in, port, bytes, &eax, strictio); if (error == 0 && in) error = vm_set_register(ctx, vcpu, VM_REG_GUEST_RAX, eax); if (error == 0) return (VMEXIT_CONTINUE); else { return (vmexit_catch_inout()); // VMEXIT_ABORT } }","title":"Example: vmexit_inout"},{"location":"posts/2021-10-27-introduction-to-bhyve/#some-data-structs_1","text":"#define SET_DECLARE(set, ptype) \\ extern ptype *__CONCAT(__start_set_,set); \\ extern ptype *__CONCAT(__stop_set_,set) #define SET_BEGIN(set) \\ (&__CONCAT(__start_set_,set)) #define SET_LIMIT(set) \\ (&__CONCAT(__stop_set_,set)) #define SET_FOREACH(pvar, set) \\ for (pvar = SET_BEGIN(set); pvar < SET_LIMIT(set); pvar++) #define SET_ITEM(set, i) \\ ((SET_BEGIN(set))[i]) #define SET_COUNT(set) \\ (SET_LIMIT(set) - SET_BEGIN(set)) SET_DECLARE(pci_devemu_set, struct pci_devemu); struct pci_devemu { char *pe_emu; /* Name of device emulation */ /* instance creation */ int (*pe_init)(struct vmctx *, struct pci_devinst *, char *opts); /* config space read/write callbacks */ int (*pe_cfgwrite)(...) int (*pe_cfgread)(...) /* I/O space read/write callbacks */ void (*pe_iow)(...) uint32_t (*pe_ior)(...) }; #ifdef __GNUCLIKE___SECTION #define __MAKE_SET(set, sym) \\ __GLOBL(__CONCAT(__start_set_,set)); \\ __GLOBL(__CONCAT(__stop_set_,set)); \\ static void const * const __set_##set##_sym_##sym \\ __section(\"set_\" #set) __used = &sym #else /* !__GNUCLIKE___SECTION */ #ifndef lint #error this file needs to be ported to your compiler #endif /* lint */ #define __MAKE_SET(set, sym) extern void const * const (__set_##set##_sym_##sym) #endif /* __GNUCLIKE___SECTION */ #define TEXT_SET(set, sym) __MAKE_SET(set, sym) #define DATA_SET(set, sym) __MAKE_SET(set, sym) #define BSS_SET(set, sym) __MAKE_SET(set, sym) #define ABS_SET(set, sym) __MAKE_SET(set, sym) #define SET_ENTRY(set, sym) __MAKE_SET(set, sym) PCI_EMUL_SET(pci_xxx); The above code defines name and callbacks of each PCI devices.","title":"Some data structs"},{"location":"posts/2021-10-27-introduction-to-bhyve/#virtual-devices-dummy-means-very-low-fidelity-old-bhyve","text":"peripheral file description atpic usr.sbin/bhyve/atpic.c dummy console usr.sbin/bhyve/consport.c ttyread|ttywrite gdbport usr.sbin/bhyve/dbgport.c bind, listen, accept, read|write elcr usr.sbin/bhyve/dbgport.c dummy pit 8254 usr.sbin/bhyve/pit_8254.c pit_8254_handler post usr.sbin/bhyve/post.c dummy rtc usr.sbin/bhyve/rtc.c rtc_addr_handler|rtc_data_handler uart usr.sbin/bhyve/uart.c dummy pci-dummy usr.sbin/bhyve/pci_emul.c pci_emul_dinit|pci_emul_diow|pci_emul_dior pci-hostbridge usr.sbin/bhyve/pci_hostbridge.c pci_hostbridge_init pci-passthru usr.sbin/bhyve/pci_passthru.c /dev/pci, /dev/io pci-uart usr.sbin/bhyve/pci_uart.c pci_uart_init|pci_uart_write|pci_uart_read pci-virtio-blk usr.sbin/bhyve/pci_virtio_block.c pci_vtblk_init|pci_vtblk_write|pci_vtblk_read pci-virtio-net usr.sbin/bhyve/pci_virtio_net.c pci_vtnet_init|pci_vtnet_write|pci_vtnet_read","title":"Virtual devices (dummy means very low fidelity) (Old BHyve)"},{"location":"posts/2021-10-27-introduction-to-bhyve/#virtual-device-initialization","text":"while (c = getopt()) switch (c) case 's': pci_parse_slot(optarg, 0); // not legacy break; case 'S': pci_parse_slot(optarg, 1); // legacy break; // ------------------------------ // pci_parse_slot // ------------------------------ // snum is from 0 to 31 // 0,hostbridge // 1,virtio-net,tap0 // pci_slotinfo[snum].si_name = emul; // hostbridge, virtio-net // pci_slotinfo[snum].si_param = config; // null, tap0 // pci_slotinfo[snum].si_legacy = legacy; // 0, 1 init_inout install handler for each port: atpic, console, gdbport, elcr, pci_emu, pit 8254, post, rtc, and uart. init_pci // it depends on opts pde = pci_emul_finddev(si->si_name); if (pde != NULL) { pci_emul_init(ctx, pde, i, si->si_param); // invoke ->init","title":"Virtual device initialization"},{"location":"posts/2021-10-27-introduction-to-bhyve/#extend-btest-like-qtest-to-bhyve","text":"The basic idea of BTest is to implement the same primitives as QTest. We can leverage PCI interfaces to implemented it because we are doing in-memory fuzzing rather than doing traps. [^1]: Homepage of Bhyve \\ [^2]: Wikipedia of Bhyve \\ [^3]: Q&A of Byyve \\ [^4]: xhyve \\ [^5]: Extending bhyve beyond FreeBD guests","title":"Extend BTest (like QTest) to BHyve"},{"location":"posts/2021-11-02-libFuzzer-cov-control/","text":"Coverage Control in libFuzzer This article reveals how to control the coverage collection in libFuzzer. How to use libFuzzer? To use libFuzzer, it is necessary to develop a fuzz target. Please refer to this and this to check how to develop a fuzz target and how to compile it with Clang. How to compiler LLVM project? Download llvm-project and compile like below. Please also refer to this and this . git clone https://github.com/llvm/llvm-project.git --depth=1 mkdir build; cd build cmake -G Ninja -DLLVM_USE_LINKER=gold -DLLVM_ENABLE_PROJECTS=\"clang;compiler-rt\" -DLLVM_TARGETS_TO_BUILD=X86 -DLLVM_OPTIMIZED_TABLEGEN=ON ../llvm/ ninja clang compiler-rt export PATH=$PWD/bin:$PATH Details beneath -fsanitize=fuzzer As we all know, when compiling a program, a compiler will automatically expand its compiler flags. If -v is enable, the compiler will show all flags. Considering a very simple example: clang -o foo -fsanitize=fuzzer foo.c , the full flags related to -fsanitize are in the following. # SIMPLIFIED \"$LLVM/bin/clang-13\" -cc1 \\ -triple x86_64-unknown-linux-gnu \\ -emit-obj \\ -target-cpu x86-64 -v \\ -fsanitize-coverage-type=1 -fsanitize-coverage-type=3 \\ -fsanitize-coverage-indirect-calls \\ -fsanitize-coverage-trace-cmp \\ -fsanitize-coverage-inline-8bit-counters \\ -fsanitize-coverage-pc-table \\ -fsanitize-coverage-stack-depth \\ -fsanitize-coverage-trace-state \\ -fsanitize=fuzzer,fuzzer-no-link \\ -o /tmp/main-d501e8.o -x c main.c # SIMPLIFIED \"/usr/local/bin/ld\" -z relro \\ --hash-style=gnu --eh-frame-hdr \\ -m elf_x86_64 \\ -dynamic-linker /lib64/ld-linux-x86-64.so.2 \\ -o main \\ $LLVM/lib/clang/13.0.0/lib/linux/libclang_rt.fuzzer-x86_64.a \\ $LLVM/lib/clang/13.0.0/lib/linux/libclang_rt.fuzzer_interceptors-x86_64.a \\ $LLVM/lib/clang/13.0.0/lib/linux/libclang_rt.ubsan_standalone-x86_64.a \\ --dynamic-list=$LLVM/lib/clang/13.0.0/lib/linux/libclang_rt.ubsan_standalone-x86_64.a.syms \\ /tmp/main-d501e8.o It's SanitizerArgs() that parses SanCov and sanitizers flags. The path to it is in the following. [#0] clang::driver::SanitizerArgs::SanitizerArgs() [#1] clang::driver::ToolChain::getSanitizerArgs() const() [#2] clang::driver::toolchains::Linux::isPIEDefault() const() [#3] clang::driver::tools::ParsePICArgs() [#4] clang::driver::tools::Clang::ConstructJob() [#5] clang::driver::Driver::BuildJobsForActionNoCache() [#6] clang::driver::Driver::BuildJobsForAction() [#7] clang::driver::Driver::BuildJobsForActionNoCache() [#8] clang::driver::Driver::BuildJobsForAction() [#9] clang::driver::Driver::BuildJobs() [#10] clang::driver::Driver::BuildCompilation() [#11] main() In SanitizerArgs() , parseArgValues will parse six sanitizer related flags. parseArgValues will invoke parseSanitizerValue defined in clang/lib/Basic/Sanitizers.cpp to parse sanitizers defined clang/include/clang/Basic/Sanitizers.def . // clang/include/clang/Basic/Sanitizers.def // libFuzzer SANITIZER(\"fuzzer\", Fuzzer) // libFuzzer-required instrumentation, no linking. SANITIZER(\"fuzzer-no-link\", FuzzerNoLink) In SanitizerArgs() , parseCoverageFeatures will parse two flags: -fsanitize-coverage=<value> and -fno-sanitize-coverage=<value> to control what kind of coverage information for sanitizers. Try clang --help | grep coverage to see more related flags. int parseCoverageFeatures(const Driver &D, const llvm::opt::Arg *A) { assert(A->getOption().matches(options::OPT_fsanitize_coverage) || A->getOption().matches(options::OPT_fno_sanitize_coverage)); int Features = 0; for (int i = 0, n = A->getNumValues(); i != n; ++i) { const char *Value = A->getValue(i); int F = llvm::StringSwitch<int>(Value) .Case(\"func\", CoverageFunc) .Case(\"bb\", CoverageBB) .Case(\"edge\", CoverageEdge) .Case(\"indirect-calls\", CoverageIndirCall) .Case(\"trace-bb\", CoverageTraceBB) .Case(\"trace-cmp\", CoverageTraceCmp) .Case(\"trace-div\", CoverageTraceDiv) .Case(\"trace-gep\", CoverageTraceGep) .Case(\"8bit-counters\", Coverage8bitCounters) .Case(\"trace-pc\", CoverageTracePC) .Case(\"trace-pc-guard\", CoverageTracePCGuard) .Case(\"no-prune\", CoverageNoPrune) .Case(\"inline-8bit-counters\", CoverageInline8bitCounters) .Case(\"inline-bool-flag\", CoverageInlineBoolFlag) .Case(\"pc-table\", CoveragePCTable) .Case(\"stack-depth\", CoverageStackDepth) .Default(0); if (F == 0) D.Diag(clang::diag::err_drv_unsupported_option_argument) << A->getOption().getName() << Value; Features |= F; } return Features; } parseCoverageFeatures clearly show what kind of coverage we can control. In the following are several tips to enable and disable these coverage flags. + func , bb , and edge are mutually exclusive + trace-bb is deprecated, use trace-pc-guard instead + 8bit-counter is deprecated, use trace-pc-guard instead + if use one of func , bb , and edge , trace-pc-guard or trace-pc must be enabled + if one of trace-pc , trace-pc-guard , inline-8bit-counter , and inline-bool-flag is enabled without any func , bb , or edge , then edge is added by default + stack-depth needs func Returning from SanitizerArgs() , ConstructJob will invoke addArgs to append flags to the command line clang -o foo -fsanitize=fuzzer foo.c . [#0] 0x55555a470fa2 \u2192 clang::driver::SanitizerArgs::addArgs() [#1] 0x55555a3c6572 \u2192 clang::driver::tools::Clang::ConstructJob() [#2] 0x55555a345a9a \u2192 clang::driver::Driver::BuildJobsForActionNoCache() [#3] 0x55555a343f99 \u2192 clang::driver::Driver::BuildJobsForAction() [#4] 0x55555a344bad \u2192 clang::driver::Driver::BuildJobsForActionNoCache() [#5] 0x55555a343f99 \u2192 clang::driver::Driver::BuildJobsForAction() [#6] 0x55555a34280e \u2192 clang::driver::Driver::BuildJobs() [#7] 0x55555a3345c4 \u2192 clang::driver::Driver::BuildCompilation() addArgs will add corresponding flags according to the table below. std::pair<int, const char *> CoverageFlags[] = { std::make_pair(CoverageFunc, \"-fsanitize-coverage-type=1\"), std::make_pair(CoverageBB, \"-fsanitize-coverage-type=2\"), std::make_pair(CoverageEdge, \"-fsanitize-coverage-type=3\"), std::make_pair(CoverageIndirCall, \"-fsanitize-coverage-indirect-calls\"), std::make_pair(CoverageTraceBB, \"-fsanitize-coverage-trace-bb\"), std::make_pair(CoverageTraceCmp, \"-fsanitize-coverage-trace-cmp\"), std::make_pair(CoverageTraceDiv, \"-fsanitize-coverage-trace-div\"), std::make_pair(CoverageTraceGep, \"-fsanitize-coverage-trace-gep\"), std::make_pair(Coverage8bitCounters, \"-fsanitize-coverage-8bit-counters\"), std::make_pair(CoverageTracePC, \"-fsanitize-coverage-trace-pc\"), std::make_pair(CoverageTracePCGuard, \"-fsanitize-coverage-trace-pc-guard\"), std::make_pair(CoverageInline8bitCounters, \"-fsanitize-coverage-inline-8bit-counters\"), std::make_pair(CoverageInlineBoolFlag, \"-fsanitize-coverage-inline-bool-flag\"), std::make_pair(CoveragePCTable, \"-fsanitize-coverage-pc-table\"), std::make_pair(CoverageNoPrune, \"-fsanitize-coverage-no-prune\"), std::make_pair(CoverageStackDepth, \"-fsanitize-coverage-stack-depth\"), std::make_pair(CoverageTraceState, \"-fsanitize-coverage-trace-state\")}; Returning from Clang::contructJob , addSanitizerRuntimes will expand linker flags. [#0] 0x55555a3dcbe2 \u2192 clang::driver::tools::addSanitizerRuntimes() [#1] 0x55555a40cac0 \u2192 clang::driver::tools::gnutools::Linker::ConstructJob() [#2] 0x55555a345a9a \u2192 clang::driver::Driver::BuildJobsForActionNoCache() [#3] 0x55555a343f99 \u2192 clang::driver::Driver::BuildJobsForAction() [#4] 0x55555a34280e \u2192 clang::driver::Driver::BuildJobs() [#5] 0x55555a3345c4 \u2192 clang::driver::Driver::BuildCompilation() [#6] 0x555557ddf8f7 \u2192 main() In addSanitizerRuntimes , collectSanitizerRuntimes will collect libraries for sanitizers. + Use -shared-libsan (by default) or -static-libsan to collect dynamic or static libraries + use -fsanitize-link-runtime\" (by default) or -fno-sanitize-link-runtime to switch on or off linking To use ASAN, assign -fsanitize=address . If only -fsanitize=fuzzer , then UBSAN will be enabled. bool SanitizerArgs::needsUbsanRt() const { // All of these include ubsan. if (needsAsanRt() || needsMsanRt() || needsHwasanRt() || needsTsanRt() || needsDfsanRt() || needsLsanRt() || needsCfiDiagRt() || (needsScudoRt() && !requiresMinimalRuntime())) return false; return (Sanitizers.Mask & NeedsUbsanRt & ~TrapSanitizers.Mask) || CoverageFeatures; } Shortly, if no other sanitizers is enabled, and if any coverage is enabled, UBSAN will be enabled. After collectSanitizerRuntimes , addSanitizerRuntimes will update runtimes regarding to -fsanitizer=fuzzer . bool SanitizerArgs::needsFuzzerInterceptors() const { return needsFuzzer() && !needsAsanRt() && !needsTsanRt() && !needsMsanRt(); } bool tools::addSanitizerRuntimes(...) { ... addSanitizerRuntime(TC, Args, CmdArgs, \"fuzzer\", false, true); if (SanArgs.needsFuzzerInterceptors()) addSanitizerRuntime(TC, Args, CmdArgs, \"fuzzer_interceptors\", false, true); } BTW, fuzz_interceptors will be appended if no ASAN, TSAN, MSAN runtime is enabled. Finally, to narrow down the coverage collection, we can construct a command in the following. clang -o foo -fsanitize=fuzzer \\ -fno-sanitize-coverage=indirect-calls,trace-cmp,stack-depth,pc-table \\ foo.c In this way, only edge and inline-8bit-counters are enabled. Flow of instrumentations The module pass SanitizerCoverage (llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp) will instrument coverage flag to each module. In the first state, SanitizerCoverage will construct the IR of stubs to be instrumented. A classic pattern is in the following. const char SanCovTracePCIndirName[] = \"__sanitizer_cov_trace_pc_indir\"; SanCovTracePCIndir = M.getOrInsertFunction(SanCovTracePCIndirName, VoidTy, IntptrTy); In the second state, SanitizerCoverage will traverse all IR code and do instrumentation at the proper position. IRB.CreateCall(SanCovTracePCIndir, IRB.CreatePointerCast(Callee, IntptrTy)); The overall flow of SanitizerCoverage is in the following. instrumentModule - stage 1 - for (auto &F : M) { instrumentFunction(F); } instrumentFunction - split edges if edge coverage[^1] - for (auto &BB : F) { BlocksToInstrument.push_back(&BB); for (auto &Inst: BB) { /* simplified */ if (IndirectCalls && xxx) IndirCalls.push_back(&Inst) if (TraceCmp && xxx) CmpTraceTargets.push_back(&Inst) if (TraceCmp && xxx) SwitchTraceTargets.push_back(&Inst) if (TraceDiv && xxx) DivTraceTargets.push_back(BO) if (TraceGep && xxx) GepTraceTargets.push_back(BO) if (TraceStackDepth && xxx) IsLeafFunc = false; } } - stage 2 InjectCoverage(F, BlocksToInstrument, IsLeafFunc); InjectCoverageForIndirectCalls(F, IndirCalls); InjectTraceForCmp(F, CmpTraceTargets); InjectTraceForSwitch(F, SwitchTraceTargets); InjectTraceForDiv(F, DivTraceTargets); InjectTraceForGep(F, GepTraceTargets); The key function in stage 2 is InjectCoverage . InjectCoverage first create FunctionGuardArray, Function8bitCounterArray, FunctionBoolArray, or FunctionPCsArray in CreateFunctionLocalArrays , then invoke InjectCoverageAtBlock to handle each basic blocks. InjectCoverageAtBlock will instrument SanCovTracePC , SanCovTracePCGuard , Inline8BitCounters , or InlineBoolFlag , or update the lowest stack frame, for each basic block. Details of stubs Please also refer to this . __sanitizer_cov_indir_call This will be in front of an indirect call. It requires at least one of trace-pc , trace-pc-guard , inline-8bit-counters , and inline-bool-flag . It accepts one parameter, the callee address. The address of the caller is passed implicitly via caller PC. Importantly, if the callee is inline assembly, the indirect call will not be instrumented. Its implementation in libFuzzer is in the following. In the end, new information will be updated into the value profile. #define GET_CALLER_PC() __builtin_return_address(0) void TracePC::HandleCallerCallee(uintptr_t Caller, uintptr_t Callee) { const uintptr_t kBits = 12; const uintptr_t kMask = (1 << kBits) - 1; uintptr_t Idx = (Caller & kMask) | ((Callee & kMask) << kBits); ValueProfileMap.AddValueModPrime(Idx); } void __sanitizer_cov_trace_pc_indir(uintptr_t Callee) { uintptr_t PC = reinterpret_cast<uintptr_t>(GET_CALLER_PC()); fuzzer::TPC.HandleCallerCallee(PC, Callee); } __sanitizer_cov_trace_[const_]cmp[1|2|4|8] These will be in front of a cmp instruction with const operand or not. They accept both operands to be compared. The address of the caller is passed implicitly via caller PC. One of its implementation in libFuzzer is in the following. In the end, new information will be updated into the value profile. #define GET_CALLER_PC() __builtin_return_address(0) template <class T> void TracePC::HandleCmp(uintptr_t PC, T Arg1, T Arg2) { uint64_t ArgXor = Arg1 ^ Arg2; if (sizeof(T) == 4) TORC4.Insert(ArgXor, Arg1, Arg2); else if (sizeof(T) == 8) TORC8.Insert(ArgXor, Arg1, Arg2); uint64_t HammingDistance = Popcountll(ArgXor); // [0,64] uint64_t AbsoluteDistance = (Arg1 == Arg2 ? 0 : Clzll(Arg1 - Arg2) + 1); ValueProfileMap.AddValue(PC * 128 + HammingDistance); ValueProfileMap.AddValue(PC * 128 + 64 + AbsoluteDistance); } void __sanitizer_cov_trace_cmp1(uint8_t Arg1, uint8_t Arg2) { uintptr_t PC = reinterpret_cast<uintptr_t>(GET_CALLER_PC()); fuzzer::TPC.HandleCmp(PC, Arg1, Arg2); } Similarly stubs are __sanitizer_cov_trace_switch , __sanitizer_cov_trace_div[4|8] , and __sanitizer_cov_trace_gep . They all invoke HandleCmp at the end to update new information into the value profile. __sanitizer_cov_trace_pc This will be at the entry of each basic block. The address of the caller is passed implicitly via caller PC. This is deprecated. __sanitizer_cov_trace_pc_guard[_init] __sanitizer_cov_trace_pc_guard will be at the entry of each basic block after __sanitier_cov_trace_pc . The address of the caller is passed implicitly via caller PC. They are deprecated. Each function would have a function guard array int32_t FunctionGuardArray[] whose size is the number of the basic blocks. This array is associated with sancov_guards section. __sanitizer_cov_trace_pc_guard accepts FunctionGuardArray[IdxofBB] as the guard. If any function guard array, SanCov will create a section named sancov.module_ctor_trace_pc_guard to invoke __sanitizer_cov_trace_pc_guard_init to initialize sancov_guards for each module. [NOT SURE] In the end, after linking, there will be one sancov_guards and one sancov.module_ctor_trace_pc_guard . __sanitizer_cov_8biPCTableEntryIdxpc_guard`. Each function would have a function 8bit counter array int8_t Function8BitArray[] whose size is the number of the basic blocks. This array is associated with sancov_cntrs section. If a basic block is visited, then the corresponding byte in the array will be increased by 1. If any function 8bit array, SanCov will create a section named sancov.module_ctor_8bit_counters to invoke __sanitizer_cov_8bit_counters_init to initialize sancov_cntrs for each module. [NOT SURE] In the end, after linking, there will be one sancov_cntrs and one sancov.module_ctor_8bit_counters . __sanitizer_cov_8bit_counters_init is defined in the following. It shows the counter information flows to Modules in the libFuzzer. In short, Modules records the start and the stop address of the sancov_cntrs divided by page ( Region ). void TracePC::HandleInline8bitCountersInit(uint8_t *Start, uint8_t *Stop) { if (Start == Stop) return; if (NumModules && Modules[NumModules - 1].Start() == Start) return; assert(NumModules < sizeof(Modules) / sizeof(Modules[0])); auto &M = Modules[NumModules++]; uint8_t *AlignedStart = RoundUpByPage(Start); uint8_t *AlignedStop = RoundDownByPage(Stop); size_t NumFullPages = AlignedStop > AlignedStart ? (AlignedStop - AlignedStart) / PageSize() : 0; bool NeedFirst = Start < AlignedStart || !NumFullPages; bool NeedLast = Stop > AlignedStop && AlignedStop >= AlignedStart; M.NumRegions = NumFullPages + NeedFirst + NeedLast;; assert(M.NumRegions > 0); M.Regions = new Module::Region[M.NumRegions]; assert(M.Regions); size_t R = 0; if (NeedFirst) M.Regions[R++] = {Start, std::min(Stop, AlignedStart), true, false}; for (uint8_t *P = AlignedStart; P < AlignedStop; P += PageSize()) M.Regions[R++] = {P, P + PageSize(), true, true}; if (NeedLast) M.Regions[R++] = {AlignedStop, Stop, true, false}; assert(R == M.NumRegions); assert(M.Size() == (size_t)(Stop - Start)); assert(M.Stop() == Stop); assert(M.Start() == Start); NumInline8bitCounters += M.Size(); } void __sanitizer_cov_8bit_counters_init(uint8_t *Start, uint8_t *Stop) { fuzzer::TPC.HandleInline8bitCountersInit(Start, Stop); } __sanitizer_cov_bool_flag_init The inline bool flag will be at the entry of each basic block after the inline 8bit counters. Each function would have a function 1 bit array int1_t FunctionBoolArray[] whose size is the number of the basic blocks. This array is associated with sancov_bools section. If a basic block is visited, then the corresponding bit in the array will be true. If any function bool array, SanCov will create a section named sancov.module_ctor_bool_flag to invoke __sanitizer_cov_bool_flag_init to initilize sancov_bools for each module. [NOT SURE] In the end, after linking, there will be one sancov_bools and one sancov.module_ctor_bool_flag . __sanitizer_cov_bool_flag_init is not defined in the libFuzzer. __sanitizer_cov_pcs_init For each function, SanCov creates a PC array associated with sancov_pcs to store {PC, PCFlags} pairs. PC is the address of the corresponding basic block, and a PCFlags describes the basic block is the function entry block (1) or not (0). If one of the trace-pc-guard , inline-8bit-counters , and inline-bool-flag , and any function PC array, SanCov will invoke __sanitizer_cov_pcs_init to initilize sancov_pcs for each module in one of the section: sancov.xxx . [NOT SURE] In the end, after linking, there will be one sancov_pcs . __sanitizer_cov_pcs_init is defined in the following. In short, the information flows to ModulePCTable in libFuzzer. void TracePC::HandlePCsInit(const uintptr_t *Start, const uintptr_t *Stop) { const PCTableEntry *B = reinterpret_cast<const PCTableEntry *>(Start); const PCTableEntry *E = reinterpret_cast<const PCTableEntry *>(Stop); if (NumPCTables && ModulePCTable[NumPCTables - 1].Start == B) return; assert(NumPCTables < sizeof(ModulePCTable) / sizeof(ModulePCTable[0])); ModulePCTable[NumPCTables++] = {B, E}; NumPCsInPCTables += E - B; } void __sanitizer_cov_pcs_init(const uintptr_t *pcs_beg, const uintptr_t *pcs_end) { fuzzer::TPC.HandlePCsInit(pcs_beg, pcs_end); } A brief list of (flag, stubs, and information sink in libFuzzer) Flag Stubs Information Sink trace-pc,indirect-calls __sanitizer_cov_trace_pc_indirect ValueProfileMap trace-pc-guard,indirect-calls __sanitizer_cov_trace_pc_indirect ValueProfileMap inline-8bit-counters,indirect-calls __sanitizer_cov_trace_pc_indirect ValueProfileMap inline-bool-flag,indirect-calls __sanitizer_cov_trace_pc_indirect ValueProfileMap trace-cmp __sanitizer_cov_trace_[const_]cmp[1|2|4|8] ValuleProfileMap trace-switch __sanitizer_cov_trace_switch ValuleProfileMap trace-div __sanitizer_cov_trace_div[4|8] ValuleProfileMap trace-gep __sanitizer_cov_trace_gep ValuleProfileMap trace-pc __sanitizer_cov_trace_pc deprecated trace-pc-guard __sanitizer_cov_trace_pc_guard[_init] deprecated inline-8bit-counters __sanitizer_cov_8bit_counters_init Modules inline-bool-flag __sanitizer_cov_bool_flag_init not supported trace-pc-guard,pc-table __sanitizer_cov_pcs_init ModulePCTable inline-8bit-guard,pc-table __sanitizer_cov_pcs_init ModulePCTable inline-bool-flag,pc-table __sanitizer_cov_pcs_init ModulePCTable Details of coverage collection algorithm and implementation Recalling that several stubs are instrumented to the target program. The implementation of these stubs are implemented in libFuzzer by default or can be replaced by developers. Most of them are defined in compiler-rt/lib/fuzzer/FuzzerTracePC.cpp. After testing an input, these stubs will update corresponding information. LibFuzzer will then calculate the coverage with the information. A detailed flow is in the following. ExecuteCallback - TPC.ResetMaps(); - CB(DataCopy, Size); TPC.CollectFeatures(); if (NumNewFeatures || ForceAddToCorpus) { TPC.UpdateObservedPCs(); } ResetMaps template <class Callback> void IterateCounterRegions(Callback CB) { for (size_t m = 0; m < NumModules; m++) for (size_t r = 0; r < Modules[m].NumRegions; r++) CB(Modules[m].Regions[r]); } void TracePC::ClearInlineCounters() { IterateCounterRegions([](const Module::Region &R){ if (R.Enabled) memset(R.Start, 0, R.Stop - R.Start); }); } void ResetMaps() { ValueProfileMap.Reset(); ClearExtraCounters(); ClearInlineCounters(); } TPC.ResetMaps reset 1) ValueProfileMap, a bit map for data flow value, 2) ExtraCounters, 3) InlineCouters, the area for inline-8bit-counters . CollectFeatures size_t NumUpdatesBefore = Corpus.NumFeatureUpdates(); TPC.CollectFeatures([&](size_t Feature) { if (Corpus.AddFeature(Feature, Size, Options.Shrink)) // * }); TPC.CollectFeatures accepts a HandleFeature function pointer. In the HandleFeature, it accepts a Feature that is calculated from all the coverage information (Information Sink), and then adds the feature to the corpus. In TPC.CollectFeatures , it maps the information sinks to features like below. // Modules (Inlint8BitCounters) FirstFeature=0 feature 0 8 w/o counters w/ counters +----+ BB00 +d'02+ +0 +(0*8 + log(2)) +----+ BB01 +d'80+ +1 +(1*8 + log(80)) +----+ FirstFeature += NumOfBits(Modules) // ExtracCounters 0 8 w/o counters w/ counters +----+ CNT0 +d'02+ +0 +(0*8 + log(2)) +----+ CNT1 +d'80+ +1 +(1*8 + log(80)) +----+ FirstFeature += NumOfBits(ExtraCounters) // ValueProfileMap 0 8 +----+ VPM0 +d'02+ +6 (b'00000010) +----+ VPM8 +d'82+ +8/+14 (b'10000010) +----+ FirstFeature += NumOfBits(ValueProfileMap) // StackDepth + StackDepthStepFunction(MaxStackOffset / 8) In general, we map coverage information to a linear feature from zero. For the Modules , libFuzzer checks each byte that records how many times a basic block is visited. If without counters, the feature is the start feature plus the index of the bytes. For BB01, if the index is 1, then the feature is 1. If with counter, it will take d'80 into consideration. The feature is 0 plus log(80). The logarithmic function guarantees the feature will not overflow 8 bits. In the end, the start of the new features will be updated by adding the bit number of modules. ExtraCounters works similarly. For the ValueProfileMap, each non-zero bit is a new feature. For the stack depth, it leverages a hash function StackDepthStepFunction. UpdateObservedPCs If any new features, libFuzzer will update observed PCs. for (size_t i = 0; i < NumModules; i++) { auto &M = Modules[i]; for (size_t r = 0; r < M.NumRegions; r++) { auto &R = M.Regions[r]; if (!R.Enabled) continue; for (uint8_t *P = R.Start; P < R.Stop; P++) if (*P) // if this basic block is visited // then get the PC of the visited the basic block // then invoke Observe Observe(&ModulePCTable[i].Start[M.Idx(P)]); } } First, if a basic block is visited, libFuzzer will get the PC of the visited the basic in the PCTable, and invoke Observe . Vector<uintptr_t> CoveredFuncs; auto ObservePC = [&](const PCTableEntry *TE) { if (ObservedPCs.insert(TE).second && DoPrintNewPCs) { PrintPC(\"\\tNEW_PC: %p %F %L\", \"\\tNEW_PC: %p\", GetNextInstructionPc(TE->PC)); Printf(\"\\n\"); } }; auto Observe = [&](const PCTableEntry *TE) { if (PcIsFuncEntry(TE)) if (++ObservedFuncs[TE->PC] == 1 && NumPrintNewFuncs) CoveredFuncs.push_back(TE->PC); ObservePC(TE); }; If the basic block is the entry, then update ObservedFunc . Otherwise, invoke ObservePC to update ObservedPCs . libFuzzer intercepts LibFuzzer will intercepts memcmp , strncmp , strcmp , strncasecmp , strcasecmp , strstr , strcasestr , and memmem functions if no ASAN, TSAN, MSAN runtime is enabled. It is not easy to disable this behavior. A typical flow for each above function is in the following. RunningUserCallback = true; int Res = CB(DataCopy, Size); RunningUserCallback = false; int memcmp(const void *s1, const void *s2, size_t n) { if (!FuzzerInited) return internal_memcmp(s1, s2, n); int result = REAL(memcmp)(s1, s2, n); __sanitizer_weak_hook_memcmp(GET_CALLER_PC(), s1, s2, n, result); return result; } void __sanitizer_weak_hook_memcmp(void *caller_pc, const void *s1, const void *s2, size_t n, int result) { if (!fuzzer::RunningUserCallback) return; if (result == 0) return; // No reason to mutate. if (n <= 1) return; // Not interesting. fuzzer::TPC.AddValueForMemcmp(caller_pc, s1, s2, n, /*StopAtZero*/false); } Here is a summary of where the collected information will flow. Function Information Sink memcmp AddValueForMemcmp ValueProfileMap strnmp AddValueForMemcmp ValueProfileMap strcmp AddValueForMemcmp ValueProfileMap strncasecmp AddValueForMemcmp ValueProfileMap strcasecmp AddValueForMemcmp strstr MMT(Mutation Only) strcasestr MMT(Mutation Only) memmem MMT(Mutation Only) To disable them, we could 1) use -use_value_profile=0 when fuzzing to avoid update coverage information from ValueProfileMap, 2) comment these __sanitizer_weak_hook_xxx to reduce the overhead. Luckily, -use_value_profile=0 is the default option of libFuzzer. Conclusion For the basic block coverage, SanCov maintains an array that records how many times a basic block is visited, and the libFuzzer will collect that information and calculate features. To disable fancy features, just do as below. clang -o foo -fsanitize=fuzzer \\ -fsanitize-coverage=bb \\ -fno-sanitize-coverage=indirect-calls,trace-cmp,stack-depth,pc-table \\ foo.c","title":"Coverage Control in libFuzzer"},{"location":"posts/2021-11-02-libFuzzer-cov-control/#coverage-control-in-libfuzzer","text":"This article reveals how to control the coverage collection in libFuzzer.","title":"Coverage Control in libFuzzer"},{"location":"posts/2021-11-02-libFuzzer-cov-control/#how-to-use-libfuzzer","text":"To use libFuzzer, it is necessary to develop a fuzz target. Please refer to this and this to check how to develop a fuzz target and how to compile it with Clang.","title":"How to use libFuzzer?"},{"location":"posts/2021-11-02-libFuzzer-cov-control/#how-to-compiler-llvm-project","text":"Download llvm-project and compile like below. Please also refer to this and this . git clone https://github.com/llvm/llvm-project.git --depth=1 mkdir build; cd build cmake -G Ninja -DLLVM_USE_LINKER=gold -DLLVM_ENABLE_PROJECTS=\"clang;compiler-rt\" -DLLVM_TARGETS_TO_BUILD=X86 -DLLVM_OPTIMIZED_TABLEGEN=ON ../llvm/ ninja clang compiler-rt export PATH=$PWD/bin:$PATH","title":"How to compiler LLVM project?"},{"location":"posts/2021-11-02-libFuzzer-cov-control/#details-beneath-fsanitizefuzzer","text":"As we all know, when compiling a program, a compiler will automatically expand its compiler flags. If -v is enable, the compiler will show all flags. Considering a very simple example: clang -o foo -fsanitize=fuzzer foo.c , the full flags related to -fsanitize are in the following. # SIMPLIFIED \"$LLVM/bin/clang-13\" -cc1 \\ -triple x86_64-unknown-linux-gnu \\ -emit-obj \\ -target-cpu x86-64 -v \\ -fsanitize-coverage-type=1 -fsanitize-coverage-type=3 \\ -fsanitize-coverage-indirect-calls \\ -fsanitize-coverage-trace-cmp \\ -fsanitize-coverage-inline-8bit-counters \\ -fsanitize-coverage-pc-table \\ -fsanitize-coverage-stack-depth \\ -fsanitize-coverage-trace-state \\ -fsanitize=fuzzer,fuzzer-no-link \\ -o /tmp/main-d501e8.o -x c main.c # SIMPLIFIED \"/usr/local/bin/ld\" -z relro \\ --hash-style=gnu --eh-frame-hdr \\ -m elf_x86_64 \\ -dynamic-linker /lib64/ld-linux-x86-64.so.2 \\ -o main \\ $LLVM/lib/clang/13.0.0/lib/linux/libclang_rt.fuzzer-x86_64.a \\ $LLVM/lib/clang/13.0.0/lib/linux/libclang_rt.fuzzer_interceptors-x86_64.a \\ $LLVM/lib/clang/13.0.0/lib/linux/libclang_rt.ubsan_standalone-x86_64.a \\ --dynamic-list=$LLVM/lib/clang/13.0.0/lib/linux/libclang_rt.ubsan_standalone-x86_64.a.syms \\ /tmp/main-d501e8.o It's SanitizerArgs() that parses SanCov and sanitizers flags. The path to it is in the following. [#0] clang::driver::SanitizerArgs::SanitizerArgs() [#1] clang::driver::ToolChain::getSanitizerArgs() const() [#2] clang::driver::toolchains::Linux::isPIEDefault() const() [#3] clang::driver::tools::ParsePICArgs() [#4] clang::driver::tools::Clang::ConstructJob() [#5] clang::driver::Driver::BuildJobsForActionNoCache() [#6] clang::driver::Driver::BuildJobsForAction() [#7] clang::driver::Driver::BuildJobsForActionNoCache() [#8] clang::driver::Driver::BuildJobsForAction() [#9] clang::driver::Driver::BuildJobs() [#10] clang::driver::Driver::BuildCompilation() [#11] main() In SanitizerArgs() , parseArgValues will parse six sanitizer related flags. parseArgValues will invoke parseSanitizerValue defined in clang/lib/Basic/Sanitizers.cpp to parse sanitizers defined clang/include/clang/Basic/Sanitizers.def . // clang/include/clang/Basic/Sanitizers.def // libFuzzer SANITIZER(\"fuzzer\", Fuzzer) // libFuzzer-required instrumentation, no linking. SANITIZER(\"fuzzer-no-link\", FuzzerNoLink) In SanitizerArgs() , parseCoverageFeatures will parse two flags: -fsanitize-coverage=<value> and -fno-sanitize-coverage=<value> to control what kind of coverage information for sanitizers. Try clang --help | grep coverage to see more related flags. int parseCoverageFeatures(const Driver &D, const llvm::opt::Arg *A) { assert(A->getOption().matches(options::OPT_fsanitize_coverage) || A->getOption().matches(options::OPT_fno_sanitize_coverage)); int Features = 0; for (int i = 0, n = A->getNumValues(); i != n; ++i) { const char *Value = A->getValue(i); int F = llvm::StringSwitch<int>(Value) .Case(\"func\", CoverageFunc) .Case(\"bb\", CoverageBB) .Case(\"edge\", CoverageEdge) .Case(\"indirect-calls\", CoverageIndirCall) .Case(\"trace-bb\", CoverageTraceBB) .Case(\"trace-cmp\", CoverageTraceCmp) .Case(\"trace-div\", CoverageTraceDiv) .Case(\"trace-gep\", CoverageTraceGep) .Case(\"8bit-counters\", Coverage8bitCounters) .Case(\"trace-pc\", CoverageTracePC) .Case(\"trace-pc-guard\", CoverageTracePCGuard) .Case(\"no-prune\", CoverageNoPrune) .Case(\"inline-8bit-counters\", CoverageInline8bitCounters) .Case(\"inline-bool-flag\", CoverageInlineBoolFlag) .Case(\"pc-table\", CoveragePCTable) .Case(\"stack-depth\", CoverageStackDepth) .Default(0); if (F == 0) D.Diag(clang::diag::err_drv_unsupported_option_argument) << A->getOption().getName() << Value; Features |= F; } return Features; } parseCoverageFeatures clearly show what kind of coverage we can control. In the following are several tips to enable and disable these coverage flags. + func , bb , and edge are mutually exclusive + trace-bb is deprecated, use trace-pc-guard instead + 8bit-counter is deprecated, use trace-pc-guard instead + if use one of func , bb , and edge , trace-pc-guard or trace-pc must be enabled + if one of trace-pc , trace-pc-guard , inline-8bit-counter , and inline-bool-flag is enabled without any func , bb , or edge , then edge is added by default + stack-depth needs func Returning from SanitizerArgs() , ConstructJob will invoke addArgs to append flags to the command line clang -o foo -fsanitize=fuzzer foo.c . [#0] 0x55555a470fa2 \u2192 clang::driver::SanitizerArgs::addArgs() [#1] 0x55555a3c6572 \u2192 clang::driver::tools::Clang::ConstructJob() [#2] 0x55555a345a9a \u2192 clang::driver::Driver::BuildJobsForActionNoCache() [#3] 0x55555a343f99 \u2192 clang::driver::Driver::BuildJobsForAction() [#4] 0x55555a344bad \u2192 clang::driver::Driver::BuildJobsForActionNoCache() [#5] 0x55555a343f99 \u2192 clang::driver::Driver::BuildJobsForAction() [#6] 0x55555a34280e \u2192 clang::driver::Driver::BuildJobs() [#7] 0x55555a3345c4 \u2192 clang::driver::Driver::BuildCompilation() addArgs will add corresponding flags according to the table below. std::pair<int, const char *> CoverageFlags[] = { std::make_pair(CoverageFunc, \"-fsanitize-coverage-type=1\"), std::make_pair(CoverageBB, \"-fsanitize-coverage-type=2\"), std::make_pair(CoverageEdge, \"-fsanitize-coverage-type=3\"), std::make_pair(CoverageIndirCall, \"-fsanitize-coverage-indirect-calls\"), std::make_pair(CoverageTraceBB, \"-fsanitize-coverage-trace-bb\"), std::make_pair(CoverageTraceCmp, \"-fsanitize-coverage-trace-cmp\"), std::make_pair(CoverageTraceDiv, \"-fsanitize-coverage-trace-div\"), std::make_pair(CoverageTraceGep, \"-fsanitize-coverage-trace-gep\"), std::make_pair(Coverage8bitCounters, \"-fsanitize-coverage-8bit-counters\"), std::make_pair(CoverageTracePC, \"-fsanitize-coverage-trace-pc\"), std::make_pair(CoverageTracePCGuard, \"-fsanitize-coverage-trace-pc-guard\"), std::make_pair(CoverageInline8bitCounters, \"-fsanitize-coverage-inline-8bit-counters\"), std::make_pair(CoverageInlineBoolFlag, \"-fsanitize-coverage-inline-bool-flag\"), std::make_pair(CoveragePCTable, \"-fsanitize-coverage-pc-table\"), std::make_pair(CoverageNoPrune, \"-fsanitize-coverage-no-prune\"), std::make_pair(CoverageStackDepth, \"-fsanitize-coverage-stack-depth\"), std::make_pair(CoverageTraceState, \"-fsanitize-coverage-trace-state\")}; Returning from Clang::contructJob , addSanitizerRuntimes will expand linker flags. [#0] 0x55555a3dcbe2 \u2192 clang::driver::tools::addSanitizerRuntimes() [#1] 0x55555a40cac0 \u2192 clang::driver::tools::gnutools::Linker::ConstructJob() [#2] 0x55555a345a9a \u2192 clang::driver::Driver::BuildJobsForActionNoCache() [#3] 0x55555a343f99 \u2192 clang::driver::Driver::BuildJobsForAction() [#4] 0x55555a34280e \u2192 clang::driver::Driver::BuildJobs() [#5] 0x55555a3345c4 \u2192 clang::driver::Driver::BuildCompilation() [#6] 0x555557ddf8f7 \u2192 main() In addSanitizerRuntimes , collectSanitizerRuntimes will collect libraries for sanitizers. + Use -shared-libsan (by default) or -static-libsan to collect dynamic or static libraries + use -fsanitize-link-runtime\" (by default) or -fno-sanitize-link-runtime to switch on or off linking To use ASAN, assign -fsanitize=address . If only -fsanitize=fuzzer , then UBSAN will be enabled. bool SanitizerArgs::needsUbsanRt() const { // All of these include ubsan. if (needsAsanRt() || needsMsanRt() || needsHwasanRt() || needsTsanRt() || needsDfsanRt() || needsLsanRt() || needsCfiDiagRt() || (needsScudoRt() && !requiresMinimalRuntime())) return false; return (Sanitizers.Mask & NeedsUbsanRt & ~TrapSanitizers.Mask) || CoverageFeatures; } Shortly, if no other sanitizers is enabled, and if any coverage is enabled, UBSAN will be enabled. After collectSanitizerRuntimes , addSanitizerRuntimes will update runtimes regarding to -fsanitizer=fuzzer . bool SanitizerArgs::needsFuzzerInterceptors() const { return needsFuzzer() && !needsAsanRt() && !needsTsanRt() && !needsMsanRt(); } bool tools::addSanitizerRuntimes(...) { ... addSanitizerRuntime(TC, Args, CmdArgs, \"fuzzer\", false, true); if (SanArgs.needsFuzzerInterceptors()) addSanitizerRuntime(TC, Args, CmdArgs, \"fuzzer_interceptors\", false, true); } BTW, fuzz_interceptors will be appended if no ASAN, TSAN, MSAN runtime is enabled. Finally, to narrow down the coverage collection, we can construct a command in the following. clang -o foo -fsanitize=fuzzer \\ -fno-sanitize-coverage=indirect-calls,trace-cmp,stack-depth,pc-table \\ foo.c In this way, only edge and inline-8bit-counters are enabled.","title":"Details beneath -fsanitize=fuzzer"},{"location":"posts/2021-11-02-libFuzzer-cov-control/#flow-of-instrumentations","text":"The module pass SanitizerCoverage (llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp) will instrument coverage flag to each module. In the first state, SanitizerCoverage will construct the IR of stubs to be instrumented. A classic pattern is in the following. const char SanCovTracePCIndirName[] = \"__sanitizer_cov_trace_pc_indir\"; SanCovTracePCIndir = M.getOrInsertFunction(SanCovTracePCIndirName, VoidTy, IntptrTy); In the second state, SanitizerCoverage will traverse all IR code and do instrumentation at the proper position. IRB.CreateCall(SanCovTracePCIndir, IRB.CreatePointerCast(Callee, IntptrTy)); The overall flow of SanitizerCoverage is in the following. instrumentModule - stage 1 - for (auto &F : M) { instrumentFunction(F); } instrumentFunction - split edges if edge coverage[^1] - for (auto &BB : F) { BlocksToInstrument.push_back(&BB); for (auto &Inst: BB) { /* simplified */ if (IndirectCalls && xxx) IndirCalls.push_back(&Inst) if (TraceCmp && xxx) CmpTraceTargets.push_back(&Inst) if (TraceCmp && xxx) SwitchTraceTargets.push_back(&Inst) if (TraceDiv && xxx) DivTraceTargets.push_back(BO) if (TraceGep && xxx) GepTraceTargets.push_back(BO) if (TraceStackDepth && xxx) IsLeafFunc = false; } } - stage 2 InjectCoverage(F, BlocksToInstrument, IsLeafFunc); InjectCoverageForIndirectCalls(F, IndirCalls); InjectTraceForCmp(F, CmpTraceTargets); InjectTraceForSwitch(F, SwitchTraceTargets); InjectTraceForDiv(F, DivTraceTargets); InjectTraceForGep(F, GepTraceTargets); The key function in stage 2 is InjectCoverage . InjectCoverage first create FunctionGuardArray, Function8bitCounterArray, FunctionBoolArray, or FunctionPCsArray in CreateFunctionLocalArrays , then invoke InjectCoverageAtBlock to handle each basic blocks. InjectCoverageAtBlock will instrument SanCovTracePC , SanCovTracePCGuard , Inline8BitCounters , or InlineBoolFlag , or update the lowest stack frame, for each basic block.","title":"Flow of instrumentations"},{"location":"posts/2021-11-02-libFuzzer-cov-control/#details-of-stubs","text":"Please also refer to this .","title":"Details of stubs"},{"location":"posts/2021-11-02-libFuzzer-cov-control/#__sanitizer_cov_indir_call","text":"This will be in front of an indirect call. It requires at least one of trace-pc , trace-pc-guard , inline-8bit-counters , and inline-bool-flag . It accepts one parameter, the callee address. The address of the caller is passed implicitly via caller PC. Importantly, if the callee is inline assembly, the indirect call will not be instrumented. Its implementation in libFuzzer is in the following. In the end, new information will be updated into the value profile. #define GET_CALLER_PC() __builtin_return_address(0) void TracePC::HandleCallerCallee(uintptr_t Caller, uintptr_t Callee) { const uintptr_t kBits = 12; const uintptr_t kMask = (1 << kBits) - 1; uintptr_t Idx = (Caller & kMask) | ((Callee & kMask) << kBits); ValueProfileMap.AddValueModPrime(Idx); } void __sanitizer_cov_trace_pc_indir(uintptr_t Callee) { uintptr_t PC = reinterpret_cast<uintptr_t>(GET_CALLER_PC()); fuzzer::TPC.HandleCallerCallee(PC, Callee); }","title":"__sanitizer_cov_indir_call"},{"location":"posts/2021-11-02-libFuzzer-cov-control/#__sanitizer_cov_trace_const_cmp1248","text":"These will be in front of a cmp instruction with const operand or not. They accept both operands to be compared. The address of the caller is passed implicitly via caller PC. One of its implementation in libFuzzer is in the following. In the end, new information will be updated into the value profile. #define GET_CALLER_PC() __builtin_return_address(0) template <class T> void TracePC::HandleCmp(uintptr_t PC, T Arg1, T Arg2) { uint64_t ArgXor = Arg1 ^ Arg2; if (sizeof(T) == 4) TORC4.Insert(ArgXor, Arg1, Arg2); else if (sizeof(T) == 8) TORC8.Insert(ArgXor, Arg1, Arg2); uint64_t HammingDistance = Popcountll(ArgXor); // [0,64] uint64_t AbsoluteDistance = (Arg1 == Arg2 ? 0 : Clzll(Arg1 - Arg2) + 1); ValueProfileMap.AddValue(PC * 128 + HammingDistance); ValueProfileMap.AddValue(PC * 128 + 64 + AbsoluteDistance); } void __sanitizer_cov_trace_cmp1(uint8_t Arg1, uint8_t Arg2) { uintptr_t PC = reinterpret_cast<uintptr_t>(GET_CALLER_PC()); fuzzer::TPC.HandleCmp(PC, Arg1, Arg2); } Similarly stubs are __sanitizer_cov_trace_switch , __sanitizer_cov_trace_div[4|8] , and __sanitizer_cov_trace_gep . They all invoke HandleCmp at the end to update new information into the value profile.","title":"__sanitizer_cov_trace_[const_]cmp[1|2|4|8]"},{"location":"posts/2021-11-02-libFuzzer-cov-control/#__sanitizer_cov_trace_pc","text":"This will be at the entry of each basic block. The address of the caller is passed implicitly via caller PC. This is deprecated.","title":"__sanitizer_cov_trace_pc"},{"location":"posts/2021-11-02-libFuzzer-cov-control/#__sanitizer_cov_trace_pc_guard_init","text":"__sanitizer_cov_trace_pc_guard will be at the entry of each basic block after __sanitier_cov_trace_pc . The address of the caller is passed implicitly via caller PC. They are deprecated. Each function would have a function guard array int32_t FunctionGuardArray[] whose size is the number of the basic blocks. This array is associated with sancov_guards section. __sanitizer_cov_trace_pc_guard accepts FunctionGuardArray[IdxofBB] as the guard. If any function guard array, SanCov will create a section named sancov.module_ctor_trace_pc_guard to invoke __sanitizer_cov_trace_pc_guard_init to initialize sancov_guards for each module. [NOT SURE] In the end, after linking, there will be one sancov_guards and one sancov.module_ctor_trace_pc_guard .","title":"__sanitizer_cov_trace_pc_guard[_init]"},{"location":"posts/2021-11-02-libFuzzer-cov-control/#__sanitizer_cov_8bipctableentryidxpc_guard","text":"Each function would have a function 8bit counter array int8_t Function8BitArray[] whose size is the number of the basic blocks. This array is associated with sancov_cntrs section. If a basic block is visited, then the corresponding byte in the array will be increased by 1. If any function 8bit array, SanCov will create a section named sancov.module_ctor_8bit_counters to invoke __sanitizer_cov_8bit_counters_init to initialize sancov_cntrs for each module. [NOT SURE] In the end, after linking, there will be one sancov_cntrs and one sancov.module_ctor_8bit_counters . __sanitizer_cov_8bit_counters_init is defined in the following. It shows the counter information flows to Modules in the libFuzzer. In short, Modules records the start and the stop address of the sancov_cntrs divided by page ( Region ). void TracePC::HandleInline8bitCountersInit(uint8_t *Start, uint8_t *Stop) { if (Start == Stop) return; if (NumModules && Modules[NumModules - 1].Start() == Start) return; assert(NumModules < sizeof(Modules) / sizeof(Modules[0])); auto &M = Modules[NumModules++]; uint8_t *AlignedStart = RoundUpByPage(Start); uint8_t *AlignedStop = RoundDownByPage(Stop); size_t NumFullPages = AlignedStop > AlignedStart ? (AlignedStop - AlignedStart) / PageSize() : 0; bool NeedFirst = Start < AlignedStart || !NumFullPages; bool NeedLast = Stop > AlignedStop && AlignedStop >= AlignedStart; M.NumRegions = NumFullPages + NeedFirst + NeedLast;; assert(M.NumRegions > 0); M.Regions = new Module::Region[M.NumRegions]; assert(M.Regions); size_t R = 0; if (NeedFirst) M.Regions[R++] = {Start, std::min(Stop, AlignedStart), true, false}; for (uint8_t *P = AlignedStart; P < AlignedStop; P += PageSize()) M.Regions[R++] = {P, P + PageSize(), true, true}; if (NeedLast) M.Regions[R++] = {AlignedStop, Stop, true, false}; assert(R == M.NumRegions); assert(M.Size() == (size_t)(Stop - Start)); assert(M.Stop() == Stop); assert(M.Start() == Start); NumInline8bitCounters += M.Size(); } void __sanitizer_cov_8bit_counters_init(uint8_t *Start, uint8_t *Stop) { fuzzer::TPC.HandleInline8bitCountersInit(Start, Stop); }","title":"__sanitizer_cov_8biPCTableEntryIdxpc_guard`."},{"location":"posts/2021-11-02-libFuzzer-cov-control/#__sanitizer_cov_bool_flag_init","text":"The inline bool flag will be at the entry of each basic block after the inline 8bit counters. Each function would have a function 1 bit array int1_t FunctionBoolArray[] whose size is the number of the basic blocks. This array is associated with sancov_bools section. If a basic block is visited, then the corresponding bit in the array will be true. If any function bool array, SanCov will create a section named sancov.module_ctor_bool_flag to invoke __sanitizer_cov_bool_flag_init to initilize sancov_bools for each module. [NOT SURE] In the end, after linking, there will be one sancov_bools and one sancov.module_ctor_bool_flag . __sanitizer_cov_bool_flag_init is not defined in the libFuzzer.","title":"__sanitizer_cov_bool_flag_init"},{"location":"posts/2021-11-02-libFuzzer-cov-control/#__sanitizer_cov_pcs_init","text":"For each function, SanCov creates a PC array associated with sancov_pcs to store {PC, PCFlags} pairs. PC is the address of the corresponding basic block, and a PCFlags describes the basic block is the function entry block (1) or not (0). If one of the trace-pc-guard , inline-8bit-counters , and inline-bool-flag , and any function PC array, SanCov will invoke __sanitizer_cov_pcs_init to initilize sancov_pcs for each module in one of the section: sancov.xxx . [NOT SURE] In the end, after linking, there will be one sancov_pcs . __sanitizer_cov_pcs_init is defined in the following. In short, the information flows to ModulePCTable in libFuzzer. void TracePC::HandlePCsInit(const uintptr_t *Start, const uintptr_t *Stop) { const PCTableEntry *B = reinterpret_cast<const PCTableEntry *>(Start); const PCTableEntry *E = reinterpret_cast<const PCTableEntry *>(Stop); if (NumPCTables && ModulePCTable[NumPCTables - 1].Start == B) return; assert(NumPCTables < sizeof(ModulePCTable) / sizeof(ModulePCTable[0])); ModulePCTable[NumPCTables++] = {B, E}; NumPCsInPCTables += E - B; } void __sanitizer_cov_pcs_init(const uintptr_t *pcs_beg, const uintptr_t *pcs_end) { fuzzer::TPC.HandlePCsInit(pcs_beg, pcs_end); }","title":"__sanitizer_cov_pcs_init"},{"location":"posts/2021-11-02-libFuzzer-cov-control/#a-brief-list-of-flag-stubs-and-information-sink-in-libfuzzer","text":"Flag Stubs Information Sink trace-pc,indirect-calls __sanitizer_cov_trace_pc_indirect ValueProfileMap trace-pc-guard,indirect-calls __sanitizer_cov_trace_pc_indirect ValueProfileMap inline-8bit-counters,indirect-calls __sanitizer_cov_trace_pc_indirect ValueProfileMap inline-bool-flag,indirect-calls __sanitizer_cov_trace_pc_indirect ValueProfileMap trace-cmp __sanitizer_cov_trace_[const_]cmp[1|2|4|8] ValuleProfileMap trace-switch __sanitizer_cov_trace_switch ValuleProfileMap trace-div __sanitizer_cov_trace_div[4|8] ValuleProfileMap trace-gep __sanitizer_cov_trace_gep ValuleProfileMap trace-pc __sanitizer_cov_trace_pc deprecated trace-pc-guard __sanitizer_cov_trace_pc_guard[_init] deprecated inline-8bit-counters __sanitizer_cov_8bit_counters_init Modules inline-bool-flag __sanitizer_cov_bool_flag_init not supported trace-pc-guard,pc-table __sanitizer_cov_pcs_init ModulePCTable inline-8bit-guard,pc-table __sanitizer_cov_pcs_init ModulePCTable inline-bool-flag,pc-table __sanitizer_cov_pcs_init ModulePCTable","title":"A brief list of (flag, stubs, and information sink in libFuzzer)"},{"location":"posts/2021-11-02-libFuzzer-cov-control/#details-of-coverage-collection-algorithm-and-implementation","text":"Recalling that several stubs are instrumented to the target program. The implementation of these stubs are implemented in libFuzzer by default or can be replaced by developers. Most of them are defined in compiler-rt/lib/fuzzer/FuzzerTracePC.cpp. After testing an input, these stubs will update corresponding information. LibFuzzer will then calculate the coverage with the information. A detailed flow is in the following. ExecuteCallback - TPC.ResetMaps(); - CB(DataCopy, Size); TPC.CollectFeatures(); if (NumNewFeatures || ForceAddToCorpus) { TPC.UpdateObservedPCs(); }","title":"Details of coverage collection algorithm and implementation"},{"location":"posts/2021-11-02-libFuzzer-cov-control/#resetmaps","text":"template <class Callback> void IterateCounterRegions(Callback CB) { for (size_t m = 0; m < NumModules; m++) for (size_t r = 0; r < Modules[m].NumRegions; r++) CB(Modules[m].Regions[r]); } void TracePC::ClearInlineCounters() { IterateCounterRegions([](const Module::Region &R){ if (R.Enabled) memset(R.Start, 0, R.Stop - R.Start); }); } void ResetMaps() { ValueProfileMap.Reset(); ClearExtraCounters(); ClearInlineCounters(); } TPC.ResetMaps reset 1) ValueProfileMap, a bit map for data flow value, 2) ExtraCounters, 3) InlineCouters, the area for inline-8bit-counters .","title":"ResetMaps"},{"location":"posts/2021-11-02-libFuzzer-cov-control/#collectfeatures","text":"size_t NumUpdatesBefore = Corpus.NumFeatureUpdates(); TPC.CollectFeatures([&](size_t Feature) { if (Corpus.AddFeature(Feature, Size, Options.Shrink)) // * }); TPC.CollectFeatures accepts a HandleFeature function pointer. In the HandleFeature, it accepts a Feature that is calculated from all the coverage information (Information Sink), and then adds the feature to the corpus. In TPC.CollectFeatures , it maps the information sinks to features like below. // Modules (Inlint8BitCounters) FirstFeature=0 feature 0 8 w/o counters w/ counters +----+ BB00 +d'02+ +0 +(0*8 + log(2)) +----+ BB01 +d'80+ +1 +(1*8 + log(80)) +----+ FirstFeature += NumOfBits(Modules) // ExtracCounters 0 8 w/o counters w/ counters +----+ CNT0 +d'02+ +0 +(0*8 + log(2)) +----+ CNT1 +d'80+ +1 +(1*8 + log(80)) +----+ FirstFeature += NumOfBits(ExtraCounters) // ValueProfileMap 0 8 +----+ VPM0 +d'02+ +6 (b'00000010) +----+ VPM8 +d'82+ +8/+14 (b'10000010) +----+ FirstFeature += NumOfBits(ValueProfileMap) // StackDepth + StackDepthStepFunction(MaxStackOffset / 8) In general, we map coverage information to a linear feature from zero. For the Modules , libFuzzer checks each byte that records how many times a basic block is visited. If without counters, the feature is the start feature plus the index of the bytes. For BB01, if the index is 1, then the feature is 1. If with counter, it will take d'80 into consideration. The feature is 0 plus log(80). The logarithmic function guarantees the feature will not overflow 8 bits. In the end, the start of the new features will be updated by adding the bit number of modules. ExtraCounters works similarly. For the ValueProfileMap, each non-zero bit is a new feature. For the stack depth, it leverages a hash function StackDepthStepFunction.","title":"CollectFeatures"},{"location":"posts/2021-11-02-libFuzzer-cov-control/#updateobservedpcs","text":"If any new features, libFuzzer will update observed PCs. for (size_t i = 0; i < NumModules; i++) { auto &M = Modules[i]; for (size_t r = 0; r < M.NumRegions; r++) { auto &R = M.Regions[r]; if (!R.Enabled) continue; for (uint8_t *P = R.Start; P < R.Stop; P++) if (*P) // if this basic block is visited // then get the PC of the visited the basic block // then invoke Observe Observe(&ModulePCTable[i].Start[M.Idx(P)]); } } First, if a basic block is visited, libFuzzer will get the PC of the visited the basic in the PCTable, and invoke Observe . Vector<uintptr_t> CoveredFuncs; auto ObservePC = [&](const PCTableEntry *TE) { if (ObservedPCs.insert(TE).second && DoPrintNewPCs) { PrintPC(\"\\tNEW_PC: %p %F %L\", \"\\tNEW_PC: %p\", GetNextInstructionPc(TE->PC)); Printf(\"\\n\"); } }; auto Observe = [&](const PCTableEntry *TE) { if (PcIsFuncEntry(TE)) if (++ObservedFuncs[TE->PC] == 1 && NumPrintNewFuncs) CoveredFuncs.push_back(TE->PC); ObservePC(TE); }; If the basic block is the entry, then update ObservedFunc . Otherwise, invoke ObservePC to update ObservedPCs .","title":"UpdateObservedPCs"},{"location":"posts/2021-11-02-libFuzzer-cov-control/#libfuzzer-intercepts","text":"LibFuzzer will intercepts memcmp , strncmp , strcmp , strncasecmp , strcasecmp , strstr , strcasestr , and memmem functions if no ASAN, TSAN, MSAN runtime is enabled. It is not easy to disable this behavior. A typical flow for each above function is in the following. RunningUserCallback = true; int Res = CB(DataCopy, Size); RunningUserCallback = false; int memcmp(const void *s1, const void *s2, size_t n) { if (!FuzzerInited) return internal_memcmp(s1, s2, n); int result = REAL(memcmp)(s1, s2, n); __sanitizer_weak_hook_memcmp(GET_CALLER_PC(), s1, s2, n, result); return result; } void __sanitizer_weak_hook_memcmp(void *caller_pc, const void *s1, const void *s2, size_t n, int result) { if (!fuzzer::RunningUserCallback) return; if (result == 0) return; // No reason to mutate. if (n <= 1) return; // Not interesting. fuzzer::TPC.AddValueForMemcmp(caller_pc, s1, s2, n, /*StopAtZero*/false); } Here is a summary of where the collected information will flow. Function Information Sink memcmp AddValueForMemcmp ValueProfileMap strnmp AddValueForMemcmp ValueProfileMap strcmp AddValueForMemcmp ValueProfileMap strncasecmp AddValueForMemcmp ValueProfileMap strcasecmp AddValueForMemcmp strstr MMT(Mutation Only) strcasestr MMT(Mutation Only) memmem MMT(Mutation Only) To disable them, we could 1) use -use_value_profile=0 when fuzzing to avoid update coverage information from ValueProfileMap, 2) comment these __sanitizer_weak_hook_xxx to reduce the overhead. Luckily, -use_value_profile=0 is the default option of libFuzzer.","title":"libFuzzer intercepts"},{"location":"posts/2021-11-02-libFuzzer-cov-control/#conclusion","text":"For the basic block coverage, SanCov maintains an array that records how many times a basic block is visited, and the libFuzzer will collect that information and calculate features. To disable fancy features, just do as below. clang -o foo -fsanitize=fuzzer \\ -fsanitize-coverage=bb \\ -fno-sanitize-coverage=indirect-calls,trace-cmp,stack-depth,pc-table \\ foo.c","title":"Conclusion"},{"location":"posts/2021-11-15-ase-firmguide/","text":"ASE'21 - FirmGuide This is the speech text of FirmGuide for ASE'21. Text (15 mins, ~1500 words) and Slides Hello, everyone. My name is Liu Qiang from Zhejiang University. I'm going to introduce one of our works on firmware rehosting: FirmGuide. This is a joint work with Zhang Cheng, the other co-first author, and other authors from Zhejiang University, Nanyang Technological University, and The Hong Kong Polytechnic University. Now high-end embedded devices like routers and IP cameras use the Linux kernel. We want to dynamically understand and discover the bugs or vulnerabilities in the context of embedded systems. However, it is not easy and scalable due to the hardware requirements. The goal of this paper is then to rehost the embedded Linux kernels with the best effort. The rehosting has three challenges. First, a System on Chip or an SoC has numerous peripherals. Based on the observation that whether a peripheral is necessary to the Linux kernel core functionalities, we classify peripherals into two types. Type-I peripherals, such as memory, interrupt controllers, timers, and UART, are critical to memory management, scheduling, and user-kernel interactions. We have to design high-fidelity models for them. Others are type-II peripherals that are not necessary to be high fidelity. We use dummy device models with proper initialized values to pass some checks to avoid being stuck when the Linux kernel is booting. This classification saves the time to model every type of peripherals, which is a complicated problem that may take years. The minimum best effort, i.e., focusing on Type-I peripherals, is the first step to start the dynamic analysis of the embedded Linux kernels. Next, we are going to discuss two other challenges when modeling the Type-I peripherals. The second challenge is that even one type of peripherals, e.g., interrupt controllers, have different models. Do we need to model each interrupt controller? The answer is no. Based on our observation, the driver of an interrupt controller must obey the protocol defined by the Linux kernel in the interrupt subsystem. To solve this challenge, we extract generic state machines from the Linux kernel subsystems for further high fidelity model construction. The third challenge is that each peripheral has complex interactive semantics. For example, to mask an interrupt source, an interrupt controller will read the mask register, mask one specific bit, and then write the value back to the register. To load the number of a pending interrupt, an interrupt controller will load the corresponding value, parse it, and invoke the relative interrupt service routine. We observe that the driver of an interrupt controller has to implement the callbacks defined in the interrupt subsystem. Each specific driver callback embeds such complex interactive semantics via MMIO read and write sequences. We analyze the drivers of Type-I peripherals and extract MMIO read and write sequences from these callbacks to complement the state machine extracted from the interrupt subsystem. In our paper, we propose a new technique named model-guided kernel execution. The idea is that we can leverage a state machine model to guide the kernel's execution. The peripheral model consists of two parts. The first part is the model template, that is, a state machine. It is manually constructed by experts. Note that the transition condition is blank. The second part is MMIO read and write sequences as transition conditions. This part can be automatically inferred by analyzing the source code of the drivers. How does the model-guided kernel execution work? The peripheral model monitors the execution of the Linux kernel, compares the MMIO read and write sequences encoded in the state machine, and then transit to the corresponding states. Finally, the Linux kernel will successfully boot and spawn an interactive shell. Here is a running example. The left figure has two representative callback functions of an interrupt controller driver in the Linux kernel. The right figure shows how the peripheral model works. In the irq_mask_callback function, it first issues an MMIO read. In the peripheral model, we monitor this MMIO read. Give a concrete irq, we do mask a specific bit in the variable mask, and then issue an MMIO write. The peripheral model can detect this MMIO read and write sequence. The peripheral model can infer the specific interrupt request number by the write value and then mask it. Similarly, the callback function handle_irq_callback reads the current pending interrupt sources. After monitoring it, the peripheral model will check the current state machine and return the number of the pending interrupt. The example shows that the MMIO read and write sequences from the Linux kernel can be recognized to drive the state machine of our emulated peripherals, which is the core idea of how the model-guided kernel execution works. How to construct the peripheral model? In the above row, we first manually analyze the Linux kernel subsystems and construct the model template manually. In the bottom row, we parse the device tree blob to get some parameters, such as the number of interrupts that an interrupt controller can support, then automatically analyze the driver code. The automated inference has three parts. The first part is the basic MMIO read and write sequence extraction via symbolic execution. The second part is to handle CFSV. CFSV are kernel-maintained shared variables. They will cache the value of the MMIO registers. We have to analyze them and consider them as part of the peripheral model. Otherwise, the peripheral model will lose track of the interaction semantics. The third part is to infer the semantic difference between the hardware and the Linux kernel. Specifically, the time unit used by the hardware and the Linux kernel is different. We have to calculate the difference and convert it to hardware-recognized or kernel-recognized value. Then, we have the MMIO read and write sequences with more information for each state transition. Finally, we convert the peripheral model to QEMU virtual device. In general, we semi-automatically build the state machine of each peripheral with a general model template and model parameters. Here is our system design and implementation. FirmGuide consists of two components. The first component, \"offline model generation\", analyzes the Linux kernel source code and generates virtual devices finally. This component uses LLVM pass for preprocessing, KLEE for MMIO read and write sequences analysis, and Python scripts for gluing. The second component, \"online kernel booting\", accepts the binary firmware, lists the peripherals in its device tree blob, and composes the whole virtual machine. This component uses Python for the main logic and leverages the template-render design pattern for code generation. The first question in our evaluation is what peripherals models FirmGuide can generate. As shown in the first table, FirmGuide can support five different families of SoCs, covering six interrupt controllers and five timers. In the parameter inference, the symbolic execution engine can solve the first solution within 1 hour. We also count the number of CFSV and timer semantic-aware values. Our experiences show that these peripheral models can support the basic functionality of a rehosted embedded Linux kernel. In the second table, we list the number of Type-II peripherals and the number of initialized values we should handle to avoid being stuck when the Linux kernel is booting. In general, because the number of initial values is limited, they are easier to handle with the symbolic execution. The second question is what embedded Linux kernel we can rehost. In the figure, we list the number of unpacked firmware, the number of extracted kernels, the number of embedded kernels that go to the user space, and the number of embedded kernels that spawn shells. Given more than six thousand of firmware crossing ten vendors, three architectures, and 22 Linux kernel versions, FirmGuide can successfully rehost more than 96% of them, showing the scalability of FirmGuide. The third question is about the functionality or fidelity of the rehosted embedded Linux kernels via the system call testing tools in the Linux Test Project. We manually develop a QEMU virtual machine with well-constructed Type-I peripherals and compare the result with the one FirmGuide generates. Results in the table show that FirmGuide generated virtual machines has the same fidelity as manually developed QEMU virtual machine regarding the system calls. The fourth question is the applications of FirmGuide. We use FirmGuide to reproduce and develop exploits for six Linux kernel CVEs. We also leverage fuzzing to test the rehosted embedded Linux kernel. Here we are. First, we proposed a novel technique. Second, we design and implement the first semi-automatic framework for embedded Linux kernel rehosting. Last, we apply FirmGuide to analyze and discover the bugs in the embedded Linux kernel. At last, I'd like to discuss the limitation of FirmGuide and future work. First, we need experts to extract the state machine from the Linux kernel subsystems manually. It depends on a well-formed abstraction. It is still challenging to infer the peripheral model automatically for complicated peripherals. Second, FirmGuide cannot support the high fidelity of Type-II peripherals due to our minimum best efforts strategy. It is an important problem to support more Type-II peripherals and enable more analysis of Type-II peripheral drivers in the embedded Linux kernel. Thank you!","title":"ASE'21 - FirmGuide"},{"location":"posts/2021-11-15-ase-firmguide/#ase21-firmguide","text":"This is the speech text of FirmGuide for ASE'21.","title":"ASE'21 - FirmGuide"},{"location":"posts/2021-11-15-ase-firmguide/#text-15-mins-1500-words-and-slides","text":"Hello, everyone. My name is Liu Qiang from Zhejiang University. I'm going to introduce one of our works on firmware rehosting: FirmGuide. This is a joint work with Zhang Cheng, the other co-first author, and other authors from Zhejiang University, Nanyang Technological University, and The Hong Kong Polytechnic University. Now high-end embedded devices like routers and IP cameras use the Linux kernel. We want to dynamically understand and discover the bugs or vulnerabilities in the context of embedded systems. However, it is not easy and scalable due to the hardware requirements. The goal of this paper is then to rehost the embedded Linux kernels with the best effort. The rehosting has three challenges. First, a System on Chip or an SoC has numerous peripherals. Based on the observation that whether a peripheral is necessary to the Linux kernel core functionalities, we classify peripherals into two types. Type-I peripherals, such as memory, interrupt controllers, timers, and UART, are critical to memory management, scheduling, and user-kernel interactions. We have to design high-fidelity models for them. Others are type-II peripherals that are not necessary to be high fidelity. We use dummy device models with proper initialized values to pass some checks to avoid being stuck when the Linux kernel is booting. This classification saves the time to model every type of peripherals, which is a complicated problem that may take years. The minimum best effort, i.e., focusing on Type-I peripherals, is the first step to start the dynamic analysis of the embedded Linux kernels. Next, we are going to discuss two other challenges when modeling the Type-I peripherals. The second challenge is that even one type of peripherals, e.g., interrupt controllers, have different models. Do we need to model each interrupt controller? The answer is no. Based on our observation, the driver of an interrupt controller must obey the protocol defined by the Linux kernel in the interrupt subsystem. To solve this challenge, we extract generic state machines from the Linux kernel subsystems for further high fidelity model construction. The third challenge is that each peripheral has complex interactive semantics. For example, to mask an interrupt source, an interrupt controller will read the mask register, mask one specific bit, and then write the value back to the register. To load the number of a pending interrupt, an interrupt controller will load the corresponding value, parse it, and invoke the relative interrupt service routine. We observe that the driver of an interrupt controller has to implement the callbacks defined in the interrupt subsystem. Each specific driver callback embeds such complex interactive semantics via MMIO read and write sequences. We analyze the drivers of Type-I peripherals and extract MMIO read and write sequences from these callbacks to complement the state machine extracted from the interrupt subsystem. In our paper, we propose a new technique named model-guided kernel execution. The idea is that we can leverage a state machine model to guide the kernel's execution. The peripheral model consists of two parts. The first part is the model template, that is, a state machine. It is manually constructed by experts. Note that the transition condition is blank. The second part is MMIO read and write sequences as transition conditions. This part can be automatically inferred by analyzing the source code of the drivers. How does the model-guided kernel execution work? The peripheral model monitors the execution of the Linux kernel, compares the MMIO read and write sequences encoded in the state machine, and then transit to the corresponding states. Finally, the Linux kernel will successfully boot and spawn an interactive shell. Here is a running example. The left figure has two representative callback functions of an interrupt controller driver in the Linux kernel. The right figure shows how the peripheral model works. In the irq_mask_callback function, it first issues an MMIO read. In the peripheral model, we monitor this MMIO read. Give a concrete irq, we do mask a specific bit in the variable mask, and then issue an MMIO write. The peripheral model can detect this MMIO read and write sequence. The peripheral model can infer the specific interrupt request number by the write value and then mask it. Similarly, the callback function handle_irq_callback reads the current pending interrupt sources. After monitoring it, the peripheral model will check the current state machine and return the number of the pending interrupt. The example shows that the MMIO read and write sequences from the Linux kernel can be recognized to drive the state machine of our emulated peripherals, which is the core idea of how the model-guided kernel execution works. How to construct the peripheral model? In the above row, we first manually analyze the Linux kernel subsystems and construct the model template manually. In the bottom row, we parse the device tree blob to get some parameters, such as the number of interrupts that an interrupt controller can support, then automatically analyze the driver code. The automated inference has three parts. The first part is the basic MMIO read and write sequence extraction via symbolic execution. The second part is to handle CFSV. CFSV are kernel-maintained shared variables. They will cache the value of the MMIO registers. We have to analyze them and consider them as part of the peripheral model. Otherwise, the peripheral model will lose track of the interaction semantics. The third part is to infer the semantic difference between the hardware and the Linux kernel. Specifically, the time unit used by the hardware and the Linux kernel is different. We have to calculate the difference and convert it to hardware-recognized or kernel-recognized value. Then, we have the MMIO read and write sequences with more information for each state transition. Finally, we convert the peripheral model to QEMU virtual device. In general, we semi-automatically build the state machine of each peripheral with a general model template and model parameters. Here is our system design and implementation. FirmGuide consists of two components. The first component, \"offline model generation\", analyzes the Linux kernel source code and generates virtual devices finally. This component uses LLVM pass for preprocessing, KLEE for MMIO read and write sequences analysis, and Python scripts for gluing. The second component, \"online kernel booting\", accepts the binary firmware, lists the peripherals in its device tree blob, and composes the whole virtual machine. This component uses Python for the main logic and leverages the template-render design pattern for code generation. The first question in our evaluation is what peripherals models FirmGuide can generate. As shown in the first table, FirmGuide can support five different families of SoCs, covering six interrupt controllers and five timers. In the parameter inference, the symbolic execution engine can solve the first solution within 1 hour. We also count the number of CFSV and timer semantic-aware values. Our experiences show that these peripheral models can support the basic functionality of a rehosted embedded Linux kernel. In the second table, we list the number of Type-II peripherals and the number of initialized values we should handle to avoid being stuck when the Linux kernel is booting. In general, because the number of initial values is limited, they are easier to handle with the symbolic execution. The second question is what embedded Linux kernel we can rehost. In the figure, we list the number of unpacked firmware, the number of extracted kernels, the number of embedded kernels that go to the user space, and the number of embedded kernels that spawn shells. Given more than six thousand of firmware crossing ten vendors, three architectures, and 22 Linux kernel versions, FirmGuide can successfully rehost more than 96% of them, showing the scalability of FirmGuide. The third question is about the functionality or fidelity of the rehosted embedded Linux kernels via the system call testing tools in the Linux Test Project. We manually develop a QEMU virtual machine with well-constructed Type-I peripherals and compare the result with the one FirmGuide generates. Results in the table show that FirmGuide generated virtual machines has the same fidelity as manually developed QEMU virtual machine regarding the system calls. The fourth question is the applications of FirmGuide. We use FirmGuide to reproduce and develop exploits for six Linux kernel CVEs. We also leverage fuzzing to test the rehosted embedded Linux kernel. Here we are. First, we proposed a novel technique. Second, we design and implement the first semi-automatic framework for embedded Linux kernel rehosting. Last, we apply FirmGuide to analyze and discover the bugs in the embedded Linux kernel. At last, I'd like to discuss the limitation of FirmGuide and future work. First, we need experts to extract the state machine from the Linux kernel subsystems manually. It depends on a well-formed abstraction. It is still challenging to infer the peripheral model automatically for complicated peripherals. Second, FirmGuide cannot support the high fidelity of Type-II peripherals due to our minimum best efforts strategy. It is an important problem to support more Type-II peripherals and enable more analysis of Type-II peripheral drivers in the embedded Linux kernel. Thank you!","title":"Text (15 mins, ~1500 words) and Slides"},{"location":"posts/2021-12-13-Summary-of-CS725/","text":"A brief summary of CS-725 CS-725: Topics in Language-based Software Security , co-taught by Mathias Payer and Manuel Egele, is an inspiring seminar on software testing (finding bugs), and mitigation (protecting against the exploitation of bugs). What we did during the seminar: give presentation, ask questions, and give feedbacks. What I learned from the seminar: experiences, conclusion for research, techniques, and implementation. What are the difference between sanitizers and mitigation? How to estimate the overhead? Is the evaluation fair and enough? Why it this a survey paper rather than an SoK? ... What I felt about the seminar: 1) both teachers and students are dedicated; 2) the whole class is self-organized, 3) I didn't spend much time on it but learned something. I attended a similar seminar on system (not system security) in Zhejiang University. Here are some differences. This system seminar does not actually match my research interests. Only the last lesson was about system security. Most of the time, I did not listen or just skipped lessons. I chose this seminar because I needed two more credits and there was no more security-focused seminars at all. It's better to cut down the credit requirement or join a seminar hosted by our supervisors who have free time. The teaching material in this system seminar were the latest papers accepted by OSDI and SOSP, which might not be the best choices because we know nothing about the related work. We may need famous and cited papers like in CS-725. It's the instructor that introduced papers in class not students. Considering not all students were interested in this seminar, this might be a better choice. We don't know why. Why this? Why that? In the final examination, we were required to find the authors' claims in the paper and fill them into the blanks. We have to spend two 45-minutes sessions for this system seminar and we have to spend extra time to prepare the examination. For CS-725, we speed one 45-minute session for class, and one session for preparing slides and writing summary. For CS-725, the whole time spent on the seminar won't exceed the requirement of two credits. Chinese Universities really should learn this!!!","title":"A brief summary of CS-725"},{"location":"posts/2021-12-13-Summary-of-CS725/#a-brief-summary-of-cs-725","text":"CS-725: Topics in Language-based Software Security , co-taught by Mathias Payer and Manuel Egele, is an inspiring seminar on software testing (finding bugs), and mitigation (protecting against the exploitation of bugs). What we did during the seminar: give presentation, ask questions, and give feedbacks. What I learned from the seminar: experiences, conclusion for research, techniques, and implementation. What are the difference between sanitizers and mitigation? How to estimate the overhead? Is the evaluation fair and enough? Why it this a survey paper rather than an SoK? ... What I felt about the seminar: 1) both teachers and students are dedicated; 2) the whole class is self-organized, 3) I didn't spend much time on it but learned something. I attended a similar seminar on system (not system security) in Zhejiang University. Here are some differences. This system seminar does not actually match my research interests. Only the last lesson was about system security. Most of the time, I did not listen or just skipped lessons. I chose this seminar because I needed two more credits and there was no more security-focused seminars at all. It's better to cut down the credit requirement or join a seminar hosted by our supervisors who have free time. The teaching material in this system seminar were the latest papers accepted by OSDI and SOSP, which might not be the best choices because we know nothing about the related work. We may need famous and cited papers like in CS-725. It's the instructor that introduced papers in class not students. Considering not all students were interested in this seminar, this might be a better choice. We don't know why. Why this? Why that? In the final examination, we were required to find the authors' claims in the paper and fill them into the blanks. We have to spend two 45-minutes sessions for this system seminar and we have to spend extra time to prepare the examination. For CS-725, we speed one 45-minute session for class, and one session for preparing slides and writing summary. For CS-725, the whole time spent on the seminar won't exceed the requirement of two credits. Chinese Universities really should learn this!!!","title":"A brief summary of CS-725"}]}