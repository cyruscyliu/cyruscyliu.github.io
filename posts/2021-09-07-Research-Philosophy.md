# How to Do [System|Software] (Security) Research

## Where to find a problem
Most practical ideas come from your research activities. Usually, we can read
and propose a new idea after reading a paper. However, there would be a delay.
First, a research paper would be published two years later than its authors came
up with that idea. Second, even though some PC members can check all interesting
papers submitted to a conference, there is about half a year or one-year delay.
How can we fill the gap? No, we cannot unless we are connecting or collaborating
with these scholars. Another source of research ideas is practical requirements
from users. This source is so so inefficient unless we are connecting or
collaborating with industry people. **Practical ideas come from our research
activities, and we should be curious about everything in our research activities
all the time.** To make it more clear, we can put it in this way. We can study
everything. Whenever you find or hear of a thing, we should show our interests
and clarify the motivation to study it. **Of course, do not forget our
connection with the academic and industrial community in which inevitable
benefits will come as well.**

## How to define problems
Before going further, I’d like to discuss the types of knowledge. One type of
knowledge looks forward, and the other focuses on backward. Classifying research
ideas in computer science bridges computer science to other disciplines. Physics
looks forward, and history looks backward. We should also think in this way
during our research activities. Designing a system looks forward while reviewing
literature looks backward. Learning the history of all science helps to improve
our research quality of ideas, evaluation, and writing. **Here, we have the
first category you should judge for a thing to be studied: looking forward or
looking backward.**

A thing is an object to be studied. During our activities, we always do
something. We should be curious about a thing since it would be our research
object. An object can be a thing in the real world, for example, a piece of
software; an object can be a process of humans, for example, developing a piece
of software. We can see similarities and differences between them.
Interestingly, if we focus on a thing itself, the research problems would look
forward; if we focus on a human process, the research problems look backward.
**Here, we have the second category: a thing or a human process.**

Define a looking-forward problem starting from its nature while define a
looking-backward problem starting from history. To make our research more
scientific, we should avoid some construction problems that usually make
computer science (and technology) to computer engineering in which all
scientific parts hide. For a looking-forward problem, we have to define what to
predict, and for a looking-backward problem, we should define what to summarize.
**Here, we have the third category: nature and history.**

BTW, check [this
article](https://medium.com/digital-diplomacy/how-to-look-for-ideas-in-computer-science-research-7a3fa6f4696f)
to learn the patterns of research and other tips.

## How to evaluate your problems
Now, we have two simple problems: what to predict and what to summarize. We have
to introduce more principles to evaluate our problems because not all problems
are worthy of study.

The first question is whether a problem is generic. **We have to check whether
this problem has many instances in the real world, such that the real impact is
there.**

The second question is whether a problem is solvable. We have to seek help from
the computation theory and estimate what the best we can do. **We should
carefully take reasonable assumptions and think of several different
solutions.**

## How to evaluate your ideas
Remember that not all ideas can be accepted by top-tier conferences. One is the
**novelty**, and the other is **superiority**. To be novel, we have to do a
literature review and distinguish our idea from others’. Because of the time
budget, we cannot make our idea superior to others in every aspect, and thus we
can choose the core metrics. The core metrics evolve among the development of
the whole community. Some technology becomes mature such that some metrics are
easier to achieve. Such easier metrics are not core metrics but the metrics you
have to include. Consider all techniques you can use to be superior.

OK. Let us evaluate our ideas. To save time, we are not supposed to make many
mistakes. Nowadays, the computer science research community is competitive
because not only most of the problems are easier to solve but also more and more
people join us. When reviewers judge a manuscript, they pick up your mistakes
and reject the papers that have more. Here are some tips from past research
activities to evaluate our ideas quickly.

### Budge your time
- **Always consider what you are doing to be some paragraph in the paper and never do it twice.**
- **Think and ask ourselves about what is the fastest way to do this and then do it.**
- **Spend 30 seconds more to save us from a 30 mins disaster.**
- Spend less than one day on a project you are not the first author.
- Have a rest in the evening or on weekends if we can focus more on weekdays.

### Know what you are going to do
- **Review papers and run their systems (related work)**
- **Identify challenges and evaluate solutions in theory (challenges, insights, solutions)**
- **Design system and evaluate design choices in theory (background, system design)**
- **Implement a prototype and write evaluation scripts (implementation, evaluation)**
- **Write our paper in advance and get feedback from others**.

### Reviews papers
- Always run their systems
- Survey all related work you might use

## Some tips about parallel tasks
- Always be clear about the shared things: data, and storage
- Be more automatic

## How to sell your idea

### Write a good paper
- Keep learning to write a paper
- Reader-centric writing
- Unity, Support, and Coherent
- Revise, revise, and revise: practical abstraction

### Advertise
- Homepage
- Twitteriture
- Group
- Main conference session
- Poster session