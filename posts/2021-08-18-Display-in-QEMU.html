<!DOCTYPE html>
<html>
<head>
<title>2021-08-18-Display-in-QEMU.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>
<link rel="stylesheet" href="https://cyruscyliu.github.io/styles/light-default.css" type="text/css">
<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="display-in-qemu">Display in QEMU</h1>
<p>Gerd Hoffmann has introduced graphics in QEMU here and there[^1], and in this
article, I will do some basic introduction about QEMU displays and QEMU consoles
with QEMU code (QEMU 6.1.0-rc3).</p>
<h2 id="qemu-displays">QEMU Displays</h2>
<p>QEMU displays are a set of display change listeners with the support of text or
graphic tools on the host machine.</p>
<h3 id="qemu-display-options">QEMU Display options</h3>
<p>As claimed <a href="https://wiki.gentoo.org/wiki/QEMU/Options">here</a>, we can send the
QEMU display to sdl/curses/gtk/vnc/spice windows, or just do not display video
output. Only curses supports text mode. &quot;Nothing is displayed when the graphics
device is in graphical mode or if the graphics device does not support a text
mode. Generally, only the VGA device models support text mode.&quot;</p>
<p>To talk to the host, each display has a change listener with several callbacks
that would call the relative APIs. For example, <code>curses_update</code> will call
<a href="https://linux.die.net/man/3/pnoutrefresh"><code>pnoutrefresh</code></a>.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> DisplayChangeListenerOps dcl_ops = {
    .dpy_name        = <span class="hljs-string">"curses"</span>,
    .dpy_text_update = curses_update,
    .dpy_text_resize = curses_resize,
    .dpy_refresh     = curses_refresh,
    .dpy_text_cursor = curses_cursor_position,
};
</div></code></pre>
<p>Here are all change listener callbacks.</p>
<pre class="hljs"><code><div>ui/curses.c:767:static const DisplayChangeListenerOps dcl_ops = {
ui/sdl2.c:761:static const DisplayChangeListenerOps dcl_2d_ops = {
ui/sdl2.c:772:static const DisplayChangeListenerOps dcl_gl_ops = {
ui/spice-display.c:775:static const DisplayChangeListenerOps display_listener_ops = {
ui/spice-display.c:1096:static const DisplayChangeListenerOps display_listener_gl_ops = {
ui/egl-headless.c:154:static const DisplayChangeListenerOps egl_ops = {
ui/cocoa.m:86:static const DisplayChangeListenerOps dcl_ops = {
ui/gtk.c:607:static const DisplayChangeListenerOps dcl_ops = {
ui/gtk.c:635:static const DisplayChangeListenerOps dcl_gl_area_ops = {
ui/gtk.c:656:static const DisplayChangeListenerOps dcl_egl_ops = {
ui/vnc.c:3337:static const DisplayChangeListenerOps dcl_ops = {
</div></code></pre>
<h3 id="in-qemu-the-registration-process-is-in-the-following">In QEMU, the registration process is in the following.</h3>
<p>First, <code>qemu_display_register</code> will register all <code>QemuDisplay</code> objects to
<code>dpys[DISPLAY_TYPE__MAX]</code>.</p>
<pre class="hljs"><code><div>static QemuDisplay *dpys[DISPLAY_TYPE__MAX];

void qemu_display_register(QemuDisplay *ui) {
    assert(ui-&gt;type &lt; DISPLAY_TYPE__MAX);
    dpys[ui-&gt;type] = ui; // S3
}

static QemuDisplay qemu_display_curses = {
    .type       = DISPLAY_TYPE_CURSES,
    .init       = curses_display_init,
};

static void register_curses(void) {
    qemu_display_register(&amp;qemu_display_curses); // S2
}

type_init(register_curses); // S1
</div></code></pre>
<p>Second, <code>qemu_init_displays</code> will first initialize a global <code>DisplayState</code> and
initialize all text consoles if available. Then, <code>qemu_init_displays</code> will call
<code>qemu_display_init</code>, and then call all <code>.init</code> registered if <code>-display none</code> is
not set.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">static</span> DisplayState *<span class="hljs-title">get_alloc_displaystate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-keyword">if</span> (!display_state) {
        display_state = g_new0(DisplayState, <span class="hljs-number">1</span>);
        cursor_timer = timer_new_ms(
            QEMU_CLOCK_REALTIME, text_console_update_cursor, <span class="hljs-literal">NULL</span>);
    }
    <span class="hljs-keyword">return</span> display_state;
}

<span class="hljs-function">DisplayState *<span class="hljs-title">init_displaystate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    gchar *name;
    QemuConsole *con;

    get_alloc_displaystate();
    QTAILQ_FOREACH(con, &amp;consoles, next) {
        <span class="hljs-keyword">if</span> (con-&gt;console_type != GRAPHIC_CONSOLE &amp;&amp;
            con-&gt;ds == <span class="hljs-literal">NULL</span>) {
            text_console_do_init(con-&gt;chr, display_state);
        }
        ...
    }
    <span class="hljs-keyword">return</span> display_state;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qemu_display_init</span><span class="hljs-params">(DisplayState *ds, DisplayOptions *opts)</span> </span>{
    <span class="hljs-keyword">if</span> (opts-&gt;type == DISPLAY_TYPE_NONE) {
        <span class="hljs-keyword">return</span>;
    }
    assert(dpys[opts-&gt;type] != <span class="hljs-literal">NULL</span>);
    dpys[opts-&gt;type]-&gt;init(ds, opts);
}
</div></code></pre>
<h2 id="qemu-console">QEMU Console</h2>
<p>QEMU consoles are the bridges between video devices and QEMU displays.</p>
<h3 id="qemu-consoles-are-defined-as-a-list-of-qemuconsole">QEMU consoles are defined as a list of <code>QemuConsole</code>.</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">QTAILQ_HEAD</span><span class="hljs-params">(, QemuConsole)</span> consoles </span>= QTAILQ_HEAD_INITIALIZER(consoles);
</div></code></pre>
<ul>
<li>There is a for-each primitive to traverse each <code>QemuConsole</code>.</li>
</ul>
<pre class="hljs"><code><div>QTAILQ_FOREACH(con, &amp;consoles, next) { }
</div></code></pre>
<ul>
<li>There are several high-level primitives to access a <code>QemuConsole</code> as well.</li>
</ul>
<pre class="hljs"><code><div>qemu_console_lookup_by_index(... index)
qemu_console_lookup_by_device(... dev, ... head)
qemu_console_lookup_by_device_name(... device_id, head) <span class="hljs-comment">// device_id -&gt; dev</span>
qemu_console_lookup_unused()
</div></code></pre>
<h3 id="qemu-consoles-have-three-types">QEMU consoles have three types.</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> {
    GRAPHIC_CONSOLE, TEXT_CONSOLE, TEXT_CONSOLE_FIXED_SIZE
} <span class="hljs-keyword">console_type_t</span>;
</div></code></pre>
<ul>
<li><code>GRAPHIC_CONSOLE</code></li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// e.g., ati-vga</span>
ati_vga_realize -&gt; graphic_console_init -&gt; new_console(..., GRAPHIC_CONSOLE, ...)
</div></code></pre>
<p>Other examples are in the following.</p>
<pre class="hljs"><code><div>hw/display/pl110.c
hw/display/g364fb.c
hw/display/virtio-gpu-base.c
hw/display/bochs-display.c
hw/display/vga-pci.c
hw/display/vmware_vga.c
hw/display/xlnx_dp.c
hw/display/vga-isa-mm.c
hw/display/cirrus_vga.c
hw/display/ramfb-standalone.c
hw/display/exynos4210_fimd.c
hw/display/macfb.c
hw/display/bcm2835_fb.c
hw/display/cg3.c
hw/display/xenfb.c
hw/display/cirrus_vga_isa.c
hw/display/omap_lcdc.c
hw/display/jazz_led.c
hw/display/tc6393xb.c
hw/display/milkymist-vgafb.c
hw/display/vga-isa.c
hw/display/next-fb.c
hw/display/ssd0323.c
hw/display/ati.c
hw/display/artist.c
hw/display/qxl.c
hw/display/ssd0303.c
hw/display/tcx.c
hw/display/omap_dss.c
hw/display/sm501.c
hw/display/blizzard.c
hw/display/pxa2xx_lcd.c
</div></code></pre>
<ul>
<li><code>TEXT_CONSOLE[_FIXED_SIZE]</code></li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// e.g., chardev-vc</span>
vc_chr_open -&gt; new_console(..., TEXT_CONSOLE[_FIXED_SIZE], ...)
</div></code></pre>
<h3 id="qemu-consoles-are-initialized-by-newconsole">QEMU consoles are initialized by <code>new_console</code>.</h3>
<p>First, <code>new_console</code> allocates an object and initializes some fields.</p>
<pre class="hljs"><code><div>obj = object_new(TYPE_QEMU_CONSOLE);
s = QEMU_CONSOLE(obj);
qemu_co_queue_init(&amp;s-&gt;dump_queue);
s-&gt;head = head;
</div></code></pre>
<p>Then, if no console is activated, it will choose the first allocated console.
However, a graphic console can override others.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (!active_console || ((active_console-&gt;console_type != GRAPHIC_CONSOLE) &amp;&amp;
    (console_type == GRAPHIC_CONSOLE))) {
    active_console = s;
}
</div></code></pre>
<p>Next, still some fields.</p>
<pre class="hljs"><code><div>s-&gt;ds = ds; <span class="hljs-comment">// with display change listeners </span>
s-&gt;console_type = console_type;
s-&gt;window_id = <span class="hljs-number">-1</span>;
</div></code></pre>
<p>Last, <code>new_console</code> will insert the allocated object to the list <code>consoles</code>.</p>
<ul>
<li>If the list is empty, insert the object directly and then set the index to 0.</li>
<li>If the object is not a graphic console and QEMU is in the phase
of <code>PHASE_MACHINE_READY</code>, append the object and update its index.</li>
<li>If the object is a graphic console, append the object to the last graphic
console and keep the graphic consoles in front of the text consoles. If in this
situation, the text consoles will be renumbered.</li>
</ul>
<h2 id="qemu-consoles-qemu-video-devices-and-qemu-displays">QEMU consoles, QEMU video devices and QEMU displays</h2>
<h3 id="a-typical-example-would-be-graphicconsoleinit">A typical example would be <code>graphic_console_init</code>.</h3>
<p>First, by calling <code>get_alloc_dispaly</code>, it allocates or gets an allocated
<code>DisplayState</code> that is bonded to a list of display change listeners.</p>
<pre class="hljs"><code><div>ds = get_alloc_displaystate();
</div></code></pre>
<p>Second, it finds an unused QEMU console by <code>qemu_console_lookup_unused</code>. A QEMU
console is unused when it is at least not linked to a QEMU video device. If
there is no console available, it will call <code>new_console</code> to allocate a graphic
console with the allocated <code>DisplayState</code>.</p>
<pre class="hljs"><code><div>s = qemu_console_lookup_unused();
<span class="hljs-keyword">if</span> (s) {
    <span class="hljs-keyword">if</span> (s-&gt;surface) {
        <span class="hljs-built_in">width</span> = surface_width(s-&gt;surface);
        <span class="hljs-built_in">height</span> = surface_height(s-&gt;surface);
    }
} <span class="hljs-keyword">else</span> {
    s = new_console(ds, GRAPHIC_CONSOLE, head);
    s-&gt;ui_timer = timer_new_ms(QEMU_CLOCK_REALTIME, dpy_set_ui_info_timer, s);
}
</div></code></pre>
<p>Third, it links the console to the QEMU video device and registers relative
callbacks.</p>
<pre class="hljs"><code><div>graphic_console_set_hwops(s, hw_ops, opaque);
<span class="hljs-keyword">if</span> (dev) {
    object_property_set_link(OBJECT(s), <span class="hljs-string">"device"</span>, OBJECT(dev), &amp;error_abort);
}
</div></code></pre>
<p>Finally, create a surface and notify all QEMU displays through
<code>s-&gt;ds-&gt;listeners</code>.</p>
<pre class="hljs"><code><div>surface = qemu_create_placeholder_surface(<span class="hljs-built_in">width</span>, <span class="hljs-built_in">height</span>, noinit);
dpy_gfx_replace_surface(s, surface);
</div></code></pre>
<p>Here is a summary.</p>
<pre class="hljs"><code><div>+------------------+           +------------+              +-------------+
+QEMU vidio devices+ &lt;-hw_ops- +QEMU console+ -listeners-&gt; +QEMU dispalys+
+------------------+           +------------+              +-------------+
</div></code></pre>
<h3 id="when-it-comes-to-a-text-console-things-are-similar">When it comes to a text console, things are similar.</h3>
<p>First, allocate a QEMU console.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (<span class="hljs-built_in">width</span> == <span class="hljs-number">0</span> || <span class="hljs-built_in">height</span> == <span class="hljs-number">0</span>) {
    s = new_console(<span class="hljs-literal">NULL</span>, TEXT_CONSOLE, <span class="hljs-number">0</span>);
} <span class="hljs-keyword">else</span> {
    s = new_console(<span class="hljs-literal">NULL</span>, TEXT_CONSOLE_FIXED_SIZE, <span class="hljs-number">0</span>);
    s-&gt;surface = qemu_create_displaysurface(<span class="hljs-built_in">width</span>, <span class="hljs-built_in">height</span>);
}
</div></code></pre>
<p>Then, link the console with the <code>ChardevVC</code>, <code>DisplayState</code> if available and
relative hardware operations.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">text_console_do_init</span><span class="hljs-params">(Chardev *chr, DisplayState *ds)</span> </span>{
    s-&gt;ds = ds
    ...
    s-&gt;hw_ops = &amp;text_console_ops;
    s-&gt;hw = s;
    ...
}
</div></code></pre>
<h2 id="interactions-through-qemu-consoles">Interactions through QEMU consoles</h2>
<h3 id="first-of-all-we-will-figure-out-when-the-hwops-are-called">First of all, we will figure out when the hw_ops are called.</h3>
<p>All hw_ops are defined in the following.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GraphicHwOps</span> {</span>
    <span class="hljs-keyword">int</span> (*get_flags)(<span class="hljs-keyword">void</span> *opaque); <span class="hljs-comment">/* optional, default 0 */</span>
    <span class="hljs-keyword">void</span> (*invalidate)(<span class="hljs-keyword">void</span> *opaque);
    <span class="hljs-keyword">void</span> (*gfx_update)(<span class="hljs-keyword">void</span> *opaque);
    <span class="hljs-keyword">bool</span> gfx_update_async; <span class="hljs-comment">/* if true, calls graphic_hw_update_done() */</span>
    <span class="hljs-keyword">void</span> (*text_update)(<span class="hljs-keyword">void</span> *opaque, <span class="hljs-keyword">console_ch_t</span> *<span class="hljs-built_in">text</span>);
    <span class="hljs-keyword">void</span> (*update_interval)(<span class="hljs-keyword">void</span> *opaque, <span class="hljs-keyword">uint64_t</span> interval);
    <span class="hljs-keyword">int</span> (*ui_info)(<span class="hljs-keyword">void</span> *opaque, <span class="hljs-keyword">uint32_t</span> head, QemuUIInfo *info);
    <span class="hljs-keyword">void</span> (*gl_block)(<span class="hljs-keyword">void</span> *opaque, <span class="hljs-keyword">bool</span> block);
    <span class="hljs-keyword">void</span> (*gl_flushed)(<span class="hljs-keyword">void</span> *opaque);
} GraphicHwOps;
</div></code></pre>
<p>We can group them according to their usage.</p>
<h4 id="group-1-graphichwxxx">Group 1: graphic_hw_xxx</h4>
<p>Callbacks in this group will be called by QEMU displays. Graphic displays
usually call <code>graphic_hw_update</code>, while text displays would call
<code>graphic_hw_text_udpate</code>. A virtual device must tell the corresponding QEMU
displays what should do by implementing these callbacks.</p>
<pre class="hljs"><code><div>graphic_hw_update (gfx_update)
graphic_hw_text_update
graphic_hw_invalidate 
graphic_hw_gl_block
graphic_hw_gl_flushed
</div></code></pre>
<h4 id="group-2-guiupdate---updateinterval">Group 2: gui_update -&gt; update_interval</h4>
<p>When <code>register_displaychangelistener</code> is called by a QEMU display, it will set a
timer to call <code>phy_refresh</code> periodically. A virtual device can implement
<code>update_interval</code> to synchronize the interval of the timer.</p>
<h4 id="group-3-dpycompatiblewith-and-dpysetuiinfotimer">Group 3: dpy_compatible_with and dpy_set_ui_info_timer</h4>
<p>The former checks whether a video device is compatible with a QEMU display by
calling <code>get_flags</code>. The latter will be triggered when ui info should be told to
the guest.</p>
<h3 id="second-we-will-figure-out-how-the-display-listener-callbacks-work">Second, we will figure out how the display listener callbacks work.</h3>
<h4 id="an-example-of-graphic-qemu-display">An example of graphic QEMU display</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> DisplayChangeListenerOps dcl_ops = {
    .dpy_name             = <span class="hljs-string">"gtk"</span>,
    .dpy_gfx_update       = gd_update,
    .dpy_gfx_switch       = gd_switch,
    .dpy_gfx_check_format = qemu_pixman_check_format,
    .dpy_refresh          = gd_refresh,
    .dpy_mouse_set        = gd_mouse_set,
    .dpy_cursor_define    = gd_cursor_define,
};
</div></code></pre>
<ul>
<li><code>dpy_gfx_update</code>, <code>dpy_gfx_check_format</code>, <code>dpy_mouse_set</code>, and <code>dpy_cursor_define</code>
will be called from vedio devices.</li>
<li><code>dpy_refresh</code> is illustrated above.</li>
<li><code>gpy_gfx_switch</code> will be called in <code>register_displaychangelistener</code> or will be
called by QEMU displays.</li>
</ul>
<h3 id="what-about-together">What about together?</h3>
<p>Let's review the history of graphic devices.</p>
<ul>
<li>1st gen VGA Card: output images but leave all calculations to CPU</li>
<li>2nd gen Graphics Card: integrate image output and processing</li>
<li>3rd gen Video Card: take over the video coding-encoding from CPU</li>
<li>4th gen 3D Accelerator Card: take over the 3D Accelerator from a special 3D card</li>
<li>5th gen GPU: integrate more generic calculation tasks</li>
</ul>
<p>Basically, a video device will process and output images.  In QEMU,
periodically, <code>graphic_hw_update</code> will be called switching from QEMU displays to
QEMU video devices. The devices will process the image and then call
<code>dpy_gfx_update</code> to inform the changes to QEMU displays.</p>
<p>[^1]: <a href="https://www.kraxel.org/slides/qemu-gfx/">Graphics in QEMU</a></p>

</body>
</html>
