
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://github.com/cyruscyliu/cyruscyliu.github.io/posts/2021-11-15-ase-firmguide/">
      
      
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.2">
    
    
      
        <title>ASE'21 - FirmGuide - Qiang Liu's Homepage</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.50c56a3b.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#ase21-firmguide" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Qiang Liu&#39;s Homepage" class="md-header__button md-logo" aria-label="Qiang Liu's Homepage" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Qiang Liu's Homepage
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              ASE'21 - FirmGuide
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Qiang Liu&#39;s Homepage" class="md-nav__button md-logo" aria-label="Qiang Liu's Homepage" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Qiang Liu's Homepage
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Posts
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#text-15-mins-1500-words-and-slides" class="md-nav__link">
    <span class="md-ellipsis">
      Text (15 mins, ~1500 words) and Slides
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="ase21-firmguide">ASE'21 - FirmGuide</h1>
<p>This is the speech text of FirmGuide for ASE'21.</p>
<h2 id="text-15-mins-1500-words-and-slides">Text (15 mins, ~1500 words) and <a href="../2021-11-15-ase-firmguide.pdf">Slides</a></h2>
<p>Hello, everyone. My name is Liu Qiang from Zhejiang University. I'm going to
introduce one of our works on firmware rehosting: FirmGuide. This is a joint
work with Zhang Cheng, the other co-first author, and other authors from
Zhejiang University, Nanyang Technological University, and The Hong Kong
Polytechnic University.</p>
<p>Now high-end embedded devices like routers and IP cameras use the Linux kernel.
We want to dynamically understand and discover the bugs or vulnerabilities in the
context of embedded systems. However, it is not easy and scalable due to the
hardware requirements. The goal of this paper is then to rehost the embedded
Linux kernels with the best effort.</p>
<p>The rehosting has three challenges. First, a System on Chip or an SoC has
numerous peripherals. Based on the observation that whether a peripheral is
necessary to the Linux kernel core functionalities, we classify peripherals into
two types. Type-I peripherals, such as memory, interrupt
controllers, timers, and UART, are critical to memory management, scheduling, and
user-kernel interactions. We have to design high-fidelity models
for them. Others are type-II peripherals that are not necessary to be high
fidelity. We use dummy device models with proper initialized values to pass some
checks to avoid being stuck when the Linux kernel is booting. This
classification saves the time to model every type of peripherals, which is a
complicated problem that may take years. The minimum best effort, i.e., focusing
on Type-I peripherals, is the first step to start the dynamic analysis of the
embedded Linux kernels. Next, we are going to discuss two other challenges when
modeling the Type-I peripherals.</p>
<p>The second challenge is that even one type of peripherals, e.g., interrupt
controllers, have different models. Do we need to model each interrupt
controller? The answer is no. Based on our observation, the driver of an
interrupt controller must obey the protocol defined by the Linux kernel in the
interrupt subsystem. To solve this challenge, we extract generic state machines
from the Linux kernel subsystems for further high fidelity model construction.</p>
<p>The third challenge is that each peripheral has complex interactive semantics.
For example, to mask an interrupt source, an interrupt controller will read the
mask register, mask one specific bit, and then write the value back to the
register. To load the number of a pending interrupt, an interrupt controller
will load the corresponding value, parse it, and invoke the relative interrupt
service routine. We observe that the driver of an interrupt controller has to
implement the callbacks defined in the interrupt subsystem. Each specific driver
callback embeds such complex interactive semantics via MMIO read and write
sequences. We analyze the drivers of Type-I peripherals and extract MMIO read
and write sequences from these callbacks to complement the state machine
extracted from the interrupt subsystem.</p>
<p>In our paper, we propose a new technique named model-guided kernel execution.
The idea is that we can leverage a state machine model to guide the kernel's
execution. The peripheral model consists of two parts. The first part is the
model template, that is, a state machine. It is manually constructed by experts.
Note that the transition condition is blank. The second part is MMIO read and
write sequences as transition conditions. This part can be automatically
inferred by analyzing the source code of the drivers. How does the model-guided
kernel execution work? The peripheral model monitors the execution of the Linux
kernel, compares the MMIO read and write sequences encoded in the state machine,
and then transit to the corresponding states. Finally, the Linux kernel will
successfully boot and spawn an interactive shell.</p>
<p>Here is a running example. The left figure has two representative callback
functions of an interrupt controller driver in the Linux kernel. The right
figure shows how the peripheral model works. In the irq_mask_callback function,
it first issues an MMIO read. In the peripheral model, we monitor this MMIO
read. Give a concrete irq, we do mask a specific bit in the variable mask, and
then issue an MMIO write. The peripheral model can detect this MMIO read and
write sequence. The peripheral model can infer the specific interrupt request
number by the write value and then mask it. Similarly, the callback function
handle_irq_callback reads the current pending interrupt sources. After
monitoring it, the peripheral model will check the current state machine and
return the number of the pending interrupt. The example shows that the MMIO read
and write sequences from the Linux kernel can be recognized to drive the state
machine of our emulated peripherals, which is the core idea of how the
model-guided kernel execution works.</p>
<p>How to construct the peripheral model? In the above row, we first manually
analyze the Linux kernel subsystems and construct the model template manually.
In the bottom row, we parse the device tree blob to get some parameters, such as
the number of interrupts that an interrupt controller can support, then
automatically analyze the driver code. The automated inference has three parts.
The first part is the basic MMIO read and write sequence extraction via symbolic
execution. The second part is to handle CFSV. CFSV are kernel-maintained shared
variables. They will cache the value of the MMIO registers. We have to analyze
them and consider them as part of the peripheral model. Otherwise, the
peripheral model will lose track of the interaction semantics. The third part is
to infer the semantic difference between the hardware and the Linux kernel.
Specifically, the time unit used by the hardware and the Linux kernel is
different. We have to calculate the difference and convert it to
hardware-recognized or kernel-recognized value. Then, we have the MMIO read and
write sequences with more information for each state transition. Finally, we
convert the peripheral model to QEMU virtual device. In general, we
semi-automatically build the state machine of each peripheral with a general
model template and model parameters.</p>
<p>Here is our system design and implementation. FirmGuide consists of two
components. The first component, "offline model generation", analyzes the Linux
kernel source code and generates virtual devices finally. This component uses
LLVM pass for preprocessing, KLEE for MMIO read and write sequences analysis,
and Python scripts for gluing. The second component, "online kernel booting",
accepts the binary firmware, lists the peripherals in its device tree blob, and
composes the whole virtual machine. This component uses Python for the main
logic and leverages the template-render design pattern for code generation.</p>
<p>The first question in our evaluation is what peripherals models FirmGuide can
generate. As shown in the first table, FirmGuide can support five different
families of SoCs, covering six interrupt controllers and five timers. In the
parameter inference, the symbolic execution engine can solve the first solution
within 1 hour. We also count the number of CFSV and timer semantic-aware values.
Our experiences show that these peripheral models can support the basic
functionality of a rehosted embedded Linux kernel. In the second table, we list
the number of Type-II peripherals and the number of initialized values we should
handle to avoid being stuck when the Linux kernel is booting. In general,
because the number of initial values is limited, they are easier to handle with
the symbolic execution.</p>
<p>The second question is what embedded Linux kernel we can rehost. In the
figure, we list the number of unpacked firmware, the number of extracted
kernels, the number of embedded kernels that go to the user space, and the
number of embedded kernels that spawn shells. Given more than six thousand of
firmware crossing ten vendors, three architectures, and 22 Linux kernel
versions, FirmGuide can successfully rehost more than 96% of them, showing the
scalability of FirmGuide.</p>
<p>The third question is about the functionality or fidelity of the rehosted
embedded Linux kernels via the system call testing tools in the Linux Test
Project. We manually develop a QEMU virtual machine with well-constructed Type-I
peripherals and compare the result with the one FirmGuide generates. Results in
the table show that FirmGuide generated virtual machines has the same fidelity
as manually developed QEMU virtual machine regarding the system calls. The
fourth question is the applications of FirmGuide. We use FirmGuide to reproduce
and develop exploits for six Linux kernel CVEs. We also leverage fuzzing to
test the rehosted embedded Linux kernel.</p>
<p>Here we are. First, we proposed a novel technique. Second, we design and
implement the first semi-automatic framework for embedded Linux kernel
rehosting. Last, we apply FirmGuide to analyze and discover the bugs in the
embedded Linux kernel.</p>
<p>At last, I'd like to discuss the limitation of FirmGuide and future work.
First, we need experts to extract the state machine from the Linux kernel
subsystems manually. It depends on a well-formed abstraction. It is still
challenging to infer the peripheral model automatically for complicated
peripherals. Second, FirmGuide cannot support the high fidelity of Type-II
peripherals due to our minimum best efforts strategy. It is an important problem
to support more Type-II peripherals and enable more analysis of Type-II
peripheral drivers in the embedded Linux kernel.</p>
<p>Thank you!</p>







  
    
  
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="Last update">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1-2.1-2M12.5 7v5.2l4 2.4-1 1L11 13V7h1.5M11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2v1.8Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">March 6, 2022</span>
  </span>

    
    
    
    
  </aside>





                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.f886a092.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.d7c377c4.min.js"></script>
      
    
  </body>
</html>