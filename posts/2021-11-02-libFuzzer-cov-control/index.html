<!DOCTYPE html>
<html lang="en">
    <head>
      <script>
	// Hack for scrolling window when linking to anchor tag with fixed nav header
        var shiftWindow = function() { scrollBy(0, -75) };
        window.addEventListener("hashchange", shiftWindow);
        function load() { if (window.location.hash) shiftWindow(); }
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://github.com/cyruscyliu/cyruscyliu.github.io/posts/2021-11-02-libFuzzer-cov-control/">
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Coverage Control in libFuzzer - Qiang Liu's Homepage</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link href="../../css/font-awesome.min.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/http.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../../js/base.js"></script> 
    </head>

    <body class="">

      <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
	<div class="container">
	<a class="navbar-brand" href="../..">Qiang Liu's Homepage</a>
	<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarsExample04" aria-controls="navbarsExample04" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
	</button>

	<div class="collapse navbar-collapse">
          <!-- Main navigation -->
          <nav class="nav">
            <ul class="navbar-nav">
              <li >
                <a class="nav-link" href="../..">Qiang Liu's Homepage</a>
              </li>
              <li class="nav-item dropdown active">
                <a href="#" role="button" class="nav-link dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" id="nav-dropdown-Posts">Posts <b class="caret"></b></a>
                <div class="dropdown-menu" aria-labelledby="nav-dropdown-Posts">
                  
<a href="../2018-01-19-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E6%88%91%E7%9A%84%E7%9F%9B%E7%9B%BE%EF%BC%88%E6%8F%90%E7%BA%B2%EF%BC%89/" class="dropdown-item">ANU暑期学校-我的矛盾（提纲）</a>
                  
<a href="../2018-01-21-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E6%83%8A%E5%A5%87/" class="dropdown-item">ANU暑期学校-惊奇</a>
                  
<a href="../2018-01-23-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E6%97%A0%E9%A2%98/" class="dropdown-item">ANU暑期学校-无题</a>
                  
<a href="../2018-01-24-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E7%BB%BD%E6%94%BE/" class="dropdown-item">ANU暑期学校-绽放</a>
                  
<a href="../2018-02-01-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E6%88%91%E7%9A%84%E7%9F%9B%E7%9B%BE/" class="dropdown-item">ANU暑期学校-我的矛盾</a>
                  
<a href="../2018-02-07-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E5%B0%BE%E5%A3%B0/" class="dropdown-item">ANU暑期学校-尾声</a>
                  
<a href="../2018-02-07-ANU%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E7%94%9F%E6%B4%BB%E5%92%8C%E5%B7%A5%E4%BD%9C/" class="dropdown-item">ANU暑期学校-生活和工作</a>
                  
<a href="../2018-03-08-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%B8%80%E5%A4%A9/" class="dropdown-item">在杭州的100天-第一天</a>
                  
<a href="../2018-03-08-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%BA%8C%E5%A4%A9/" class="dropdown-item">在杭州的100天-第二天</a>
                  
<a href="../2018-03-10-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%B8%89%E5%A4%A9/" class="dropdown-item">在杭州的100天-第三天</a>
                  
<a href="../2018-03-11-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%B9%9D%E5%A4%A9/" class="dropdown-item">在杭州的100天-第九天</a>
                  
<a href="../2018-03-28-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E5%8D%81%E5%A4%A9/" class="dropdown-item">在杭州的100天-第十天</a>
                  
<a href="../2018-04-07-%E5%9C%A8%E6%9D%AD%E5%B7%9E%E7%9A%84100%E5%A4%A9-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E5%A4%A9/" class="dropdown-item">在杭州的100天-第二十七天</a>
                  
<a href="../2019-11-23-CCS-London-Summary/" class="dropdown-item">Summary of CCS'19 (London)</a>
                  
<a href="../2020-11-18-buildroot-qemu-x86_64/" class="dropdown-item">Buildroot, QEMU and Linux kernel for x86_64</a>
                  
<a href="../2020-11-30-wllvm-clang-qemu-x86_64/" class="dropdown-item">Clang, wllvm, passes, QEMU for x86_64</a>
                  
<a href="../2021-08-18-Display-in-QEMU/" class="dropdown-item">Display in QEMU</a>
                  
<a href="../2021-08-27-Principle-of-Presentation/" class="dropdown-item">Principles of Research Presentation</a>
                  
<a href="../2021-09-03-Summary-Research-SE/" class="dropdown-item">Programming Skills for Research</a>
                  
<a href="../2021-09-07-Research-Philosophy/" class="dropdown-item">How to Do [System|Software] (Security) Research</a>
                  
<a href="../2021-10-22-fuzzing-presentation/" class="dropdown-item">CS-725 Presentation - Fuzz Testing</a>
                  
<a href="../2021-10-27-introduction-to-bhyve/" class="dropdown-item">Introduction to Bhyve</a>
                  
<a href="./" class="dropdown-item active">Coverage Control in libFuzzer</a>
                  
<a href="../2021-11-15-ase-firmguide/" class="dropdown-item">ASE'21 - FirmGuide</a>
                  
<a href="../2021-12-13-Summary-of-CS725/" class="dropdown-item">A brief summary of CS-725</a>
                </div>
              </li>
            </ul>
          </nav>

          <ul class="navbar-nav flex-row ml-md-auto d-none d-md-flex">
            <li class="nav-item">
              <a class="nav-link" href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
		<i class="fa fa-search"></i> Search
              </a>
            </li>
          </ul>
	</div>
	</div>
      </nav><div id="content" class="container">
        
      <div class="row">
        <div class="col-md-9" role="main">


<nav aria-label="breadcrumb">
  <ol class="breadcrumb">
    
    
    <li class="breadcrumb-item">Posts</li>
    
    
    <li class="breadcrumb-item active" aria-current="page">Coverage Control in libFuzzer</li>
  </ol>
</nav>


<h1 id="coverage-control-in-libfuzzer">Coverage Control in libFuzzer</h1>
<p>This article reveals how to control the coverage collection in libFuzzer.</p>
<h2 id="how-to-use-libfuzzer">How to use libFuzzer?</h2>
<p>To use libFuzzer, it is necessary to develop a fuzz target. Please refer to
<a href="https://llvm.org/docs/LibFuzzer.html#id14">this</a> and
<a href="https://llvm.org/docs/LibFuzzer.html#id23">this</a> to check how to develop a fuzz
target and how to compile it with Clang.</p>
<h2 id="how-to-compiler-llvm-project">How to compiler LLVM project?</h2>
<p>Download llvm-project and compile like below. Please also refer to
<a href="https://llvm.org/docs/GettingStarted.html">this</a> and
<a href="https://clang.llvm.org/get_started.html">this</a>.</p>
<pre><code class="language-bash">git clone https://github.com/llvm/llvm-project.git --depth=1
mkdir build; cd build
cmake -G Ninja -DLLVM_USE_LINKER=gold -DLLVM_ENABLE_PROJECTS=&quot;clang;compiler-rt&quot; -DLLVM_TARGETS_TO_BUILD=X86 -DLLVM_OPTIMIZED_TABLEGEN=ON ../llvm/
ninja clang compiler-rt
export PATH=$PWD/bin:$PATH
</code></pre>
<h2 id="details-beneath-fsanitizefuzzer">Details beneath <code>-fsanitize=fuzzer</code></h2>
<p>As we all know, when compiling a program, a compiler will automatically expand
its compiler flags. If <code>-v</code> is enable, the compiler will show all flags.
Considering a very simple example: <code>clang -o foo -fsanitize=fuzzer foo.c</code>, the
full flags related to <code>-fsanitize</code> are in the following.</p>
<pre><code class="language-txt"># SIMPLIFIED
&quot;$LLVM/bin/clang-13&quot; -cc1 \
   -triple x86_64-unknown-linux-gnu \
   -emit-obj \
   -target-cpu x86-64 -v \
   -fsanitize-coverage-type=1 -fsanitize-coverage-type=3 \
   -fsanitize-coverage-indirect-calls \
   -fsanitize-coverage-trace-cmp \
   -fsanitize-coverage-inline-8bit-counters \
   -fsanitize-coverage-pc-table \
   -fsanitize-coverage-stack-depth \
   -fsanitize-coverage-trace-state \
   -fsanitize=fuzzer,fuzzer-no-link \
   -o /tmp/main-d501e8.o -x c main.c
# SIMPLIFIED
&quot;/usr/local/bin/ld&quot; -z relro \
   --hash-style=gnu --eh-frame-hdr \
    -m elf_x86_64 \
    -dynamic-linker /lib64/ld-linux-x86-64.so.2 \
    -o main \
    $LLVM/lib/clang/13.0.0/lib/linux/libclang_rt.fuzzer-x86_64.a \
    $LLVM/lib/clang/13.0.0/lib/linux/libclang_rt.fuzzer_interceptors-x86_64.a \
    $LLVM/lib/clang/13.0.0/lib/linux/libclang_rt.ubsan_standalone-x86_64.a \
    --dynamic-list=$LLVM/lib/clang/13.0.0/lib/linux/libclang_rt.ubsan_standalone-x86_64.a.syms \
    /tmp/main-d501e8.o
</code></pre>
<p>It's <code>SanitizerArgs()</code> that parses SanCov and sanitizers flags. The path to it
is in the following.</p>
<pre><code> [#0] clang::driver::SanitizerArgs::SanitizerArgs()
 [#1] clang::driver::ToolChain::getSanitizerArgs() const()
 [#2] clang::driver::toolchains::Linux::isPIEDefault() const()
 [#3] clang::driver::tools::ParsePICArgs()
 [#4] clang::driver::tools::Clang::ConstructJob()
 [#5] clang::driver::Driver::BuildJobsForActionNoCache()
 [#6] clang::driver::Driver::BuildJobsForAction()
 [#7] clang::driver::Driver::BuildJobsForActionNoCache()
 [#8] clang::driver::Driver::BuildJobsForAction()
 [#9] clang::driver::Driver::BuildJobs()
[#10] clang::driver::Driver::BuildCompilation()
[#11] main()
</code></pre>
<p>In <code>SanitizerArgs()</code>, <code>parseArgValues</code> will parse six sanitizer related flags.
<code>parseArgValues</code> will invoke <code>parseSanitizerValue</code> defined in
<code>clang/lib/Basic/Sanitizers.cpp</code> to parse sanitizers defined
<code>clang/include/clang/Basic/Sanitizers.def</code>.</p>
<pre><code class="language-c">// clang/include/clang/Basic/Sanitizers.def
// libFuzzer
SANITIZER(&quot;fuzzer&quot;, Fuzzer)

// libFuzzer-required instrumentation, no linking.
SANITIZER(&quot;fuzzer-no-link&quot;, FuzzerNoLink)
</code></pre>
<p>In <code>SanitizerArgs()</code>, <code>parseCoverageFeatures</code> will parse two flags:
<code>-fsanitize-coverage=&lt;value&gt;</code> and <code>-fno-sanitize-coverage=&lt;value&gt;</code> to control
what kind of coverage information for sanitizers. Try <code>clang --help | grep
coverage</code> to see more related flags.</p>
<pre><code class="language-c">int parseCoverageFeatures(const Driver &amp;D, const llvm::opt::Arg *A) {
  assert(A-&gt;getOption().matches(options::OPT_fsanitize_coverage) ||
         A-&gt;getOption().matches(options::OPT_fno_sanitize_coverage));
  int Features = 0;
  for (int i = 0, n = A-&gt;getNumValues(); i != n; ++i) {
    const char *Value = A-&gt;getValue(i);
    int F = llvm::StringSwitch&lt;int&gt;(Value)
                .Case(&quot;func&quot;, CoverageFunc)
                .Case(&quot;bb&quot;, CoverageBB)
                .Case(&quot;edge&quot;, CoverageEdge)
                .Case(&quot;indirect-calls&quot;, CoverageIndirCall)
                .Case(&quot;trace-bb&quot;, CoverageTraceBB)
                .Case(&quot;trace-cmp&quot;, CoverageTraceCmp)
                .Case(&quot;trace-div&quot;, CoverageTraceDiv)
                .Case(&quot;trace-gep&quot;, CoverageTraceGep)
                .Case(&quot;8bit-counters&quot;, Coverage8bitCounters)
                .Case(&quot;trace-pc&quot;, CoverageTracePC)
                .Case(&quot;trace-pc-guard&quot;, CoverageTracePCGuard)
                .Case(&quot;no-prune&quot;, CoverageNoPrune)
                .Case(&quot;inline-8bit-counters&quot;, CoverageInline8bitCounters)
                .Case(&quot;inline-bool-flag&quot;, CoverageInlineBoolFlag)
                .Case(&quot;pc-table&quot;, CoveragePCTable)
                .Case(&quot;stack-depth&quot;, CoverageStackDepth)
                .Default(0);
    if (F == 0)
      D.Diag(clang::diag::err_drv_unsupported_option_argument)
          &lt;&lt; A-&gt;getOption().getName() &lt;&lt; Value;
    Features |= F;
  }
  return Features;
}
</code></pre>
<p><code>parseCoverageFeatures</code> clearly show what kind of coverage we can control. In
the following are several tips to enable and disable these coverage flags.
+ <code>func</code>, <code>bb</code>, and <code>edge</code> are mutually exclusive
+ <code>trace-bb</code> is deprecated, use <code>trace-pc-guard</code> instead
+ <code>8bit-counter</code> is deprecated, use <code>trace-pc-guard</code> instead
+ if use one of <code>func</code>, <code>bb</code>, and <code>edge</code>, <code>trace-pc-guard</code> or <code>trace-pc</code> must be enabled
+ if one of <code>trace-pc</code>, <code>trace-pc-guard</code>, <code>inline-8bit-counter</code>, and <code>inline-bool-flag</code>
is enabled without any <code>func</code>, <code>bb</code>, or <code>edge</code>, then <code>edge</code> is added by default
+ <code>stack-depth</code> needs <code>func</code></p>
<p>Returning from <code>SanitizerArgs()</code>,  <code>ConstructJob</code> will invoke <code>addArgs</code> to
append flags to the command line <code>clang -o foo -fsanitize=fuzzer foo.c</code>.</p>
<pre><code class="language-txt">[#0] 0x55555a470fa2 → clang::driver::SanitizerArgs::addArgs()
[#1] 0x55555a3c6572 → clang::driver::tools::Clang::ConstructJob()
[#2] 0x55555a345a9a → clang::driver::Driver::BuildJobsForActionNoCache()
[#3] 0x55555a343f99 → clang::driver::Driver::BuildJobsForAction()
[#4] 0x55555a344bad → clang::driver::Driver::BuildJobsForActionNoCache()
[#5] 0x55555a343f99 → clang::driver::Driver::BuildJobsForAction()
[#6] 0x55555a34280e → clang::driver::Driver::BuildJobs()
[#7] 0x55555a3345c4 → clang::driver::Driver::BuildCompilation()
</code></pre>
<p><code>addArgs</code> will add corresponding flags according to the table below.</p>
<pre><code class="language-c">std::pair&lt;int, const char *&gt; CoverageFlags[] = {
    std::make_pair(CoverageFunc, &quot;-fsanitize-coverage-type=1&quot;),
    std::make_pair(CoverageBB, &quot;-fsanitize-coverage-type=2&quot;),
    std::make_pair(CoverageEdge, &quot;-fsanitize-coverage-type=3&quot;),
    std::make_pair(CoverageIndirCall, &quot;-fsanitize-coverage-indirect-calls&quot;),
    std::make_pair(CoverageTraceBB, &quot;-fsanitize-coverage-trace-bb&quot;),
    std::make_pair(CoverageTraceCmp, &quot;-fsanitize-coverage-trace-cmp&quot;),
    std::make_pair(CoverageTraceDiv, &quot;-fsanitize-coverage-trace-div&quot;),
    std::make_pair(CoverageTraceGep, &quot;-fsanitize-coverage-trace-gep&quot;),
    std::make_pair(Coverage8bitCounters, &quot;-fsanitize-coverage-8bit-counters&quot;),
    std::make_pair(CoverageTracePC, &quot;-fsanitize-coverage-trace-pc&quot;),
    std::make_pair(CoverageTracePCGuard,
                    &quot;-fsanitize-coverage-trace-pc-guard&quot;),
    std::make_pair(CoverageInline8bitCounters,
                    &quot;-fsanitize-coverage-inline-8bit-counters&quot;),
    std::make_pair(CoverageInlineBoolFlag,
                    &quot;-fsanitize-coverage-inline-bool-flag&quot;),
    std::make_pair(CoveragePCTable, &quot;-fsanitize-coverage-pc-table&quot;),
    std::make_pair(CoverageNoPrune, &quot;-fsanitize-coverage-no-prune&quot;),
    std::make_pair(CoverageStackDepth, &quot;-fsanitize-coverage-stack-depth&quot;),
    std::make_pair(CoverageTraceState, &quot;-fsanitize-coverage-trace-state&quot;)};
</code></pre>
<p>Returning from <code>Clang::contructJob</code>, <code>addSanitizerRuntimes</code> will expand linker
flags.</p>
<pre><code class="language-txt">[#0] 0x55555a3dcbe2 → clang::driver::tools::addSanitizerRuntimes()
[#1] 0x55555a40cac0 → clang::driver::tools::gnutools::Linker::ConstructJob()
[#2] 0x55555a345a9a → clang::driver::Driver::BuildJobsForActionNoCache()
[#3] 0x55555a343f99 → clang::driver::Driver::BuildJobsForAction()
[#4] 0x55555a34280e → clang::driver::Driver::BuildJobs()
[#5] 0x55555a3345c4 → clang::driver::Driver::BuildCompilation()
[#6] 0x555557ddf8f7 → main()
</code></pre>
<p>In <code>addSanitizerRuntimes</code>, <code>collectSanitizerRuntimes</code> will collect libraries for
sanitizers.
+ Use <code>-shared-libsan</code> (by default) or <code>-static-libsan</code> to collect dynamic or static libraries
+ use <code>-fsanitize-link-runtime"</code> (by default) or <code>-fno-sanitize-link-runtime</code> to switch on or off linking</p>
<p>To use ASAN, assign <code>-fsanitize=address</code>. If only <code>-fsanitize=fuzzer</code>, then
UBSAN will be enabled.</p>
<pre><code class="language-c">bool SanitizerArgs::needsUbsanRt() const {
  // All of these include ubsan.
  if (needsAsanRt() || needsMsanRt() || needsHwasanRt() || needsTsanRt() ||
      needsDfsanRt() || needsLsanRt() || needsCfiDiagRt() ||
      (needsScudoRt() &amp;&amp; !requiresMinimalRuntime()))
    return false;

  return (Sanitizers.Mask &amp; NeedsUbsanRt &amp; ~TrapSanitizers.Mask) ||
         CoverageFeatures;
}
</code></pre>
<p>Shortly, if no other sanitizers is enabled, and if any coverage is enabled,
UBSAN will be enabled.</p>
<p>After <code>collectSanitizerRuntimes</code>, <code>addSanitizerRuntimes</code> will update runtimes regarding to <code>-fsanitizer=fuzzer</code>.</p>
<pre><code class="language-c">bool SanitizerArgs::needsFuzzerInterceptors() const {
  return needsFuzzer() &amp;&amp; !needsAsanRt() &amp;&amp; !needsTsanRt() &amp;&amp; !needsMsanRt();
}

bool tools::addSanitizerRuntimes(...) {
  ...
    addSanitizerRuntime(TC, Args, CmdArgs, &quot;fuzzer&quot;, false, true);
    if (SanArgs.needsFuzzerInterceptors())
        addSanitizerRuntime(TC, Args, CmdArgs, &quot;fuzzer_interceptors&quot;, false, true);
}
</code></pre>
<p>BTW, <code>fuzz_interceptors</code> will be appended if no ASAN, TSAN, MSAN runtime is
enabled.</p>
<p>Finally, to narrow down the coverage collection, we can construct a command in
the following.</p>
<pre><code class="language-bash">clang -o foo -fsanitize=fuzzer \
    -fno-sanitize-coverage=indirect-calls,trace-cmp,stack-depth,pc-table \
    foo.c
</code></pre>
<p>In this way, only <code>edge</code> and <code>inline-8bit-counters</code> are enabled.</p>
<h2 id="flow-of-instrumentations">Flow of instrumentations</h2>
<p>The module pass <code>SanitizerCoverage</code>
(llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp) will instrument
coverage flag to each module.</p>
<p>In the first state, <code>SanitizerCoverage</code> will construct the IR of stubs to be
instrumented. A classic pattern is in the following.</p>
<pre><code class="language-c++">const char SanCovTracePCIndirName[] = &quot;__sanitizer_cov_trace_pc_indir&quot;;
SanCovTracePCIndir = M.getOrInsertFunction(SanCovTracePCIndirName, VoidTy, IntptrTy);
</code></pre>
<p>In the second state, <code>SanitizerCoverage</code> will traverse all IR code and do
instrumentation at the proper position.</p>
<pre><code class="language-c++">IRB.CreateCall(SanCovTracePCIndir, IRB.CreatePointerCast(Callee, IntptrTy));
</code></pre>
<p>The overall flow of <code>SanitizerCoverage</code> is in the following.</p>
<pre><code class="language-txt">instrumentModule
    - stage 1
    - for (auto &amp;F : M) { instrumentFunction(F); }
instrumentFunction
    - split edges if edge coverage[^1]
    - for (auto &amp;BB : F) {
        BlocksToInstrument.push_back(&amp;BB);
        for (auto &amp;Inst: BB) { /* simplified */
          if (IndirectCalls &amp;&amp; xxx) IndirCalls.push_back(&amp;Inst)
          if (TraceCmp &amp;&amp; xxx) CmpTraceTargets.push_back(&amp;Inst)
          if (TraceCmp &amp;&amp; xxx) SwitchTraceTargets.push_back(&amp;Inst)
          if (TraceDiv &amp;&amp; xxx) DivTraceTargets.push_back(BO)
          if (TraceGep &amp;&amp; xxx) GepTraceTargets.push_back(BO)
          if (TraceStackDepth &amp;&amp; xxx) IsLeafFunc = false;
        }
      }
    - stage 2
        InjectCoverage(F, BlocksToInstrument, IsLeafFunc);
        InjectCoverageForIndirectCalls(F, IndirCalls);
        InjectTraceForCmp(F, CmpTraceTargets);
        InjectTraceForSwitch(F, SwitchTraceTargets);
        InjectTraceForDiv(F, DivTraceTargets);
        InjectTraceForGep(F, GepTraceTargets);
</code></pre>
<p>The key function in stage 2 is <code>InjectCoverage</code>.</p>
<p><code>InjectCoverage</code> first create FunctionGuardArray, Function8bitCounterArray,
FunctionBoolArray, or FunctionPCsArray in <code>CreateFunctionLocalArrays</code>, then
invoke <code>InjectCoverageAtBlock</code> to handle each basic blocks.
<code>InjectCoverageAtBlock</code> will instrument <code>SanCovTracePC</code>, <code>SanCovTracePCGuard</code>,
<code>Inline8BitCounters</code>, or <code>InlineBoolFlag</code>, or update the lowest stack frame, for
each basic block.</p>
<h2 id="details-of-stubs">Details of stubs</h2>
<p>Please also refer to <a href="https://clang.llvm.org/docs/SanitizerCoverage.html">this</a>.</p>
<h3 id="__sanitizer_cov_indir_call">__sanitizer_cov_indir_call</h3>
<p>This will be in front of an indirect call. It requires at least one of
<code>trace-pc</code>, <code>trace-pc-guard</code>, <code>inline-8bit-counters</code>, and <code>inline-bool-flag</code>.
It accepts one parameter, the callee address. The address of the caller is
passed implicitly via caller PC. Importantly, if the callee is inline assembly,
the indirect call will not be instrumented. Its implementation in libFuzzer is
in the following. In the end, new information will be updated into the value
profile.</p>
<pre><code class="language-c++">#define GET_CALLER_PC() __builtin_return_address(0)

void TracePC::HandleCallerCallee(uintptr_t Caller, uintptr_t Callee) {
  const uintptr_t kBits = 12;
  const uintptr_t kMask = (1 &lt;&lt; kBits) - 1;
  uintptr_t Idx = (Caller &amp; kMask) | ((Callee &amp; kMask) &lt;&lt; kBits);
  ValueProfileMap.AddValueModPrime(Idx);
}

void __sanitizer_cov_trace_pc_indir(uintptr_t Callee) {
  uintptr_t PC = reinterpret_cast&lt;uintptr_t&gt;(GET_CALLER_PC());
  fuzzer::TPC.HandleCallerCallee(PC, Callee);
}
</code></pre>
<h3 id="__sanitizer_cov_trace_const_cmp1248">__sanitizer_cov_trace_[const_]cmp[1|2|4|8]</h3>
<p>These will be in front of a cmp instruction with const operand or not. They
accept both operands to be compared. The address of the caller is passed
implicitly via caller PC. One of its implementation in libFuzzer is in the
following. In the end, new information will be updated into the value profile.</p>
<pre><code class="language-c++">#define GET_CALLER_PC() __builtin_return_address(0)

template &lt;class T&gt;
void TracePC::HandleCmp(uintptr_t PC, T Arg1, T Arg2) {
  uint64_t ArgXor = Arg1 ^ Arg2;
  if (sizeof(T) == 4)
      TORC4.Insert(ArgXor, Arg1, Arg2);
  else if (sizeof(T) == 8)
      TORC8.Insert(ArgXor, Arg1, Arg2);
  uint64_t HammingDistance = Popcountll(ArgXor);  // [0,64]
  uint64_t AbsoluteDistance = (Arg1 == Arg2 ? 0 : Clzll(Arg1 - Arg2) + 1);
  ValueProfileMap.AddValue(PC * 128 + HammingDistance);
  ValueProfileMap.AddValue(PC * 128 + 64 + AbsoluteDistance);
}

void __sanitizer_cov_trace_cmp1(uint8_t Arg1, uint8_t Arg2) {
  uintptr_t PC = reinterpret_cast&lt;uintptr_t&gt;(GET_CALLER_PC());
  fuzzer::TPC.HandleCmp(PC, Arg1, Arg2);
}
</code></pre>
<p>Similarly stubs are <code>__sanitizer_cov_trace_switch</code>,
<code>__sanitizer_cov_trace_div[4|8]</code>, and <code>__sanitizer_cov_trace_gep</code>.  They all
invoke HandleCmp at the end to update new information into the value profile.</p>
<h3 id="__sanitizer_cov_trace_pc">__sanitizer_cov_trace_pc</h3>
<p>This will be at the entry of each basic block. The address of the caller is
passed implicitly via caller PC. This is deprecated.</p>
<h3 id="__sanitizer_cov_trace_pc_guard_init">__sanitizer_cov_trace_pc_guard[_init]</h3>
<p><code>__sanitizer_cov_trace_pc_guard</code> will be at the entry of each basic block after
<code>__sanitier_cov_trace_pc</code>. The address of the caller is passed implicitly via
caller PC. They are deprecated.</p>
<p>Each function would have a function guard array <code>int32_t FunctionGuardArray[]</code>
whose size is the number of the basic blocks. This array is associated with
<code>sancov_guards</code> section. <code>__sanitizer_cov_trace_pc_guard</code> accepts
<code>FunctionGuardArray[IdxofBB]</code> as the guard.</p>
<p>If any function guard array, SanCov will create a section named
<code>sancov.module_ctor_trace_pc_guard</code> to invoke
<code>__sanitizer_cov_trace_pc_guard_init</code> to initialize <code>sancov_guards</code> for each
module.</p>
<p>[NOT SURE] In the end, after linking, there will be one <code>sancov_guards</code> and one
<code>sancov.module_ctor_trace_pc_guard</code>.</p>
<h3 id="__sanitizer_cov_8bipctableentryidxpc_guard">__sanitizer_cov_8biPCTableEntryIdxpc_guard`.</h3>
<p>Each function would have a function 8bit counter array <code>int8_t
Function8BitArray[]</code> whose size is the number of the basic blocks. This array is
associated with <code>sancov_cntrs</code> section. If a basic block is visited, then the
corresponding byte in the array will be increased by 1.</p>
<p>If any function 8bit array, SanCov will create a section named
<code>sancov.module_ctor_8bit_counters</code> to invoke
<code>__sanitizer_cov_8bit_counters_init</code> to initialize <code>sancov_cntrs</code> for each
module.</p>
<p>[NOT SURE] In the end, after linking, there will be one <code>sancov_cntrs</code> and one
<code>sancov.module_ctor_8bit_counters</code>.</p>
<p><code>__sanitizer_cov_8bit_counters_init</code> is defined in the following. It shows the
counter information flows to <code>Modules</code> in the libFuzzer. In short, <code>Modules</code>
records the start and the stop address of the <code>sancov_cntrs</code> divided by page
(<code>Region</code>).</p>
<pre><code class="language-c++">void TracePC::HandleInline8bitCountersInit(uint8_t *Start, uint8_t *Stop) {
  if (Start == Stop) return;
  if (NumModules &amp;&amp;
      Modules[NumModules - 1].Start() == Start)
    return;
  assert(NumModules &lt;
         sizeof(Modules) / sizeof(Modules[0]));
  auto &amp;M = Modules[NumModules++];
  uint8_t *AlignedStart = RoundUpByPage(Start);
  uint8_t *AlignedStop  = RoundDownByPage(Stop);
  size_t NumFullPages = AlignedStop &gt; AlignedStart ?
                        (AlignedStop - AlignedStart) / PageSize() : 0;
  bool NeedFirst = Start &lt; AlignedStart || !NumFullPages;
  bool NeedLast  = Stop &gt; AlignedStop &amp;&amp; AlignedStop &gt;= AlignedStart;
  M.NumRegions = NumFullPages + NeedFirst + NeedLast;;
  assert(M.NumRegions &gt; 0);
  M.Regions = new Module::Region[M.NumRegions];
  assert(M.Regions);
  size_t R = 0;
  if (NeedFirst)
    M.Regions[R++] = {Start, std::min(Stop, AlignedStart), true, false};
  for (uint8_t *P = AlignedStart; P &lt; AlignedStop; P += PageSize())
    M.Regions[R++] = {P, P + PageSize(), true, true};
  if (NeedLast)
    M.Regions[R++] = {AlignedStop, Stop, true, false};
  assert(R == M.NumRegions);
  assert(M.Size() == (size_t)(Stop - Start));
  assert(M.Stop() == Stop);
  assert(M.Start() == Start);
  NumInline8bitCounters += M.Size();
}

void __sanitizer_cov_8bit_counters_init(uint8_t *Start, uint8_t *Stop) {
  fuzzer::TPC.HandleInline8bitCountersInit(Start, Stop);
}
</code></pre>
<h3 id="__sanitizer_cov_bool_flag_init">__sanitizer_cov_bool_flag_init</h3>
<p>The inline bool flag will be at the entry of each basic block after the inline
8bit counters.</p>
<p>Each function would have a function 1 bit array <code>int1_t FunctionBoolArray[]</code>
whose size is the number of the basic blocks. This array is associated with
<code>sancov_bools</code> section. If a basic block is visited, then the corresponding bit
in the array will be true.</p>
<p>If any function bool array, SanCov will create a section named
<code>sancov.module_ctor_bool_flag</code> to invoke <code>__sanitizer_cov_bool_flag_init</code> to
initilize <code>sancov_bools</code> for each module.</p>
<p>[NOT SURE] In the end, after linking, there will be one <code>sancov_bools</code> and one
<code>sancov.module_ctor_bool_flag</code>.</p>
<p><code>__sanitizer_cov_bool_flag_init</code> is not defined in the libFuzzer.</p>
<h3 id="__sanitizer_cov_pcs_init">__sanitizer_cov_pcs_init</h3>
<p>For each function, SanCov creates a PC array associated with <code>sancov_pcs</code> to
store <code>{PC, PCFlags}</code> pairs. PC is the address of the corresponding basic block,
and a PCFlags describes the basic block is the function entry block (1) or not
(0).</p>
<p>If one of the <code>trace-pc-guard</code>, <code>inline-8bit-counters</code>, and <code>inline-bool-flag</code>,
and any function PC array, SanCov will invoke <code>__sanitizer_cov_pcs_init</code> to
initilize <code>sancov_pcs</code> for each module in one of the section: <code>sancov.xxx</code>.</p>
<p>[NOT SURE] In the end, after linking, there will be one <code>sancov_pcs</code>.</p>
<p><code>__sanitizer_cov_pcs_init</code> is defined in the following. In short, the
information flows to <code>ModulePCTable</code> in libFuzzer.</p>
<pre><code class="language-c++">void TracePC::HandlePCsInit(const uintptr_t *Start, const uintptr_t *Stop) {
  const PCTableEntry *B = reinterpret_cast&lt;const PCTableEntry *&gt;(Start);
  const PCTableEntry *E = reinterpret_cast&lt;const PCTableEntry *&gt;(Stop);
  if (NumPCTables &amp;&amp; ModulePCTable[NumPCTables - 1].Start == B) return;
  assert(NumPCTables &lt; sizeof(ModulePCTable) / sizeof(ModulePCTable[0]));
  ModulePCTable[NumPCTables++] = {B, E};
  NumPCsInPCTables += E - B;
}

void __sanitizer_cov_pcs_init(const uintptr_t *pcs_beg,
                              const uintptr_t *pcs_end) {
  fuzzer::TPC.HandlePCsInit(pcs_beg, pcs_end);
}
</code></pre>
<h3 id="a-brief-list-of-flag-stubs-and-information-sink-in-libfuzzer">A brief list of (flag, stubs, and information sink in libFuzzer)</h3>
<table>
<thead>
<tr>
<th align="center">Flag</th>
<th align="center">Stubs</th>
<th align="center">Information Sink</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">trace-pc,indirect-calls</td>
<td align="center">__sanitizer_cov_trace_pc_indirect</td>
<td align="center">ValueProfileMap</td>
</tr>
<tr>
<td align="center">trace-pc-guard,indirect-calls</td>
<td align="center">__sanitizer_cov_trace_pc_indirect</td>
<td align="center">ValueProfileMap</td>
</tr>
<tr>
<td align="center">inline-8bit-counters,indirect-calls</td>
<td align="center">__sanitizer_cov_trace_pc_indirect</td>
<td align="center">ValueProfileMap</td>
</tr>
<tr>
<td align="center">inline-bool-flag,indirect-calls</td>
<td align="center">__sanitizer_cov_trace_pc_indirect</td>
<td align="center">ValueProfileMap</td>
</tr>
<tr>
<td align="center">trace-cmp</td>
<td align="center">__sanitizer_cov_trace_[const_]cmp[1|2|4|8]</td>
<td align="center">ValuleProfileMap</td>
</tr>
<tr>
<td align="center">trace-switch</td>
<td align="center">__sanitizer_cov_trace_switch</td>
<td align="center">ValuleProfileMap</td>
</tr>
<tr>
<td align="center">trace-div</td>
<td align="center">__sanitizer_cov_trace_div[4|8]</td>
<td align="center">ValuleProfileMap</td>
</tr>
<tr>
<td align="center">trace-gep</td>
<td align="center">__sanitizer_cov_trace_gep</td>
<td align="center">ValuleProfileMap</td>
</tr>
<tr>
<td align="center">trace-pc</td>
<td align="center">__sanitizer_cov_trace_pc</td>
<td align="center">deprecated</td>
</tr>
<tr>
<td align="center">trace-pc-guard</td>
<td align="center">__sanitizer_cov_trace_pc_guard[_init]</td>
<td align="center">deprecated</td>
</tr>
<tr>
<td align="center">inline-8bit-counters</td>
<td align="center">__sanitizer_cov_8bit_counters_init</td>
<td align="center">Modules</td>
</tr>
<tr>
<td align="center">inline-bool-flag</td>
<td align="center">__sanitizer_cov_bool_flag_init</td>
<td align="center">not supported</td>
</tr>
<tr>
<td align="center">trace-pc-guard,pc-table</td>
<td align="center">__sanitizer_cov_pcs_init</td>
<td align="center">ModulePCTable</td>
</tr>
<tr>
<td align="center">inline-8bit-guard,pc-table</td>
<td align="center">__sanitizer_cov_pcs_init</td>
<td align="center">ModulePCTable</td>
</tr>
<tr>
<td align="center">inline-bool-flag,pc-table</td>
<td align="center">__sanitizer_cov_pcs_init</td>
<td align="center">ModulePCTable</td>
</tr>
</tbody>
</table>
<h2 id="details-of-coverage-collection-algorithm-and-implementation">Details of coverage collection algorithm and implementation</h2>
<p>Recalling that several stubs are instrumented to the target program. The implementation of these stubs are implemented in libFuzzer by default or can be replaced by developers. Most of them are defined in compiler-rt/lib/fuzzer/FuzzerTracePC.cpp. After testing an input, these stubs will update corresponding information. LibFuzzer will then calculate the coverage with the information. A detailed flow is in the following.</p>
<pre><code class="language-c++">ExecuteCallback
    - TPC.ResetMaps();
    - CB(DataCopy, Size);
TPC.CollectFeatures();
if (NumNewFeatures || ForceAddToCorpus) {
  TPC.UpdateObservedPCs();
}
</code></pre>
<h3 id="resetmaps">ResetMaps</h3>
<pre><code class="language-c++">template &lt;class Callback&gt;
void IterateCounterRegions(Callback CB) {
  for (size_t m = 0; m &lt; NumModules; m++)
    for (size_t r = 0; r &lt; Modules[m].NumRegions; r++)
      CB(Modules[m].Regions[r]);
}

void TracePC::ClearInlineCounters() {
  IterateCounterRegions([](const Module::Region &amp;R){
    if (R.Enabled)
      memset(R.Start, 0, R.Stop - R.Start);
  });
}

void ResetMaps() {
  ValueProfileMap.Reset();
  ClearExtraCounters();
  ClearInlineCounters();
}
</code></pre>
<p>TPC.ResetMaps reset 1) ValueProfileMap, a bit map for data flow value, 2)
ExtraCounters, 3) InlineCouters, the area for <code>inline-8bit-counters</code>.</p>
<h3 id="collectfeatures">CollectFeatures</h3>
<pre><code class="language-c++">size_t NumUpdatesBefore = Corpus.NumFeatureUpdates();
TPC.CollectFeatures([&amp;](size_t Feature) {
  if (Corpus.AddFeature(Feature, Size, Options.Shrink))
    // *
});
</code></pre>
<p><code>TPC.CollectFeatures</code> accepts a HandleFeature function pointer.  In the
HandleFeature, it accepts a Feature that is calculated from all the coverage
information (Information Sink), and then adds the feature to the corpus.</p>
<p>In <code>TPC.CollectFeatures</code>, it maps the information sinks to features like below.</p>
<pre><code class="language-txt">// Modules (Inlint8BitCounters)
FirstFeature=0
                         feature
      0    8    w/o counters  w/ counters
      +----+
BB00  +d'02+    +0            +(0*8 + log(2))
      +----+
BB01  +d'80+    +1            +(1*8 + log(80))
      +----+
FirstFeature += NumOfBits(Modules)
// ExtracCounters
      0    8    w/o counters  w/ counters
      +----+
CNT0  +d'02+    +0            +(0*8 + log(2))
      +----+
CNT1  +d'80+    +1            +(1*8 + log(80))
      +----+
FirstFeature += NumOfBits(ExtraCounters)
// ValueProfileMap
      0    8
      +----+
VPM0  +d'02+    +6 (b'00000010)
      +----+
VPM8  +d'82+    +8/+14 (b'10000010)
      +----+
FirstFeature += NumOfBits(ValueProfileMap)
// StackDepth
                + StackDepthStepFunction(MaxStackOffset / 8)
</code></pre>
<p>In general, we map coverage information to a linear feature from zero. For the
<code>Modules</code>, libFuzzer checks each byte that records how many times a basic block is
visited. If without counters, the feature is the start feature plus the index of
the bytes. For BB01, if the index is 1, then the feature is 1. If with counter,
it will take d'80 into consideration. The feature is 0 plus log(80). The
logarithmic function guarantees the feature will not overflow 8 bits. In the
end, the start of the new features will be updated by adding the bit number of
modules. <code>ExtraCounters</code> works similarly. For the ValueProfileMap, each non-zero
bit is a new feature. For the stack depth, it leverages a hash function
StackDepthStepFunction.</p>
<h3 id="updateobservedpcs">UpdateObservedPCs</h3>
<p>If any new features, libFuzzer will update observed PCs.</p>
<pre><code class="language-c++">for (size_t i = 0; i &lt; NumModules; i++) {
  auto &amp;M = Modules[i];
  for (size_t r = 0; r &lt; M.NumRegions; r++) {
    auto &amp;R = M.Regions[r];
    if (!R.Enabled) continue;
    for (uint8_t *P = R.Start; P &lt; R.Stop; P++)
      if (*P) // if this basic block is visited
        // then get the PC of the visited the basic block
        // then invoke Observe
        Observe(&amp;ModulePCTable[i].Start[M.Idx(P)]);
  }
}
</code></pre>
<p>First, if a basic block is visited, libFuzzer will get the PC of the visited the
basic in the PCTable, and invoke <code>Observe</code>.</p>
<pre><code class="language-c++">Vector&lt;uintptr_t&gt; CoveredFuncs;
auto ObservePC = [&amp;](const PCTableEntry *TE) {
  if (ObservedPCs.insert(TE).second &amp;&amp; DoPrintNewPCs) {
    PrintPC(&quot;\tNEW_PC: %p %F %L&quot;, &quot;\tNEW_PC: %p&quot;,
            GetNextInstructionPc(TE-&gt;PC));
    Printf(&quot;\n&quot;);
  }
};

auto Observe = [&amp;](const PCTableEntry *TE) {
  if (PcIsFuncEntry(TE))
    if (++ObservedFuncs[TE-&gt;PC] == 1 &amp;&amp; NumPrintNewFuncs)
      CoveredFuncs.push_back(TE-&gt;PC);
  ObservePC(TE);
};
</code></pre>
<p>If the basic block is the entry, then update <code>ObservedFunc</code>. Otherwise, invoke
<code>ObservePC</code> to update <code>ObservedPCs</code>.</p>
<h2 id="libfuzzer-intercepts">libFuzzer intercepts</h2>
<p>LibFuzzer will intercepts <code>memcmp</code>, <code>strncmp</code>, <code>strcmp</code>, <code>strncasecmp</code>,
<code>strcasecmp</code>, <code>strstr</code>, <code>strcasestr</code>, and <code>memmem</code> functions if no ASAN, TSAN,
MSAN runtime is enabled. It is not easy to disable this behavior.</p>
<p>A typical flow for each above function is in the following.</p>
<pre><code class="language-c++">    RunningUserCallback = true;
    int Res = CB(DataCopy, Size);
    RunningUserCallback = false;

int memcmp(const void *s1, const void *s2, size_t n) {
  if (!FuzzerInited)
    return internal_memcmp(s1, s2, n);
  int result = REAL(memcmp)(s1, s2, n);
  __sanitizer_weak_hook_memcmp(GET_CALLER_PC(), s1, s2, n, result);
  return result;
}

void __sanitizer_weak_hook_memcmp(void *caller_pc, const void *s1,
                                  const void *s2, size_t n, int result) {
  if (!fuzzer::RunningUserCallback) return;
  if (result == 0) return;  // No reason to mutate.
  if (n &lt;= 1) return;  // Not interesting.
  fuzzer::TPC.AddValueForMemcmp(caller_pc, s1, s2, n, /*StopAtZero*/false);
}
</code></pre>
<p>Here is a summary of where the collected information will flow.</p>
<table>
<thead>
<tr>
<th align="center">Function</th>
<th align="center"></th>
<th align="center">Information Sink</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">memcmp</td>
<td align="center">AddValueForMemcmp</td>
<td align="center">ValueProfileMap</td>
</tr>
<tr>
<td align="center">strnmp</td>
<td align="center">AddValueForMemcmp</td>
<td align="center">ValueProfileMap</td>
</tr>
<tr>
<td align="center">strcmp</td>
<td align="center">AddValueForMemcmp</td>
<td align="center">ValueProfileMap</td>
</tr>
<tr>
<td align="center">strncasecmp</td>
<td align="center">AddValueForMemcmp</td>
<td align="center">ValueProfileMap</td>
</tr>
<tr>
<td align="center">strcasecmp</td>
<td align="center"></td>
<td align="center">AddValueForMemcmp</td>
</tr>
<tr>
<td align="center">strstr</td>
<td align="center"></td>
<td align="center">MMT(Mutation Only)</td>
</tr>
<tr>
<td align="center">strcasestr</td>
<td align="center"></td>
<td align="center">MMT(Mutation Only)</td>
</tr>
<tr>
<td align="center">memmem</td>
<td align="center"></td>
<td align="center">MMT(Mutation Only)</td>
</tr>
</tbody>
</table>
<p>To disable them, we could 1) use <code>-use_value_profile=0</code> when fuzzing to avoid
update coverage information from ValueProfileMap, 2) comment these
<code>__sanitizer_weak_hook_xxx</code> to reduce the overhead. Luckily,
<code>-use_value_profile=0</code> is the default option of libFuzzer.</p>
<h2 id="conclusion">Conclusion</h2>
<ol>
<li>
<p>For the basic block coverage, SanCov maintains an array that records how many
times a basic block is visited, and the libFuzzer will collect that information
and calculate features.</p>
</li>
<li>
<p>To disable fancy features, just do as below.</p>
</li>
</ol>
<pre><code class="language-bash">clang -o foo -fsanitize=fuzzer \
    -fsanitize-coverage=bb \
    -fno-sanitize-coverage=indirect-calls,trace-cmp,stack-depth,pc-table \
    foo.c
</code></pre>

<ul class="metadata page-metadata" data-bi-name="page info" lang="en-us" dir="ltr">
  <li class="last-updated-holder displayDate loading">
    <span class="last-updated-text">Last updated:</span>
    <time role="presentation" datetime="2018-10-25T00:00:00.000Z" data-article-date-source="ms.date"></time>
  </li>
<!--
  <li class="readingTime">
    2 minutes to read
  </li>
-->
  <li class="contributors-holder">
    <span class="contributors-text">Contributors</span>
    <ul class="contributors" data-bi-name="contributors"></ul>
  </li>
</ul>
</div>
        <div class="col-md-3"><div class="navbar-light navbar-expand-md hidden-print sticky-top sticky-offset" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    <div id="toc-collapse" class="navbar-collapse collapse card">
        <ul class="nav flex-column bs-sidenav">
            <li class="nav-item main"><a class="nav-link" href="#coverage-control-in-libfuzzer">Coverage Control in libFuzzer</a></li>
                <li class="nav-item">
                    <a href="#how-to-use-libfuzzer" class="nav-link">How to use libFuzzer?</a>
                </li>
                <li class="nav-item">
                    <a href="#how-to-compiler-llvm-project" class="nav-link">How to compiler LLVM project?</a>
                </li>
                <li class="nav-item">
                    <a href="#details-beneath-fsanitizefuzzer" class="nav-link">Details beneath -fsanitize=fuzzer</a>
                </li>
                <li class="nav-item">
                    <a href="#flow-of-instrumentations" class="nav-link">Flow of instrumentations</a>
                </li>
                <li class="nav-item">
                    <a href="#details-of-stubs" class="nav-link">Details of stubs</a>
                </li>
                <li class="nav-item">
                    <a href="#details-of-coverage-collection-algorithm-and-implementation" class="nav-link">Details of coverage collection algorithm and implementation</a>
                </li>
                <li class="nav-item">
                    <a href="#libfuzzer-intercepts" class="nav-link">libFuzzer intercepts</a>
                </li>
                <li class="nav-item">
                    <a href="#conclusion" class="nav-link">Conclusion</a>
                </li>
        </ul>
    </div>
</div></div>
      </div>
      </div>

      <footer class="col-md-12">
	<hr>
	<div class="container">
	</div>
      </footer>
      <script>
	var base_url = "../..",
            shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
      </script>
      <script src="../../js/base.js" defer></script>
      <script src="../../search/main.js" defer></script>

      <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <p class="h4 modal-title">Keyboard Shortcuts</p>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
