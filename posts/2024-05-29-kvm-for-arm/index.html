<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="generator" content="mkdocs-1.5.3, mkdocs-terminal-4.6.0">
     
     
    
    <link rel="canonical" href="https://github.com/cyruscyliu/cyruscyliu.github.io/posts/2024-05-29-kvm-for-arm/"><link rel="icon" type="image/png" sizes="192x192" href="../../img/android-chrome-192x192.png" />
<link rel="icon" type="image/png" sizes="512x512" href="../../img/android-chrome-512x512.png" />
<link rel="apple-touch-icon" sizes="180x180" href="../../img/apple-touch-icon.png" />
<link rel="shortcut icon" type="image/png" sizes="48x48" href="../../img/favicon.ico" />
<link rel="icon" type="image/png" sizes="16x16" href="../../img/favicon-16x16.png" />
<link rel="icon" type="image/png" sizes="32x32" href="../../img/favicon-32x32.png" />


    
 
<title>KVM/ARM - Qiang Liu's Homepage</title>


<link href="../../css/fontawesome/css/fontawesome.min.css" rel="stylesheet">
<link href="../../css/fontawesome/css/solid.min.css" rel="stylesheet">
<link href="../../css/normalize.css" rel="stylesheet">
<link href="../../css/terminal.css" rel="stylesheet">
<link href="../../css/theme.css" rel="stylesheet">
<link href="../../css/theme.tile_grid.css" rel="stylesheet">
<link href="../../css/theme.footer.css" rel="stylesheet">
<!-- pink color palette -->
<link href="../../css/palettes/pink.css" rel="stylesheet">

<!-- page layout -->
<style>
/* initially set page layout to a one column grid */
.terminal-mkdocs-main-grid {
    display: grid;
    grid-column-gap: 1.4em;
    grid-template-columns: auto;
    grid-template-rows: auto;
}

/*  
*   when side navigation is not hidden, use a two column grid.  
*   if the screen is too narrow, fall back to the initial one column grid layout.
*   in this case the main content will be placed under the navigation panel. 
*/
@media only screen and (min-width: 70em) {
    .terminal-mkdocs-main-grid {
        grid-template-columns: 4fr 9fr;
    }
}</style>



     
    
    

    
    <!-- search css support -->
<link href="../../css/search/bootstrap-modal.css" rel="stylesheet">
<!-- search scripts -->
<script>
    var base_url = "../..",
    shortcuts = "{}";
</script>
<script src="../../js/jquery/jquery-1.10.1.min.js" defer></script>
<script src="../../js/bootstrap/bootstrap.min.js" defer></script>
<script src="../../js/mkdocs/base.js" defer></script>
    
    
    
    
    <script src="../../search/main.js"></script>
    

    
</head>

<body class="terminal"><div class="container">
    <div class="terminal-nav">
        <header class="terminal-logo">
            <div id="mkdocs-terminal-site-name" class="logo terminal-prompt"><a href="https://github.com/cyruscyliu/cyruscyliu.github.io/" class="no-style">Qiang Liu's Homepage</a></div>
        </header>
        
        <nav class="terminal-menu">
            
            <ul vocab="https://schema.org/" typeof="BreadcrumbList">
                
                
                <li property="itemListElement" typeof="ListItem">
                    <a href="../.." class="menu-item " property="item" typeof="WebPage">
                        <span property="name">Home</span>
                    </a>
                    <meta property="position" content="0">
                </li>
                
                
                <li property="itemListElement" typeof="ListItem">
                    <a href="../" class="menu-item " property="item" typeof="WebPage">
                        <span property="name">Posts</span>
                    </a>
                    <meta property="position" content="1">
                </li>
                
                
                <li property="itemListElement" typeof="ListItem">
                    <a href="../../projects/" class="menu-item " property="item" typeof="WebPage">
                        <span property="name">Projects</span>
                    </a>
                    <meta property="position" content="2">
                </li>
                
                    
                    


<li property="itemListElement" typeof="ListItem">
    <a href="#" class="menu-item" data-toggle="modal" data-target="#mkdocs_search_modal" property="item" typeof="SearchAction">
        <i aria-hidden="true" class="fa fa-search"></i> <span property="name">Search</span>
    </a>
    <meta property="position" content="3">
</li>
                    
            </ul>
            
        </nav>
    </div>
</div>
        
    <div class="container">
        <div class="terminal-mkdocs-main-grid"><aside id="terminal-mkdocs-side-panel"><nav>
  
    <ul class="terminal-mkdocs-side-nav-items">
        
          



<li class="terminal-mkdocs-side-nav-li">
    
    
    
        
        
            <a class="

    terminal-mkdocs-side-nav-item" href="../..">Home</a>
        
    
    
    
  </li>
        
          



<li class="terminal-mkdocs-side-nav-li">
    
    
    
        
        
            <a class="

    terminal-mkdocs-side-nav-item" href="../">Posts</a>
        
    
    
    
  </li>
        
          



<li class="terminal-mkdocs-side-nav-li">
    
    
    
        
        
            <a class="

    terminal-mkdocs-side-nav-item" href="../../projects/">Projects</a>
        
    
    
    
  </li>
        
    </ul>
  
</nav><hr>
<nav>
    <ul>
        <li><a href="#kvmarm">KVM/ARM</a></li>
        
    </ul>
</nav>
</aside>
            <main id="terminal-mkdocs-main-content">
    
    
    
    
    

<section id="mkdocs-terminal-content">
    <h1 id="kvmarm"><a href="https://dl.acm.org/doi/pdf/10.1145/2644865.2541946">KVM/ARM</a><a class="headerlink" href="#kvmarm" title="Do what you think is right">#</a></h1>
<ul>
<li>Why KVM for ARM? Easy to have a hypervisor enabled for every SoC.</li>
<li>Security monitor cannot support trap-and-emulate. Hypervisor mode was
then introduced as a trap-and-emulate mechanism to support virtualization in
the non-secure world<ul>
<li>To run VMs, the hypervisor must at least partially reside in Hyp mode.</li>
<li>From kernel mode: the hypervisor can configure the hardware to trap
from kernel mode into hypervisor mode on various sensitive instructions and
hardware interrupts.</li>
<li>From user mode: can trap into kernel mode or hyp mode directly. The ARM
architecture allows each trap to be configured to trap directly into a VM’s
kernel mode instead of going through Hyp mode. For example, traps caused by
system calls or page faults from user mode can be configured to trap to a
VM’s kernel mode directly so that they are handled by the guest OS without
intervention of the hypervisor.  This avoids going to Hyp mode on each
system call or page fault, reducing virtualization overhead. Additionally,
all traps into Hyp mode can be disabled and a single non-virtualized kernel
can run in kernel mode and have complete control of the system.</li>
<li>Has less control registers to use and share no page tables with host user
space programs  (but share page tables with the host kernel)</li>
</ul>
</li>
<li>Memory virtualization<ul>
<li>Stage-2 page tables, which translate from Intermediate Physical
Addresses (IPAs), also known as guest physical addresses, to physical
addresses (PAs), also known as host physical addresses.  Stage-2
translation can be completely disabled and enabled from Hyp mode.
Stage-2 page tables use ARM’s new LPAE page table format, with subtle
differences from the page tables used by kernel mode.</li>
</ul>
</li>
<li>Comparison to x86<ul>
<li>Hyp mode, which is a separate and strictly more privileged CPU mode
than previous user and kernel modes. In contrast, Intel has root and
non-root mode, which are orthogonal to the CPU protection modes. A
crucial difference between the two hardware designs is that Intel’s root
mode supports the same full range of user and kernel mode functionality
as its non-root mode, whereas ARM’s Hyp mode is a strictly different CPU
mode with its own set of features. A hypervisor using ARM’s Hyp mode
has an arguably simpler set of features to use than the more complex
options available with Intel’s root mode.</li>
<li>No VMCS that is automatically saved and restored when switching to and
from root mode. In contrast, any state that needs to be saved and
restored must be done explicitly in software, which is flexible and
potentially faster if no additional state to save.</li>
<li>ARM and Intel are quite similar in their support for virtualizing
physical memory.</li>
</ul>
</li>
<li>(split-mode virtualization) the lowvisor and the highvisor<ul>
<li>Lowvisor<ul>
<li>(Setup) First, the lowvisor sets up the correct execution context by
appropriate configuration of the hardware, and enforces protection
and isolation between different execution contexts.</li>
<li>(World Switch) Second, the lowvisor switches from a VM execution
context to the host execution context and vice-versa. The host
execution context is used to run the hypervisor and the host Linux
kernel.</li>
<li>(Limited trap handlers) Third, the lowvisor provides a
virtualization trap handler, which handles interrupts and exceptions
that must trap to the hypervisor.</li>
</ul>
</li>
<li>Highvisor implements other functionalitys like handling Stage-2 page
faults from the VM and performing instruction emulation</li>
<li>(Double-traps) A trap to the highvisor while running the VM will first
trap to the lowvisor running in Hyp mode (from user/kernel). The lowvisor
will then cause another trap to run the highvisor. Similarly, going from the
highvisor to a VM requires trapping from kernel mode to Hyp mode, and then
switching to the VM (to user/kernel). Hyp mode is not bypassed.</li>
<li>(Identy mapping) 1) the Hyp mode cannot reuse kernel's paga table because
Hyp mode uses a different page table format, 2) the highvisor explicitly
manages the Hyp mode page tables to map any code executed in Hyp mode and
any data structures shared between the highvisor and the lowvisor to the
same virtual addresses in Hyp mode and in kernel mode.</li>
</ul>
</li>
<li>CPU virtualization<ul>
<li>Not trapping<ul>
<li>Set of Stage-1 page table base register
in most guest OSes.</li>
</ul>
</li>
<li>Hyp Mode -&gt; VM World<ul>
<li>(1) store all host GP registers on the Hyp stack</li>
<li>(2) configure the VGIC for the VM</li>
<li>(3) configure the timers for the VM</li>
<li>(4) save all host-specific configuration registers onto the Hyp stack</li>
<li>(5) load the VM’s configuration registers onto the hardware, which can be done without affecting current execution, because Hyp mode uses its own configuration registers, separate from the host state</li>
<li>(6) configure Hyp mode to trap floating-point operations for lazy
context switching, trap interrupts, trap CPU halt instructions
(WFI/WFE), trap SMC instructions, trap specific configuration register
accesses, and trap debug register accesses</li>
<li>(7) write VM-specific IDs into shadow ID registers</li>
<li>(8) set the Stage-2 page table base register (VTTBR) and enable
Stage-2 address translation</li>
<li>(9) restore all guest GP registers</li>
<li>(10) trap into either user or kernel mode</li>
</ul>
</li>
<li>VM World -&gt; Hyp Mode -(123456789)-&gt; Kernel Mode<ul>
<li>(0) trap to Hyp Mode due to a Stage-2 page fault, or a hardware interrupt</li>
<li>(1) store all VM GP registers</li>
<li>(2) disable Stage-2 translation</li>
<li>(3) configure Hyp mode to not trap any register access or instructions</li>
<li>(4) save all VM-specific configuration registers</li>
<li>(5) load the host’s configuration registers onto the hardware</li>
<li>(6) configure the timers for the host</li>
<li>(7) save VM-specific VGIC state</li>
<li>(8) restore all host GP registers,</li>
<li>(9) trap into kernel mode</li>
</ul>
</li>
</ul>
</li>
<li>Memory virtualization<ul>
<li>(stage-2 translation) stage-2 translation can only be configured in
hypervisor mode, and accesses not allowed will cause stage-2 page faults
which trap to the hypervisor (although both the highvisor and VMs share the
same CPU modes). Stage-2 translation is disabled in the non-VM world (when
running in the highvisor and lowviser), and is enabled when in the VM world.</li>
<li>(stage-2 page table) KVM/ARM handles Stage-2 page faults by considering
the IPA of the fault, and if that address belongs to normal memory in the VM
memory map, KVM/ARM allocates a page for the VM by simply calling an
existing kernel function, such as get_user_pages, and maps the allocated
page to the VM in the Stage-2 page tables.</li>
</ul>
</li>
<li>I/O virtualization<ul>
<li>(virtual devices) QEMU and Virtio virtual devices in host userspace</li>
<li>(interfaces) load/restore to MMIO device regions, no in/out</li>
<li>(enforcement) Except the passthroughed devices, KVM/ARM uses stage-2
translations to ensure that physical devices cannot be accessed directly
from VMs. Any access outside of RAM regions allocated for the VM will trap
to the hypervisor, which can route the access to a specific emulated device
in QEMU based on the fault address.</li>
</ul>
</li>
<li>
<p>Key ideas of nested virtualization</p>
<ul>
<li>Guest Hypervisor runs in vEL2 that is in EL1<ul>
<li>ARMv8.3 supports to trap EL2 operations/eret to EL2 from vEL2</li>
</ul>
</li>
<li>Virtual exceptions are enforced by<ul>
<li>trapping to Host hypervisor (EL2) first and then farwarding the
exception to Guest Hypervisor</li>
</ul>
</li>
<li>The virtual second-stage page tables are software-implemented shadow pages</li>
<li>Exit Multiplication Problem: Guest Hypervisor has to access EL1 registers
and EL2 registers that all traps -&gt; <a href="https://dl.acm.org/doi/pdf/10.1145/3132747.3132754">NEVE</a><ul>
<li>access EL1 registers -&gt; access memory: similar to VMCS</li>
<li>access EL2 registers -&gt; redirect to EL1 registers</li>
<li>5 times faster</li>
</ul>
</li>
<li>Good images: https://developer.arm.com/documentation/102142/0100/Nested-virtualization</li>
</ul>
</li>
<li>
<p>It seems the split-mode lowvisor/highvisor thing has been deprecated. Now,
Linux kernel supports nVHE/hVHE/VHE.</p>
<ul>
<li>
<p>nVHE and VHE: KVM/arm64 supports different execution modes depending on
the availability of certain CPU features, namely, the Virtualization Host
Extensions (VHE) (ARMv8.1 and later). In one of those modes, commonly known
as the non-VHE mode, the hypervisor code is split out of the kernel image
during boot and installed at EL2, whereas the kernel itself runs at EL1.
Although part of the Linux codebase, the EL2 component of KVM is a small
component in charge of the switch between multiple EL1s.  The hypervisor
component is compiled with Linux, but resides in a separate, dedicated
memory section of the vmlinux image.</p>
</li>
<li>
<p>And for nVHE, there is a protected mode enabled by kvm-arm.mode=protected.
nVHE-based mode with support for guests whose state is kept private from the
host. Not valid if the kernel is running in EL2.</p>
</li>
<li>
<p>hVHE: enable VHE for split hypervisor mode</p>
</li>
</ul>
</li>
</ul>
</section>

<section id="mkdocs-terminal-after-content">
    
</section>
<section id="mkdocs-terminal-revision">
<br>
<aside>
    <p>
        <small>
            <i>Page last updated 2024-11-05. </i>
        </small>
    </p>
</aside>
</section>
            </main>
        </div>
        <hr><footer>
    <div class="terminal-mkdocs-footer-grid">
        <div id="terminal-mkdocs-footer-copyright-info">
             Site built with <a href="http://www.mkdocs.org">MkDocs</a> and <a href="https://github.com/ntno/mkdocs-terminal">Terminal for MkDocs</a>.
        </div>
    </div>
</footer>
    </div>

    
    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="alertdialog" aria-modal="true" aria-labelledby="searchModalLabel">
    <div class="modal-dialog modal-lg" role="search">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="searchModalLabel">Search</h5>
                <button type="button" class="close btn btn-default btn-ghost" data-dismiss="modal"><span aria-hidden="true">x</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p id="searchInputLabel">Type to start searching</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" aria-labelledby="searchInputLabel" placeholder="" id="mkdocs-search-query" title="Please enter search terms here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No document matches found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>
    
    
</body>

</html>