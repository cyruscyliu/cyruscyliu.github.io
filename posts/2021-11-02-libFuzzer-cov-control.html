<!DOCTYPE html>
<html>
<head>
<title>2021-11-02-libFuzzer-cov-control.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>
<link rel="stylesheet" href="https://cyruscyliu.github.io/styles/light-default.css" type="text/css">
<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="coverage-control-in-libfuzzer">Coverage Control in libFuzzer</h1>
<p>This article reveals how to control the coverage collection in libFuzzer.</p>
<h2 id="how-to-use-libfuzzer">How to use libFuzzer?</h2>
<p>To use libFuzzer, it is necessary to develop a fuzz target. Please refer to
<a href="https://llvm.org/docs/LibFuzzer.html#id14">this</a> and
<a href="https://llvm.org/docs/LibFuzzer.html#id23">this</a> to check how to develop a fuzz
target and how to compile it with Clang.</p>
<h2 id="how-to-compiler-llvm-project">How to compiler LLVM project?</h2>
<p>Download llvm-project and compile like below. Please also refer to
<a href="https://llvm.org/docs/GettingStarted.html">this</a> and
<a href="https://clang.llvm.org/get_started.html">this</a>.</p>
<pre class="hljs"><code><div>git <span class="hljs-built_in">clone</span> https://github.com/llvm/llvm-project.git --depth=1
mkdir build; <span class="hljs-built_in">cd</span> build
cmake -G Ninja -DLLVM_USE_LINKER=gold -DLLVM_ENABLE_PROJECTS=<span class="hljs-string">"clang;compiler-rt"</span> -DLLVM_TARGETS_TO_BUILD=X86 -DLLVM_OPTIMIZED_TABLEGEN=ON ../llvm/
ninja clang compiler-rt
<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PWD</span>/bin:<span class="hljs-variable">$PATH</span>
</div></code></pre>
<h2 id="details-beneath--fsanitizefuzzer">Details beneath <code>-fsanitize=fuzzer</code></h2>
<p>As we all know, when compiling a program, a compiler will automatically expand
its compiler flags. If <code>-v</code> is enable, the compiler will show all flags.
Considering a very simple example: <code>clang -o foo -fsanitize=fuzzer foo.c</code>, the
full flags related to <code>-fsanitize</code> are in the following.</p>
<pre class="hljs"><code><div># SIMPLIFIED
&quot;$LLVM/bin/clang-13&quot; -cc1 \
   -triple x86_64-unknown-linux-gnu \
   -emit-obj \
   -target-cpu x86-64 -v \
   -fsanitize-coverage-type=1 -fsanitize-coverage-type=3 \
   -fsanitize-coverage-indirect-calls \
   -fsanitize-coverage-trace-cmp \
   -fsanitize-coverage-inline-8bit-counters \
   -fsanitize-coverage-pc-table \
   -fsanitize-coverage-stack-depth \
   -fsanitize-coverage-trace-state \
   -fsanitize=fuzzer,fuzzer-no-link \
   -o /tmp/main-d501e8.o -x c main.c
# SIMPLIFIED
&quot;/usr/local/bin/ld&quot; -z relro \
   --hash-style=gnu --eh-frame-hdr \
    -m elf_x86_64 \
    -dynamic-linker /lib64/ld-linux-x86-64.so.2 \
    -o main \
    $LLVM/lib/clang/13.0.0/lib/linux/libclang_rt.fuzzer-x86_64.a \
    $LLVM/lib/clang/13.0.0/lib/linux/libclang_rt.fuzzer_interceptors-x86_64.a \
    $LLVM/lib/clang/13.0.0/lib/linux/libclang_rt.ubsan_standalone-x86_64.a \
    --dynamic-list=$LLVM/lib/clang/13.0.0/lib/linux/libclang_rt.ubsan_standalone-x86_64.a.syms \
    /tmp/main-d501e8.o
</div></code></pre>
<p>It's <code>SanitizerArgs()</code> that parses SanCov and sanitizers flags. The path to it
is in the following.</p>
<pre class="hljs"><code><div> [#0] clang::driver::SanitizerArgs::SanitizerArgs()
 [#1] clang::driver::ToolChain::getSanitizerArgs() const()
 [#2] clang::driver::toolchains::Linux::isPIEDefault() const()
 [#3] clang::driver::tools::ParsePICArgs()
 [#4] clang::driver::tools::Clang::ConstructJob()
 [#5] clang::driver::Driver::BuildJobsForActionNoCache()
 [#6] clang::driver::Driver::BuildJobsForAction()
 [#7] clang::driver::Driver::BuildJobsForActionNoCache()
 [#8] clang::driver::Driver::BuildJobsForAction()
 [#9] clang::driver::Driver::BuildJobs()
[#10] clang::driver::Driver::BuildCompilation()
[#11] main()
</div></code></pre>
<p>In <code>SanitizerArgs()</code>, <code>parseArgValues</code> will parse six sanitizer related flags.
<code>parseArgValues</code> will invoke <code>parseSanitizerValue</code> defined in
<code>clang/lib/Basic/Sanitizers.cpp</code> to parse sanitizers defined
<code>clang/include/clang/Basic/Sanitizers.def</code>.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// clang/include/clang/Basic/Sanitizers.def</span>
<span class="hljs-comment">// libFuzzer</span>
SANITIZER(<span class="hljs-string">"fuzzer"</span>, Fuzzer)

<span class="hljs-comment">// libFuzzer-required instrumentation, no linking.</span>
SANITIZER(<span class="hljs-string">"fuzzer-no-link"</span>, FuzzerNoLink)
</div></code></pre>
<p>In <code>SanitizerArgs()</code>, <code>parseCoverageFeatures</code> will parse two flags:
<code>-fsanitize-coverage=&lt;value&gt;</code> and <code>-fno-sanitize-coverage=&lt;value&gt;</code> to control
what kind of coverage information for sanitizers. Try <code>clang --help | grep coverage</code> to see more related flags.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">parseCoverageFeatures</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Driver &amp;D, <span class="hljs-keyword">const</span> llvm::opt::Arg *A)</span> </span>{
  assert(A-&gt;getOption().matches(options::OPT_fsanitize_coverage) ||
         A-&gt;getOption().matches(options::OPT_fno_sanitize_coverage));
  <span class="hljs-keyword">int</span> Features = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, n = A-&gt;getNumValues(); i != n; ++i) {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *Value = A-&gt;getValue(i);
    <span class="hljs-keyword">int</span> F = llvm::StringSwitch&lt;<span class="hljs-keyword">int</span>&gt;(Value)
                .Case(<span class="hljs-string">"func"</span>, CoverageFunc)
                .Case(<span class="hljs-string">"bb"</span>, CoverageBB)
                .Case(<span class="hljs-string">"edge"</span>, CoverageEdge)
                .Case(<span class="hljs-string">"indirect-calls"</span>, CoverageIndirCall)
                .Case(<span class="hljs-string">"trace-bb"</span>, CoverageTraceBB)
                .Case(<span class="hljs-string">"trace-cmp"</span>, CoverageTraceCmp)
                .Case(<span class="hljs-string">"trace-div"</span>, CoverageTraceDiv)
                .Case(<span class="hljs-string">"trace-gep"</span>, CoverageTraceGep)
                .Case(<span class="hljs-string">"8bit-counters"</span>, Coverage8bitCounters)
                .Case(<span class="hljs-string">"trace-pc"</span>, CoverageTracePC)
                .Case(<span class="hljs-string">"trace-pc-guard"</span>, CoverageTracePCGuard)
                .Case(<span class="hljs-string">"no-prune"</span>, CoverageNoPrune)
                .Case(<span class="hljs-string">"inline-8bit-counters"</span>, CoverageInline8bitCounters)
                .Case(<span class="hljs-string">"inline-bool-flag"</span>, CoverageInlineBoolFlag)
                .Case(<span class="hljs-string">"pc-table"</span>, CoveragePCTable)
                .Case(<span class="hljs-string">"stack-depth"</span>, CoverageStackDepth)
                .Default(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (F == <span class="hljs-number">0</span>)
      D.Diag(clang::diag::err_drv_unsupported_option_argument)
          &lt;&lt; A-&gt;getOption().getName() &lt;&lt; Value;
    Features |= F;
  }
  <span class="hljs-keyword">return</span> Features;
}
</div></code></pre>
<p><code>parseCoverageFeatures</code> clearly show what kind of coverage we can control. In
the following are several tips to enable and disable these coverage flags.</p>
<ul>
<li><code>func</code>, <code>bb</code>, and <code>edge</code> are mutually exclusive</li>
<li><code>trace-bb</code> is deprecated, use <code>trace-pc-guard</code> instead</li>
<li><code>8bit-counter</code> is deprecated, use <code>trace-pc-guard</code> instead</li>
<li>if use one of <code>func</code>, <code>bb</code>, and <code>edge</code>, <code>trace-pc-guard</code> or <code>trace-pc</code> must be enabled</li>
<li>if one of <code>trace-pc</code>, <code>trace-pc-guard</code>, <code>inline-8bit-counter</code>, and <code>inline-bool-flag</code>
is enabled without any <code>func</code>, <code>bb</code>, or <code>edge</code>, then <code>edge</code> is added by default</li>
<li><code>stack-depth</code> needs <code>func</code></li>
</ul>
<p>Returning from <code>SanitizerArgs()</code>,  <code>ConstructJob</code> will invoke <code>addArgs</code> to
append flags to the command line <code>clang -o foo -fsanitize=fuzzer foo.c</code>.</p>
<pre class="hljs"><code><div>[#0] 0x55555a470fa2 → clang::driver::SanitizerArgs::addArgs()
[#1] 0x55555a3c6572 → clang::driver::tools::Clang::ConstructJob()
[#2] 0x55555a345a9a → clang::driver::Driver::BuildJobsForActionNoCache()
[#3] 0x55555a343f99 → clang::driver::Driver::BuildJobsForAction()
[#4] 0x55555a344bad → clang::driver::Driver::BuildJobsForActionNoCache()
[#5] 0x55555a343f99 → clang::driver::Driver::BuildJobsForAction()
[#6] 0x55555a34280e → clang::driver::Driver::BuildJobs()
[#7] 0x55555a3345c4 → clang::driver::Driver::BuildCompilation()
</div></code></pre>
<p><code>addArgs</code> will add corresponding flags according to the table below.</p>
<pre class="hljs"><code><div><span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *&gt; CoverageFlags[] = {
    <span class="hljs-built_in">std</span>::make_pair(CoverageFunc, <span class="hljs-string">"-fsanitize-coverage-type=1"</span>),
    <span class="hljs-built_in">std</span>::make_pair(CoverageBB, <span class="hljs-string">"-fsanitize-coverage-type=2"</span>),
    <span class="hljs-built_in">std</span>::make_pair(CoverageEdge, <span class="hljs-string">"-fsanitize-coverage-type=3"</span>),
    <span class="hljs-built_in">std</span>::make_pair(CoverageIndirCall, <span class="hljs-string">"-fsanitize-coverage-indirect-calls"</span>),
    <span class="hljs-built_in">std</span>::make_pair(CoverageTraceBB, <span class="hljs-string">"-fsanitize-coverage-trace-bb"</span>),
    <span class="hljs-built_in">std</span>::make_pair(CoverageTraceCmp, <span class="hljs-string">"-fsanitize-coverage-trace-cmp"</span>),
    <span class="hljs-built_in">std</span>::make_pair(CoverageTraceDiv, <span class="hljs-string">"-fsanitize-coverage-trace-div"</span>),
    <span class="hljs-built_in">std</span>::make_pair(CoverageTraceGep, <span class="hljs-string">"-fsanitize-coverage-trace-gep"</span>),
    <span class="hljs-built_in">std</span>::make_pair(Coverage8bitCounters, <span class="hljs-string">"-fsanitize-coverage-8bit-counters"</span>),
    <span class="hljs-built_in">std</span>::make_pair(CoverageTracePC, <span class="hljs-string">"-fsanitize-coverage-trace-pc"</span>),
    <span class="hljs-built_in">std</span>::make_pair(CoverageTracePCGuard,
                    <span class="hljs-string">"-fsanitize-coverage-trace-pc-guard"</span>),
    <span class="hljs-built_in">std</span>::make_pair(CoverageInline8bitCounters,
                    <span class="hljs-string">"-fsanitize-coverage-inline-8bit-counters"</span>),
    <span class="hljs-built_in">std</span>::make_pair(CoverageInlineBoolFlag,
                    <span class="hljs-string">"-fsanitize-coverage-inline-bool-flag"</span>),
    <span class="hljs-built_in">std</span>::make_pair(CoveragePCTable, <span class="hljs-string">"-fsanitize-coverage-pc-table"</span>),
    <span class="hljs-built_in">std</span>::make_pair(CoverageNoPrune, <span class="hljs-string">"-fsanitize-coverage-no-prune"</span>),
    <span class="hljs-built_in">std</span>::make_pair(CoverageStackDepth, <span class="hljs-string">"-fsanitize-coverage-stack-depth"</span>),
    <span class="hljs-built_in">std</span>::make_pair(CoverageTraceState, <span class="hljs-string">"-fsanitize-coverage-trace-state"</span>)};
</div></code></pre>
<p>Returning from <code>Clang::contructJob</code>, <code>addSanitizerRuntimes</code> will expand linker
flags.</p>
<pre class="hljs"><code><div>[#0] 0x55555a3dcbe2 → clang::driver::tools::addSanitizerRuntimes()
[#1] 0x55555a40cac0 → clang::driver::tools::gnutools::Linker::ConstructJob()
[#2] 0x55555a345a9a → clang::driver::Driver::BuildJobsForActionNoCache()
[#3] 0x55555a343f99 → clang::driver::Driver::BuildJobsForAction()
[#4] 0x55555a34280e → clang::driver::Driver::BuildJobs()
[#5] 0x55555a3345c4 → clang::driver::Driver::BuildCompilation()
[#6] 0x555557ddf8f7 → main()
</div></code></pre>
<p>In <code>addSanitizerRuntimes</code>, <code>collectSanitizerRuntimes</code> will collect libraries for
sanitizers.</p>
<ul>
<li>Use <code>-shared-libsan</code> (by default) or <code>-static-libsan</code> to collect dynamic or static libraries</li>
<li>use <code>-fsanitize-link-runtime&quot;</code> (by default) or <code>-fno-sanitize-link-runtime</code> to switch on or off linking</li>
</ul>
<p>To use ASAN, assign <code>-fsanitize=address</code>. If only <code>-fsanitize=fuzzer</code>, then
UBSAN will be enabled.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">SanitizerArgs::needsUbsanRt</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-comment">// All of these include ubsan.</span>
  <span class="hljs-keyword">if</span> (needsAsanRt() || needsMsanRt() || needsHwasanRt() || needsTsanRt() ||
      needsDfsanRt() || needsLsanRt() || needsCfiDiagRt() ||
      (needsScudoRt() &amp;&amp; !requiresMinimalRuntime()))
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">return</span> (Sanitizers.Mask &amp; NeedsUbsanRt &amp; ~TrapSanitizers.Mask) ||
         CoverageFeatures;
}
</div></code></pre>
<p>Shortly, if no other sanitizers is enabled, and if any coverage is enabled,
UBSAN will be enabled.</p>
<p>After <code>collectSanitizerRuntimes</code>, <code>addSanitizerRuntimes</code> will update runtimes regarding to <code>-fsanitizer=fuzzer</code>.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">SanitizerArgs::needsFuzzerInterceptors</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> needsFuzzer() &amp;&amp; !needsAsanRt() &amp;&amp; !needsTsanRt() &amp;&amp; !needsMsanRt();
}

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">tools::addSanitizerRuntimes</span><span class="hljs-params">(...)</span> </span>{
  ...
    addSanitizerRuntime(TC, Args, CmdArgs, <span class="hljs-string">"fuzzer"</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">if</span> (SanArgs.needsFuzzerInterceptors())
        addSanitizerRuntime(TC, Args, CmdArgs, <span class="hljs-string">"fuzzer_interceptors"</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);
}
</div></code></pre>
<p>BTW, <code>fuzz_interceptors</code> will be appended if no ASAN, TSAN, MSAN runtime is
enabled.</p>
<p>Finally, to narrow down the coverage collection, we can construct a command in
the following.</p>
<pre class="hljs"><code><div>clang -o foo -fsanitize=fuzzer \
    -fno-sanitize-coverage=indirect-calls,trace-cmp,stack-depth,pc-table \
    foo.c
</div></code></pre>
<p>In this way, only <code>edge</code> and <code>inline-8bit-counters</code> are enabled.</p>
<h2 id="flow-of-instrumentations">Flow of instrumentations</h2>
<p>The module pass <code>SanitizerCoverage</code>
(llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp) will instrument
coverage flag to each module.</p>
<p>In the first state, <code>SanitizerCoverage</code> will construct the IR of stubs to be
instrumented. A classic pattern is in the following.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> SanCovTracePCIndirName[] = <span class="hljs-string">"__sanitizer_cov_trace_pc_indir"</span>;
SanCovTracePCIndir = M.getOrInsertFunction(SanCovTracePCIndirName, VoidTy, IntptrTy);
</div></code></pre>
<p>In the second state, <code>SanitizerCoverage</code> will traverse all IR code and do
instrumentation at the proper position.</p>
<pre class="hljs"><code><div>IRB.CreateCall(SanCovTracePCIndir, IRB.CreatePointerCast(Callee, IntptrTy));
</div></code></pre>
<p>The overall flow of <code>SanitizerCoverage</code> is in the following.</p>
<pre class="hljs"><code><div>instrumentModule
    - stage 1
    - for (auto &amp;F : M) { instrumentFunction(F); }
instrumentFunction
    - split edges if edge coverage[^1]
    - for (auto &amp;BB : F) {
        BlocksToInstrument.push_back(&amp;BB);
        for (auto &amp;Inst: BB) { /* simplified */
          if (IndirectCalls &amp;&amp; xxx) IndirCalls.push_back(&amp;Inst)
          if (TraceCmp &amp;&amp; xxx) CmpTraceTargets.push_back(&amp;Inst)
          if (TraceCmp &amp;&amp; xxx) SwitchTraceTargets.push_back(&amp;Inst)
          if (TraceDiv &amp;&amp; xxx) DivTraceTargets.push_back(BO)
          if (TraceGep &amp;&amp; xxx) GepTraceTargets.push_back(BO)
          if (TraceStackDepth &amp;&amp; xxx) IsLeafFunc = false;
        }
      }
    - stage 2
        InjectCoverage(F, BlocksToInstrument, IsLeafFunc);
        InjectCoverageForIndirectCalls(F, IndirCalls);
        InjectTraceForCmp(F, CmpTraceTargets);
        InjectTraceForSwitch(F, SwitchTraceTargets);
        InjectTraceForDiv(F, DivTraceTargets);
        InjectTraceForGep(F, GepTraceTargets);
</div></code></pre>
<p>The key function in stage 2 is <code>InjectCoverage</code>.</p>
<p><code>InjectCoverage</code> first create FunctionGuardArray, Function8bitCounterArray,
FunctionBoolArray, or FunctionPCsArray in <code>CreateFunctionLocalArrays</code>, then
invoke <code>InjectCoverageAtBlock</code> to handle each basic blocks.
<code>InjectCoverageAtBlock</code> will instrument <code>SanCovTracePC</code>, <code>SanCovTracePCGuard</code>,
<code>Inline8BitCounters</code>, or <code>InlineBoolFlag</code>, or update the lowest stack frame, for
each basic block.</p>
<h2 id="details-of-stubs">Details of stubs</h2>
<p>Please also refer to <a href="https://clang.llvm.org/docs/SanitizerCoverage.html">this</a>.</p>
<h3 id="sanitizercovindircall">__sanitizer_cov_indir_call</h3>
<p>This will be in front of an indirect call. It requires at least one of
<code>trace-pc</code>, <code>trace-pc-guard</code>, <code>inline-8bit-counters</code>, and <code>inline-bool-flag</code>.
It accepts one parameter, the callee address. The address of the caller is
passed implicitly via caller PC. Importantly, if the callee is inline assembly,
the indirect call will not be instrumented. Its implementation in libFuzzer is
in the following. In the end, new information will be updated into the value
profile.</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GET_CALLER_PC() __builtin_return_address(0)</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TracePC::HandleCallerCallee</span><span class="hljs-params">(<span class="hljs-keyword">uintptr_t</span> Caller, <span class="hljs-keyword">uintptr_t</span> Callee)</span> </span>{
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">uintptr_t</span> kBits = <span class="hljs-number">12</span>;
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">uintptr_t</span> kMask = (<span class="hljs-number">1</span> &lt;&lt; kBits) - <span class="hljs-number">1</span>;
  <span class="hljs-keyword">uintptr_t</span> Idx = (Caller &amp; kMask) | ((Callee &amp; kMask) &lt;&lt; kBits);
  ValueProfileMap.AddValueModPrime(Idx);
}

<span class="hljs-keyword">void</span> __sanitizer_cov_trace_pc_indir(<span class="hljs-keyword">uintptr_t</span> Callee) {
  <span class="hljs-keyword">uintptr_t</span> PC = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uintptr_t</span>&gt;(GET_CALLER_PC());
  fuzzer::TPC.HandleCallerCallee(PC, Callee);
}
</div></code></pre>
<h3 id="sanitizercovtraceconstcmp1248"><em><em>sanitizer_cov_trace</em>[const</em>]cmp[1|2|4|8]</h3>
<p>These will be in front of a cmp instruction with const operand or not. They
accept both operands to be compared. The address of the caller is passed
implicitly via caller PC. One of its implementation in libFuzzer is in the
following. In the end, new information will be updated into the value profile.</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GET_CALLER_PC() __builtin_return_address(0)</span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">TracePC</span>:</span>:HandleCmp(<span class="hljs-keyword">uintptr_t</span> PC, T Arg1, T Arg2) {
  <span class="hljs-keyword">uint64_t</span> ArgXor = Arg1 ^ Arg2;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">sizeof</span>(T) == <span class="hljs-number">4</span>)
      TORC4.Insert(ArgXor, Arg1, Arg2);
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">sizeof</span>(T) == <span class="hljs-number">8</span>)
      TORC8.Insert(ArgXor, Arg1, Arg2);
  <span class="hljs-keyword">uint64_t</span> HammingDistance = Popcountll(ArgXor);  <span class="hljs-comment">// [0,64]</span>
  <span class="hljs-keyword">uint64_t</span> AbsoluteDistance = (Arg1 == Arg2 ? <span class="hljs-number">0</span> : Clzll(Arg1 - Arg2) + <span class="hljs-number">1</span>);
  ValueProfileMap.AddValue(PC * <span class="hljs-number">128</span> + HammingDistance);
  ValueProfileMap.AddValue(PC * <span class="hljs-number">128</span> + <span class="hljs-number">64</span> + AbsoluteDistance);
}

<span class="hljs-keyword">void</span> __sanitizer_cov_trace_cmp1(<span class="hljs-keyword">uint8_t</span> Arg1, <span class="hljs-keyword">uint8_t</span> Arg2) {
  <span class="hljs-keyword">uintptr_t</span> PC = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uintptr_t</span>&gt;(GET_CALLER_PC());
  fuzzer::TPC.HandleCmp(PC, Arg1, Arg2);
}
</div></code></pre>
<p>Similarly stubs are <code>__sanitizer_cov_trace_switch</code>,
<code>__sanitizer_cov_trace_div[4|8]</code>, and <code>__sanitizer_cov_trace_gep</code>.  They all
invoke HandleCmp at the end to update new information into the value profile.</p>
<h3 id="sanitizercovtracepc">__sanitizer_cov_trace_pc</h3>
<p>This will be at the entry of each basic block. The address of the caller is
passed implicitly via caller PC. This is deprecated.</p>
<h3 id="sanitizercovtracepcguardinit">__sanitizer_cov_trace_pc_guard[_init]</h3>
<p><code>__sanitizer_cov_trace_pc_guard</code> will be at the entry of each basic block after
<code>__sanitier_cov_trace_pc</code>. The address of the caller is passed implicitly via
caller PC. They are deprecated.</p>
<p>Each function would have a function guard array <code>int32_t FunctionGuardArray[]</code>
whose size is the number of the basic blocks. This array is associated with
<code>sancov_guards</code> section. <code>__sanitizer_cov_trace_pc_guard</code> accepts
<code>FunctionGuardArray[IdxofBB]</code> as the guard.</p>
<p>If any function guard array, SanCov will create a section named
<code>sancov.module_ctor_trace_pc_guard</code> to invoke
<code>__sanitizer_cov_trace_pc_guard_init</code> to initialize <code>sancov_guards</code> for each
module.</p>
<p>[NOT SURE] In the end, after linking, there will be one <code>sancov_guards</code> and one
<code>sancov.module_ctor_trace_pc_guard</code>.</p>
<h3 id="sanitizercov8bitcountersinit">__sanitizer_cov_8bit_counters_init</h3>
<p>The inline 8bit counters will be at the entry of each basic block after
<code>__sanitizer_cov_trace_pc_guard</code>.</p>
<p>Each function would have a function 8bit counter array <code>int8_t Function8BitArray[]</code> whose size is the number of the basic blocks. This array is
associated with <code>sancov_cntrs</code> section. If a basic block is visited, then the
corresponding byte in the array will be increased by 1.</p>
<p>If any function 8bit array, SanCov will create a section named
<code>sancov.module_ctor_8bit_counters</code> to invoke
<code>__sanitizer_cov_8bit_counters_init</code> to initialize <code>sancov_cntrs</code> for each
module.</p>
<p>[NOT SURE] In the end, after linking, there will be one <code>sancov_cntrs</code> and one
<code>sancov.module_ctor_8bit_counters</code>.</p>
<p><code>__sanitizer_cov_8bit_counters_init</code> is defined in the following. It shows the
counter information flows to <code>Modules</code> in the libFuzzer. In short, <code>Modules</code>
records the start and the stop address of the <code>sancov_cntrs</code> divided by page
(<code>Region</code>).</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TracePC::HandleInline8bitCountersInit</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *Start, <span class="hljs-keyword">uint8_t</span> *Stop)</span> </span>{
  <span class="hljs-keyword">if</span> (Start == Stop) <span class="hljs-keyword">return</span>;
  <span class="hljs-keyword">if</span> (NumModules &amp;&amp;
      Modules[NumModules - <span class="hljs-number">1</span>].Start() == Start)
    <span class="hljs-keyword">return</span>;
  assert(NumModules &lt;
         <span class="hljs-keyword">sizeof</span>(Modules) / <span class="hljs-keyword">sizeof</span>(Modules[<span class="hljs-number">0</span>]));
  <span class="hljs-keyword">auto</span> &amp;M = Modules[NumModules++];
  <span class="hljs-keyword">uint8_t</span> *AlignedStart = RoundUpByPage(Start);
  <span class="hljs-keyword">uint8_t</span> *AlignedStop  = RoundDownByPage(Stop);
  <span class="hljs-keyword">size_t</span> NumFullPages = AlignedStop &gt; AlignedStart ?
                        (AlignedStop - AlignedStart) / PageSize() : <span class="hljs-number">0</span>;
  <span class="hljs-keyword">bool</span> NeedFirst = Start &lt; AlignedStart || !NumFullPages;
  <span class="hljs-keyword">bool</span> NeedLast  = Stop &gt; AlignedStop &amp;&amp; AlignedStop &gt;= AlignedStart;
  M.NumRegions = NumFullPages + NeedFirst + NeedLast;;
  assert(M.NumRegions &gt; <span class="hljs-number">0</span>);
  M.Regions = <span class="hljs-keyword">new</span> Module::Region[M.NumRegions];
  assert(M.Regions);
  <span class="hljs-keyword">size_t</span> R = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">if</span> (NeedFirst)
    M.Regions[R++] = {Start, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">min</span>(Stop, AlignedStart), <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>};
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint8_t</span> *P = AlignedStart; P &lt; AlignedStop; P += PageSize())
    M.Regions[R++] = {P, P + PageSize(), <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>};
  <span class="hljs-keyword">if</span> (NeedLast)
    M.Regions[R++] = {AlignedStop, Stop, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>};
  assert(R == M.NumRegions);
  assert(M.Size() == (<span class="hljs-keyword">size_t</span>)(Stop - Start));
  assert(M.Stop() == Stop);
  assert(M.Start() == Start);
  NumInline8bitCounters += M.Size();
}

<span class="hljs-keyword">void</span> __sanitizer_cov_8bit_counters_init(<span class="hljs-keyword">uint8_t</span> *Start, <span class="hljs-keyword">uint8_t</span> *Stop) {
  fuzzer::TPC.HandleInline8bitCountersInit(Start, Stop);
}
</div></code></pre>
<h3 id="sanitizercovboolflaginit">__sanitizer_cov_bool_flag_init</h3>
<p>The inline bool flag will be at the entry of each basic block after the inline
8bit counters.</p>
<p>Each function would have a function 1 bit array <code>int1_t FunctionBoolArray[]</code>
whose size is the number of the basic blocks. This array is associated with
<code>sancov_bools</code> section. If a basic block is visited, then the corresponding bit
in the array will be true.</p>
<p>If any function bool array, SanCov will create a section named
<code>sancov.module_ctor_bool_flag</code> to invoke <code>__sanitizer_cov_bool_flag_init</code> to
initilize <code>sancov_bools</code> for each module.</p>
<p>[NOT SURE] In the end, after linking, there will be one <code>sancov_bools</code> and one
<code>sancov.module_ctor_bool_flag</code>.</p>
<p><code>__sanitizer_cov_bool_flag_init</code> is not defined in the libFuzzer.</p>
<h3 id="sanitizercovpcsinit">__sanitizer_cov_pcs_init</h3>
<p>For each function, SanCov creates a PC array associated with <code>sancov_pcs</code> to
store <code>{PC, PCFlags}</code> pairs. PC is the address of the corresponding basic block,
and a PCFlags describes the basic block is the function entry block (1) or not
(0).</p>
<p>If one of the <code>trace-pc-guard</code>, <code>inline-8bit-counters</code>, and <code>inline-bool-flag</code>,
and any function PC array, SanCov will invoke <code>__sanitizer_cov_pcs_init</code> to
initilize <code>sancov_pcs</code> for each module in one of the section: <code>sancov.xxx</code>.</p>
<p>[NOT SURE] In the end, after linking, there will be one <code>sancov_pcs</code>.</p>
<p><code>__sanitizer_cov_pcs_init</code> is defined in the following. In short, the
information flows to <code>ModulePCTable</code> in libFuzzer.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TracePC::HandlePCsInit</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uintptr_t</span> *Start, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uintptr_t</span> *Stop)</span> </span>{
  <span class="hljs-keyword">const</span> PCTableEntry *B = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> PCTableEntry *&gt;(Start);
  <span class="hljs-keyword">const</span> PCTableEntry *E = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> PCTableEntry *&gt;(Stop);
  <span class="hljs-keyword">if</span> (NumPCTables &amp;&amp; ModulePCTable[NumPCTables - <span class="hljs-number">1</span>].Start == B) <span class="hljs-keyword">return</span>;
  assert(NumPCTables &lt; <span class="hljs-keyword">sizeof</span>(ModulePCTable) / <span class="hljs-keyword">sizeof</span>(ModulePCTable[<span class="hljs-number">0</span>]));
  ModulePCTable[NumPCTables++] = {B, E};
  NumPCsInPCTables += E - B;
}

<span class="hljs-keyword">void</span> __sanitizer_cov_pcs_init(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uintptr_t</span> *pcs_beg,
                              <span class="hljs-keyword">const</span> <span class="hljs-keyword">uintptr_t</span> *pcs_end) {
  fuzzer::TPC.HandlePCsInit(pcs_beg, pcs_end);
}
</div></code></pre>
<h3 id="a-brief-list-of-flag-stubs-and-information-sink-in-libfuzzer">A brief list of (flag, stubs, and information sink in libFuzzer)</h3>
<table>
<thead>
<tr>
<th style="text-align:center">Flag</th>
<th style="text-align:center">Stubs</th>
<th style="text-align:center">Information Sink</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">trace-pc,indirect-calls</td>
<td style="text-align:center">__sanitizer_cov_trace_pc_indirect</td>
<td style="text-align:center">ValueProfileMap</td>
</tr>
<tr>
<td style="text-align:center">trace-pc-guard,indirect-calls</td>
<td style="text-align:center">__sanitizer_cov_trace_pc_indirect</td>
<td style="text-align:center">ValueProfileMap</td>
</tr>
<tr>
<td style="text-align:center">inline-8bit-counters,indirect-calls</td>
<td style="text-align:center">__sanitizer_cov_trace_pc_indirect</td>
<td style="text-align:center">ValueProfileMap</td>
</tr>
<tr>
<td style="text-align:center">inline-bool-flag,indirect-calls</td>
<td style="text-align:center">__sanitizer_cov_trace_pc_indirect</td>
<td style="text-align:center">ValueProfileMap</td>
</tr>
<tr>
<td style="text-align:center">trace-cmp</td>
<td style="text-align:center">__sanitizer_cov_trace_[const_]cmp[1|2|4|8]</td>
<td style="text-align:center">ValuleProfileMap</td>
</tr>
<tr>
<td style="text-align:center">trace-switch</td>
<td style="text-align:center">__sanitizer_cov_trace_switch</td>
<td style="text-align:center">ValuleProfileMap</td>
</tr>
<tr>
<td style="text-align:center">trace-div</td>
<td style="text-align:center">__sanitizer_cov_trace_div[4|8]</td>
<td style="text-align:center">ValuleProfileMap</td>
</tr>
<tr>
<td style="text-align:center">trace-gep</td>
<td style="text-align:center">__sanitizer_cov_trace_gep</td>
<td style="text-align:center">ValuleProfileMap</td>
</tr>
<tr>
<td style="text-align:center">trace-pc</td>
<td style="text-align:center">__sanitizer_cov_trace_pc</td>
<td style="text-align:center">deprecated</td>
</tr>
<tr>
<td style="text-align:center">trace-pc-guard</td>
<td style="text-align:center">__sanitizer_cov_trace_pc_guard[_init]</td>
<td style="text-align:center">deprecated</td>
</tr>
<tr>
<td style="text-align:center">inline-8bit-counters</td>
<td style="text-align:center">__sanitizer_cov_8bit_counters_init</td>
<td style="text-align:center">Modules</td>
</tr>
<tr>
<td style="text-align:center">inline-bool-flag</td>
<td style="text-align:center">__sanitizer_cov_bool_flag_init</td>
<td style="text-align:center">not supported</td>
</tr>
<tr>
<td style="text-align:center">trace-pc-guard,pc-table</td>
<td style="text-align:center">__sanitizer_cov_pcs_init</td>
<td style="text-align:center">ModulePCTable</td>
</tr>
<tr>
<td style="text-align:center">inline-8bit-guard,pc-table</td>
<td style="text-align:center">__sanitizer_cov_pcs_init</td>
<td style="text-align:center">ModulePCTable</td>
</tr>
<tr>
<td style="text-align:center">inline-bool-flag,pc-table</td>
<td style="text-align:center">__sanitizer_cov_pcs_init</td>
<td style="text-align:center">ModulePCTable</td>
</tr>
</tbody>
</table>
<p>edge-coverage](https://clang.llvm.org/docs/SanitizerCoverage.html#edge-coverage)</p>

</body>
</html>
